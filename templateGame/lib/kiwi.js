/**
*
* @module Kiwi
*
*/
var Kiwi;
(function (Kiwi) {
    /**
    * The base class that is used when you create a new Game. Handles the initialisation of all of the various individual game managers and holds the RAF (RequestAnimationFrame object) which is used for the game loop.
    *
    * @class Game
    * @namespace Kiwi
    * @constructor
    * @param [domParent=''] {String} The ID of a DOM element that the game should use as its 'container'. If you are targeting Cocoon then you don't need to worry about this and can leave it blank.
    * @param [name='KiwiGame'] {String} The name of the game that is being created.
    * @param [state=null] {Any} The state to load initially. This can either be the name of a state, but preferably this would be the state object itself.
    * @param [options] {Object} Any special options for the game. E.g. Is DEBUG_ON or DEBUG_OFF, RENDERER_CANVAS or RENDERER_WEBGL, TARGET_BROWSER or TARGET_COCOON
    *   @param [options.debug=Kiwi.DEBUG_ON] {Number} If debugging is enabled or not.
    *   @param [options.bootCallback=null] {Function} A callback to be executed when the game reaches the boot stage.
    *   @param [options.deviceTarget=Kiwi.TARGET_BROWSER] {Number} The type of device Kiwi is being used on.
    *   @param [options.renderer=Kiwi.RENDERER_AUTO] {Number} The renderer Kiwi should use.
    *   @param [options.width=Kiwi.Stage.DEFAULT_WIDTH] {Number} The width of this instance of Kiwi.
    *   @param [options.height=Kiwi.Stage.DEFAULT_HEIGHT] {Number} The height of this instance of Kiwi.
    *   @param [options.scaleType=Kiwi.Stage.SCALE_NONE] {Number} The type of scaling that should be applied to Kiwi.
    *   @param [options.plugins=[]] {Array} A list of the names of plugins that are to be used with this game.
    *   @param [options.log] {Object} Default state of the Log properties
    *       @param [options.log.recording=true] {Boolean} If the logs should be recorded.
    *       @param [options.log.display=true] {Boolean} If the logs should be displayed or not.
    *       @param [options.log.enabled=true] {Boolean} If the Logger is enabled at all.
    *       @param [options.log.maxRecordings=Infinity] {Number} The maximum number of recordings to have at a single time.
    * @return {Kiwi.Game}
    *
    */
    var Game = (function () {
        function Game(domParent, name, state, options) {
            var _this = this;
            if (domParent === void 0) { domParent = ''; }
            if (name === void 0) { name = 'KiwiGame'; }
            if (state === void 0) { state = null; }
            if (options === void 0) { options = {}; }
            /**
            * The object that peforms DOM and device startup operations for browsers (ie not cocoon)
            * @property _startup
            * @type Kiwi.System.Bootstrap
            * @private
            */
            this._startup = null;
            /**
            * The audio manager that handles all of the audio in game. Inside you can globally mute the audio, create new sounds, e.t.c.
            * @property audio
            * @type Kiwi.Sound.AudioManager
            * @public
            */
            this.audio = null;
            /**
            * The global file store for this game. This handles the storage and access of information loaded, as well as tags that maybe set for them individual files.
            * @property fileStore
            * @type Kiwi.Files.FileStore
            * @public
            */
            this.fileStore = null;
            /**
            * Handles any user input with the game. These could via the users keyboard, mouse or touch events.
            * @property input
            * @type Kiwi.Input.InputManager
            * @public
            */
            this.input = null;
            /**
            * Manages the cameras the are on the stage. Single default Camera only in this version.
            * @property cameras
            * @type Kiwi.CameraManager
            * @public
            */
            this.cameras = null;
            /**
            * Manages plugins registration and initialisation for the game instance.
            * @property pluginManager
            * @type Kiwi.PluginManager
            * @public
            */
            this.pluginManager = null;
            /**
            * Loads files from outside sources and checks to see that they have loaded correctly or not.
            * @property loader
            * @type Kiwi.Files.Loader
            * @public
            */
            this.loader = null;
            /**
            * The Request Animation Frame that is being used for the update and render loops.
            * @property raf
            * @type Kiwi.Utils.RequestAnimationFrame
            * @public
            */
            this.raf = null;
            /**
            * The ONLY stage that is being used for this game.
            * @property stage
            * @type Stage
            * @public
            */
            this.stage = null;
            /**
            * Manages all of the states that exist for this game. Via the manager you can create new states, switch states and do various other tasks.
            * @property states
            * @type Kiwi.StateManager
            * @public
            */
            this.states = null;
            /**
            * Holds a reference to the clocks that are being used and has a MASTER clock that is being used for the game.
            * @property time
            * @type Kiwi.Time.ClockManager
            * @public
            */
            this.time = null;
            /**
            * The tween manager holds a reference to all of the tweens that are created and currently being used.
            * @property tweens
            * @type Kiwi.Animations.Tweens.TweenManager
            * @public
            */
            this.tweens = null;
            /**
            * A Random Data Generator. This is useful for create unique ids and random information.
            * @property rnd
            * @type Kiwi.Utils.RandomDataGenerato
            * @public
            */
            this.rnd = null;
            /**
            * The framerate at which the game will update at.
            * @property _framerate
            * @type Number
            * @default 60
            * @private
            */
            this._frameRate = 60;
            /**
            * The interval between frames.
            * @property _interval
            * @type Number
            * @default 1000/60
            * @private
            */
            this._interval = 1000 / 60;
            /**
            * The current interval between frames.
            * @property _delta
            * @type number
            * @private
            */
            this._delta = 0;
            /**
            * The number of frames since the game was launched.
            * @property _frame
            * @type number
            * @private
            * @since 1.1.0
            */
            this._frame = 0;
            Kiwi.Log.setDefaultsFromParams(options.log);
            Kiwi.Log.log('Kiwi.Game: ' + name + ' is booting using Kiwi.js ' + Kiwi.VERSION, '#version');
            if (Kiwi.DEVICE === null) {
                Kiwi.DEVICE = new Kiwi.System.Device();
            }
            if (options.debug !== 'undefined' && typeof options.debug === 'number') {
                switch (options.debug) {
                    case Kiwi.DEBUG_ON:
                        this._debugOption = options.debug;
                        Kiwi.Log.log('  Kiwi.Game: Debugging turned ON.', '#debugging');
                        break;
                    case Kiwi.DEBUG_OFF:
                        this._debugOption = options.debug;
                        Kiwi.Log.log('  Kiwi.Game: Debugging turned OFF.', '#debugging');
                        break;
                    default:
                        this._debugOption = Kiwi.DEBUG_ON;
                        Kiwi.Log.error('  Kiwi.Game: Debug option passed, but is not a valid option. Turned ON by default.', '#debugging');
                        break;
                }
            }
            else {
                this._debugOption = Kiwi.DEBUG_ON;
                Kiwi.Log.log('  Kiwi.Game: Debug option not specified. Turned ON by default.', '#debugging');
            }
            if (options.bootCallback !== 'undefined') {
                this.bootCallbackOption = options.bootCallback;
            }
            //Which device are they targetting
            if (options.deviceTarget !== 'undefined' && typeof options.deviceTarget === 'number') {
                switch (options.deviceTarget) {
                    case Kiwi.TARGET_BROWSER:
                        this._deviceTargetOption = options.deviceTarget;
                        Kiwi.Log.log('  Kiwi.Game: Targeting BROWSERS.', '#target');
                        break;
                    case Kiwi.TARGET_COCOON:
                        this._deviceTargetOption = options.deviceTarget;
                        Kiwi.Log.log('  Kiwi.Game: Targeting COCOONJS.', '#target');
                        break;
                    default:
                        this._deviceTargetOption = Kiwi.TARGET_BROWSER;
                        Kiwi.Log.error('  Kiwi.Game: Target device specified, but is not a valid option. Defaulting to BROWSER.', '#target');
                        break;
                }
            }
            else {
                this._deviceTargetOption = Kiwi.TARGET_BROWSER;
                Kiwi.Log.log('  Kiwi.Game: Targeted device not specified. Defaulting to BROWSER.', '#target');
            }
            var renderDefault = Kiwi.RENDERER_WEBGL;
            var renderFallback = Kiwi.RENDERER_CANVAS;
            // Optimise renderer request
            if (options.renderer !== 'undefined' && typeof options.renderer === 'number') {
                switch (options.renderer) {
                    case Kiwi.RENDERER_CANVAS:
                        this._renderOption = options.renderer;
                        Kiwi.Log.log('  Kiwi.Game: Rendering using CANVAS.', '#renderer', '#canvas');
                        break;
                    case Kiwi.RENDERER_WEBGL:
                        if (Kiwi.DEVICE.webGL) {
                            this._renderOption = options.renderer;
                            Kiwi.Log.log('  Kiwi.Game: Rendering using WEBGL.', '#renderer', '#webgl');
                        }
                        else {
                            this._renderOption = renderFallback;
                            Kiwi.Log.log('  Kiwi.Game: WEBGL renderer requested but device does not support WEBGL. Rendering using CANVAS.', '#renderer', '#canvas');
                        }
                        break;
                    case Kiwi.RENDERER_AUTO:
                        if (Kiwi.DEVICE.webGL) {
                            this._renderOption = renderDefault;
                            Kiwi.Log.log('  Kiwi.Game: Renderer auto-detected WEBGL.', '#renderer', '#webgl');
                        }
                        else {
                            this._renderOption = renderFallback;
                            Kiwi.Log.log('  Kiwi.Game: Renderer auto-detected CANVAS.', '#renderer', '#canvas');
                        }
                        break;
                    default:
                        if (Kiwi.DEVICE.webGL) {
                            this._renderOption = renderDefault;
                            Kiwi.Log.log('  Kiwi.Game: Renderer specified, but is not a valid option. Defaulting to WEBGL.', '#renderer', '#webgl');
                        }
                        else {
                            this._renderOption = renderFallback;
                            Kiwi.Log.log('  Kiwi.Game: Renderer specified, but is not a valid option. WEBGL renderer sought by default but device does not support WEBGL. Defaulting to CANVAS.', '#renderer', '#canvas');
                        }
                        break;
                }
            }
            else {
                if (Kiwi.DEVICE.webGL) {
                    this._renderOption = renderDefault;
                    Kiwi.Log.log('  Kiwi.Game: Renderer not specified. Defaulting to WEBGL.', '#renderer', '#webgl');
                }
                else {
                    this._renderOption = renderFallback;
                    Kiwi.Log.log('  Kiwi.Game: Renderer not specified. WEBGL renderer sought by default but device does not support WEBGL. Defaulting to CANVAS.', '#renderer', '#canvas');
                }
            }
            this.id = Kiwi.GameManager.register(this);
            this._startup = new Kiwi.System.Bootstrap();
            this.audio = new Kiwi.Sound.AudioManager(this);
            this.fileStore = new Kiwi.Files.FileStore(this);
            this.input = new Kiwi.Input.InputManager(this);
            // Width / Height
            var width = Kiwi.Stage.DEFAULT_WIDTH;
            var height = Kiwi.Stage.DEFAULT_HEIGHT;
            if (options.width !== 'undefined' && typeof options.width === 'number') {
                width = options.width;
            }
            if (options.height !== 'undefined' && typeof options.height === 'number') {
                height = options.height;
            }
            Kiwi.Log.log('  Kiwi.Game: Stage Dimensions: ' + width + 'x' + height, '#dimensions');
            if (!Kiwi.Utils.Common.isUndefined(options.scaleType)) {
                switch (options.scaleType) {
                    case Kiwi.Stage.SCALE_FIT:
                        Kiwi.Log.log('  Kiwi.Game: Stage scaling set to FIT.', '#scaling');
                        break;
                    case Kiwi.Stage.SCALE_STRETCH:
                        Kiwi.Log.log('  Kiwi.Game: Stage scaling set to STRETCH.', '#scaling');
                        break;
                    case Kiwi.Stage.SCALE_NONE:
                        Kiwi.Log.log('  Kiwi.Game: Stage scaling set to NONE.', '#scaling');
                        break;
                    default:
                        Kiwi.Log.log('  Kiwi.Game: Stage specified, but is not a valid option. Set to NONE.', '#scaling');
                        options.scaleType = 0;
                        break;
                }
            }
            else {
                Kiwi.Log.log('  Kiwi.Game: Stage scaling not specified, defaulting to NONE.', '#scaling');
                options.scaleType = 0;
            }
            this.stage = new Kiwi.Stage(this, name, width, height, options.scaleType);
            this.renderer = null;
            this.cameras = new Kiwi.CameraManager(this);
            if (this._deviceTargetOption !== Kiwi.TARGET_COCOON)
                this.huds = new Kiwi.HUD.HUDManager(this);
            this.loader = new Kiwi.Files.Loader(this);
            this.states = new Kiwi.StateManager(this);
            this.rnd = new Kiwi.Utils.RandomDataGenerator([Date.now.toString()]);
            this.time = new Kiwi.Time.ClockManager(this);
            this.tweens = new Kiwi.Animations.Tweens.TweenManager(this);
            //  If we have a state then pass it to the StateManager
            if (state !== null) {
                this.states.addState(state, true);
            }
            else {
                Kiwi.Log.log('  Kiwi.Game: Default State not passed.', '#state');
            }
            this.pluginManager = new Kiwi.PluginManager(this, options.plugins);
            if (this.deviceTargetOption === Kiwi.TARGET_BROWSER) {
                this._startup.boot(domParent, function () { return _this._start(); });
            }
            else {
                if (domParent !== '') {
                    Kiwi.Log.log('  Kiwi.Game: Not Targetting a BROWSER. DOM Parent parameter ignored.', '#dom');
                }
                this._start();
            }
        }
        Object.defineProperty(Game.prototype, "renderOption", {
            /**
            * Returns the render mode of the game. This is READ ONLY and is decided once the game gets initialised.
            * @property renderOption
            * @type number
            * @public
            */
            get: function () {
                return this._renderOption;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Game.prototype, "deviceTargetOption", {
            /**
            * Returns the device target option for the game. This is READ ONLY and is decided once the game gets initialised.
            * @property deviceTargetOption
            * @type number
            * @public
            */
            get: function () {
                return this._deviceTargetOption;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Game.prototype, "debugOption", {
            /**
            * Returns the debug option. This is READ ONLY and is decided once the game gets initialised.
            * @property debugOption
            * @type number
            * @public
            */
            get: function () {
                return this._debugOption;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Game.prototype, "debug", {
            /**
            * Returns true if debug option is set to Kiwi.DEBUG_ON
            * @property debug
            * @type boolean
            * @public
            */
            get: function () {
                return this._debugOption === Kiwi.DEBUG_ON;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * The type of object that the game is.
        * @method objType
        * @return {String} "Game"
        * @public
        */
        Game.prototype.objType = function () {
            return "Game";
        };
        Object.defineProperty(Game.prototype, "frame", {
            /**
            * The number of frames since the game was launched.
            *
            * Use this to drive cyclic animations. You may manually reset it in a Kiwi.State.create() function to restart the count from 0.
            *
            * The largest exact integer value of a JavaScript number is 2^53, or 9007199254740992. At 60 frames per second, this will take 4,760,273 years to become inaccurate.
            * @property frame
            * @type number
            * @public
            * @since 1.1.0
            */
            get: function () {
                return (this._frame);
            },
            set: function (value) {
                this._frame = Kiwi.Utils.GameMath.truncate(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Game.prototype, "idealFrame", {
            /**
            * The number of ideal frames since the game was launched.
            *
            * Use this to drive cyclic animations. This will be smoother than using the frame parameter. It is derived from the total time elapsed since the game launched.
            * @property idealFrame
            * @type number
            * @public
            * @since 1.1.0
            */
            get: function () {
                return (this.time.elapsed() / (1000 / this._frameRate));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Game.prototype, "frameRate", {
            /**
            * The current frameRate that the update/render loops are running at. Note that this may not be an  accurate representation.
            * @property frameRate
            * @return string
            * @public
            */
            get: function () {
                return this._frameRate;
            },
            set: function (value) {
                if (value > 0) {
                    this._frameRate = value;
                    this._interval = 1000 / this._frameRate;
                    this.time.setMasterInterval(this._interval);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
        * The start method gets executed when the game is ready to be booted, and handles the start-up of the managers.
        * Once the managers have started up the start loop will then begin to create the game loop.
        * @method start
        * @private
        */
        Game.prototype._start = function () {
            var _this = this;
            this.stage.boot(this._startup);
            if (!this.stage.renderer)
                Kiwi.Log.error("  Kiwi.Game: Could not create rendering context", '#renderer');
            if (this._renderOption === Kiwi.RENDERER_WEBGL && this.stage.ctx)
                this._renderOption = Kiwi.RENDERER_CANVAS; // Adapt to fallback if WebGL failed
            this.renderer = this.stage.renderer;
            this.renderer.boot();
            this.cameras.boot();
            if (this._deviceTargetOption !== Kiwi.TARGET_COCOON)
                this.huds.boot();
            this.time.boot();
            this.input.boot();
            this.audio.boot();
            this.fileStore.boot();
            this.loader.boot();
            this.states.boot();
            this.pluginManager.boot();
            this._lastTime = Date.now();
            this.raf = new Kiwi.Utils.RequestAnimationFrame(function () { return _this._loop(); });
            this.raf.start();
            if (this.bootCallbackOption) {
                Kiwi.Log.log("  Kiwi.Game: invoked boot callback", '#boot');
                this.bootCallbackOption(this);
            }
        };
        /**
        * The game loop.
        * @method _loop
        * @private
        */
        Game.prototype._loop = function () {
            // Only update non-graphical game systems if a full frame
            // has passed
            this._delta = this.raf.currentTime - this._lastTime;
            if (this._delta > this._interval) {
                this.time.update();
                this.audio.update();
                this.input.update();
                this.tweens.update();
                this.cameras.update();
                if (this._deviceTargetOption !== Kiwi.TARGET_COCOON) {
                    this.huds.update();
                }
                this.states.update();
                this.pluginManager.update();
                this._frame++;
                this._lastTime =
                    this.raf.currentTime - (this._delta % this._interval);
            }
            // Graphics MUST be drawn every frame to avert frame buffer issues
            // under some clients
            if (this.states.current !== null) {
                // Only update if there is a current state
                this.cameras.render();
                this.states.postRender();
            }
        };
        return Game;
    })();
    Kiwi.Game = Game;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
*
*/
var Kiwi;
(function (Kiwi) {
    /**
    * Each game contains a single Stage which controls the creation and
    * management of main domElements required for a Kiwi game to work.
    * This includes the Canvas and the rendering contexts,
    * as well as the width/height of the game and the position it should be
    * on the screen.
    *
    * @class Stage
    * @namespace Kiwi
    * @constructor
    * @param game {Kiwi.Game} The game that this Stage belongs to.
    * @param name {String} The name of the kiwi game.
    * @param width {Number} The initial width of the game.
    * @param height {Number} The initial heihgt of the game.
    * @param scaleType {Number} The scale method that should be used for the game.
    * @return {Kiwi.Stage}
    *
    */
    var Stage = (function () {
        function Stage(game, name, width, height, scaleType) {
            /**
            * Private property that holds the scaling method that should be
            * applied to the container element.
            * @property _scaleType
            * @type number
            * @default Kiwi.Stage.SCALE_NONE
            * @private
            */
            this._scaleType = Kiwi.Stage.SCALE_NONE;
            /**
            * A point which determines the offset of this Stage
            * @property offset
            * @type Kiwi.Geom.Point
            * @public
            */
            this.offset = new Kiwi.Geom.Point();
            /**
            * The background color of the stage.
            *
            * @property _color
            * @type Kiwi.Utils.Color
            * @public
            */
            this._color = new Kiwi.Utils.Color();
            /**
            * The parent div in which the layers and input live
            * @property container
            * @type HTMLDivElement
            * @public
            */
            this.container = null;
            this._game = game;
            this.name = name;
            this.domReady = false;
            // Properties
            this._alpha = 1;
            this._x = 0;
            this._y = 0;
            this._width = width;
            this._height = height;
            this.color = "ffffff";
            // CocoonJS should be black instead
            if (this._game.deviceTargetOption === Kiwi.TARGET_COCOON) {
                this.color = "000000";
            }
            this._scale = new Kiwi.Geom.Point(1, 1);
            this._scaleType = scaleType;
            this.onResize = new Kiwi.Signal();
            this.onWindowResize = new Kiwi.Signal();
            this.onFocus = new Kiwi.Signal();
            this.onBlur = new Kiwi.Signal();
            this.onVisibilityChange = new Kiwi.Signal();
            this._renderer = null;
        }
        /**
        * Returns the type of this object.
        * @method objType
        * @return {string} "Stage"
        * @public
        */
        Stage.prototype.objType = function () {
            return "Stage";
        };
        Object.defineProperty(Stage.prototype, "scaleType", {
            get: function () {
                return this._scaleType;
            },
            /**
            * Holds type of scaling that should be applied the container element.
            * @property scaleType
            * @type number
            * @default Kiwi.Stage.SCALE_NONE
            * @public
            */
            set: function (val) {
                this._scaleType = val;
                this._scaleContainer();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage.prototype, "alpha", {
            /**
            * Sets the alpha of the container element.
            * 0 = invisible, 1 = fully visible.
            * Note: Because the alpha value is applied to the container,
            * it will not work in CocoonJS.
            *
            * @property alpha
            * @type number
            * @default 1
            * @public
            */
            get: function () {
                return this._alpha;
            },
            set: function (value) {
                if (this._game.deviceTargetOption === Kiwi.TARGET_BROWSER) {
                    this.container.style.opacity = String(Kiwi.Utils.GameMath.clamp(value, 1, 0));
                }
                // Doesn't work in cocoon
                this._alpha = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage.prototype, "x", {
            /**
            * The X coordinate of the stage. This number should be the same
            * as the stage's `left` property.
            * @property x
            * @type number
            * @public
            */
            get: function () {
                return this._x;
            },
            set: function (value) {
                if (this._game.deviceTargetOption === Kiwi.TARGET_BROWSER) {
                    this.container.style.left = String(value + "px");
                }
                else if (this._game.deviceTargetOption === Kiwi.TARGET_COCOON) {
                    this.canvas.style.left = String(value + "px");
                }
                this._x = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage.prototype, "y", {
            /**
            * Get the Y coordinate of the stage. This number should be the same
            * as the stage's `top` property.
            * @property y
            * @type number
            * @public
            */
            get: function () {
                return this._y;
            },
            set: function (value) {
                if (this._game.deviceTargetOption === Kiwi.TARGET_BROWSER) {
                    this.container.style.top = String(value + "px");
                }
                else if (this._game.deviceTargetOption === Kiwi.TARGET_COCOON) {
                    this.canvas.style.top = String(value + "px");
                }
                this._y = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage.prototype, "width", {
            /**
            * The width of the stage. This is READ ONLY.
            * See the "resize" method if you need to modify this value.
            * @property width
            * @type number
            * @public
            * @readonly
            */
            get: function () {
                return this._width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage.prototype, "height", {
            /**
            * The height of the stage. This is READ ONLY.
            * See the `resize` method if you need to modify this value.
            * @property height
            * @type number
            * @public
            * @readonly
            */
            get: function () {
                return this._height;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage.prototype, "scale", {
            get: function () {
                return this._scale;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage.prototype, "scaleX", {
            /**
            * Calculates and returns the amount that the container has been scaled
            * by on the X axis.
            * @property scaleX
            * @type Number
            * @default 1
            * @public
            */
            get: function () {
                return this._scale.x;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage.prototype, "scaleY", {
            /**
            * Calculates and returns the amount that the container has been scaled
            * by on the Y axis.
            * @property scaleY
            * @type Number
            * @default 1
            * @public
            */
            get: function () {
                return this._scale.y;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage.prototype, "color", {
            /**
            * Sets the background color of the stage.
            *
            * This can be any valid parameter for Kiwi.Utils.Color.
            * If passing multiple parameters, do so in a single array.
            *
            * The default value is "ffffff" or pure white.
            *
            * Note for users of CocoonJS: When using the WebGL renderer,
            * the stage color will fill all parts of the screen outside the canvas.
            * Kiwi.js will automatically set the color to "000000" or pure black
            * when using CocoonJS. If you change it, and your game does not fill
            * the entire screen, the empty portions of the screen will also change
            * color.
            *
            * @property color
            * @type string
            * @public
            */
            get: function () {
                return this._color.getHex();
            },
            set: function (val) {
                if (!Kiwi.Utils.Common.isArray(val)) {
                    val = [val];
                }
                this._color.set.apply(this._color, val);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage.prototype, "rgbColor", {
            /**
            * Allows the setting of the background color of the stage through
            * component RGB colour values.
            *
            * This property is an Object Literal with "r", "g", "b" colour streams
            * of values between 0 and 255.
            *
            * @property rgbColor
            * @type Object
            * @public
            */
            get: function () {
                return { r: this._color.r * 255, g: this._color.g * 255, b: this._color.b * 255 };
            },
            set: function (val) {
                this._color.r255 = val.r;
                this._color.g255 = val.g;
                this._color.b255 = val.b;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage.prototype, "rgbaColor", {
            /**
            * Allows the setting of the background color of the stage through
            * component RGBA colour values.
            *
            * This property is an Object Literal with "r", "g", "b", "a" colour
            * streams of values between 0 and 255.
            *
            * Note that the alpha value is from 0-255, not 0-1. This is to
            * preserve compatibility with hex-style color values, e.g. "ff0000ff".
            *
            * @property rgbaColor
            * @type Object
            * @public
            * @since 1.1.0
            */
            get: function () {
                return { r: this._color.r * 255, g: this._color.g * 255, b: this._color.b * 255, a: this._color.a * 255 };
            },
            set: function (val) {
                this._color.r255 = val.r;
                this._color.g255 = val.g;
                this._color.b255 = val.b;
                this._color.a255 = val.a;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage.prototype, "normalizedColor", {
            /**
            * Get the normalized background color of the stage.
            * Returns an object with rgba values, each being between 0 and 1.
            * This is READ ONLY.
            * @property normalizedColor
            * @type string
            * @public
            */
            get: function () {
                return {
                    r: this._color.r,
                    g: this._color.g,
                    b: this._color.b,
                    a: this._color.a };
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Stage.prototype, "renderer", {
            /**
            * Get the renderer associated with the canvas context.
            * This is either a GLRenderManager or a CanvasRenderer.
            * If the Kiwi.RENDERER_WEBGL renderer was requested
            * but could not be created, it will fall back to CanvasRenderer.
            * This is READ ONLY.
            * @property renderer
            * @type number
            * @public
            * @since 1.1.0
            */
            get: function () {
                return this._renderer;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * Is executed when the DOM has loaded and the game is just starting.
        * This is a internal method used by the core of Kiwi itself.
        * @method boot
        * @param dom {HTMLElement} The
        * @public
        */
        Stage.prototype.boot = function (dom) {
            var _this = this;
            var self = this;
            this.domReady = true;
            this.container = dom.container;
            if (this._game.deviceTargetOption === Kiwi.TARGET_BROWSER) {
                this.offset = this.getOffsetPoint(this.container);
                this._x = this.offset.x;
                this._y = this.offset.y;
                window.addEventListener("resize", function (event) { return _this._windowResized(event); }, true);
                this._createFocusEvents();
            }
            this._createCompositeCanvas();
            if (this._game.deviceTargetOption === Kiwi.TARGET_COCOON) {
                this._scaleContainer();
                // Detect reorientation/resize
                window.addEventListener("orientationchange", function (event) {
                    return self._orientationChanged(event);
                }, true);
            }
            else {
                this._calculateContainerScale();
            }
        };
        /**
        * Gets the x/y coordinate offset of any given valid DOM Element
        * from the top/left position of the browser
        * Based on jQuery offset https://github.com/jquery/jquery/blob/master/src/offset.js
        * @method getOffsetPoint
        * @param {Any} element
        * @param {Kiwi.Geom.Point} output
        * @return {Kiwi.Geom.Point}
        * @public
        */
        Stage.prototype.getOffsetPoint = function (element, output) {
            if (output === void 0) { output = new Kiwi.Geom.Point; }
            var box = element.getBoundingClientRect();
            var clientTop = element.clientTop || document.body.clientTop || 0;
            var clientLeft = element.clientLeft || document.body.clientLeft || 0;
            var scrollTop = window.pageYOffset || element.scrollTop || document.body.scrollTop;
            var scrollLeft = window.pageXOffset || element.scrollLeft || document.body.scrollLeft;
            return output.setTo(box.left + scrollLeft - clientLeft, box.top + scrollTop - clientTop);
        };
        /**
        * Method that is fired when the window is resized.
        * @method _windowResized
        * @param event {UIEvent}
        * @private
        */
        Stage.prototype._windowResized = function (event) {
            this._calculateContainerScale();
            // Dispatch window resize event
            this.onWindowResize.dispatch();
        };
        /**
        * Method that is fired when the device is reoriented.
        * @method _orientationChanged
        * @param event {UIEvent}
        * @private
        * @since 1.1.1
        */
        Stage.prototype._orientationChanged = function (event) {
            this.onResize.dispatch(window.innerWidth, window.innerHeight);
        };
        /**
        * Used to calculate new offset and scale for the stage.
        * @method _calculateContainerScale
        * @private
        */
        Stage.prototype._calculateContainerScale = function () {
            // Calculate the scale twice
            // This will give the correct scale upon completion the second run
            // Temporary fix until the Scale Manager is implemented
            this._scaleContainer();
            this._scaleContainer();
            this.offset = this.getOffsetPoint(this.container);
            this._scale.x = this._width / this.container.clientWidth;
            this._scale.y = this._height / this.container.clientHeight;
        };
        /**
        * Handles the creation of the canvas that the game will use and
        * retrieves the context for the renderer.
        *
        * @method _createCompositeCanvas
        * @private
        */
        Stage.prototype._createCompositeCanvas = function () {
            // If we are using cocoon then create a accelerated screen canvas
            if (this._game.deviceTargetOption == Kiwi.TARGET_COCOON) {
                this.canvas = document.createElement(navigator["isCocoonJS"] ? "screencanvas" : "canvas");
            }
            else {
                this.canvas = document.createElement("canvas");
                this.canvas.style.width = "100%";
                this.canvas.style.height = "100%";
            }
            this.canvas.id = this._game.id + "compositeCanvas";
            this.canvas.style.position = "absolute";
            this.canvas.width = this.width;
            this.canvas.height = this.height;
            // Get 2D or GL Context; do error detection
            // and fallback to valid rendering context
            if (this._game.renderOption === Kiwi.RENDERER_CANVAS) {
                this.ctx = this.canvas.getContext("2d");
                this.ctx.fillStyle = "#fff";
                this.gl = null;
            }
            else if (this._game.renderOption === Kiwi.RENDERER_WEBGL) {
                this.gl = this.canvas.getContext("webgl");
                if (!this.gl) {
                    this.gl = this.canvas.getContext("experimental-webgl");
                    if (!this.gl) {
                        Kiwi.Log.warn("Kiwi.Stage: WebGL rendering is not available despite the device apparently supporting it. Reverting to CANVAS.", "#renderer");
                        // Reset to canvas mode
                        this.ctx = this.canvas.getContext("2d");
                        this.ctx.fillStyle = "#fff";
                        this.gl = null;
                    }
                    else {
                        Kiwi.Log.warn("Kiwi.Stage: 'webgl' context is not available. Using 'experimental-webgl'", "#renderer");
                    }
                }
                if (this.gl) {
                    // That is, WebGL was properly supported and created
                    this.gl.clearColor(1, 1, 1, 1);
                    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
                    this.ctx = null;
                }
            }
            // Create render manager
            // This is reported back to the Kiwi.Game that created the Stage.
            if (this.ctx) {
                this._renderer = new Kiwi.Renderers.CanvasRenderer(this._game);
            }
            else if (this.gl) {
                this._renderer = new Kiwi.Renderers.GLRenderManager(this._game);
            }
            if (this._game.deviceTargetOption === Kiwi.TARGET_BROWSER) {
                this.container.appendChild(this.canvas);
            }
            else {
                document.body.appendChild(this.canvas);
            }
        };
        /**
        * Set the stage width and height for rendering purposes.
        * This will not effect that "scaleType" that it has been set to.
        *
        * @method resize
        * @param width {number} The new Stage width.
        * @param height {number} The new Stage height.
        * @public
        */
        Stage.prototype.resize = function (width, height) {
            this.canvas.height = height;
            this.canvas.width = width;
            this._height = height;
            this._width = width;
            if (this._game.deviceTargetOption === Kiwi.TARGET_BROWSER) {
                this._calculateContainerScale();
            }
            this.onResize.dispatch(this._width, this._height);
        };
        /**
        * Sets the background color of the stage through component
        * RGB colour values. Each parameter is a number between 0 and 255.
        * This method also returns an Object Literal with "r", "g", "b"
        * properties.
        *
        * @method setRGBColor
        * @param r {Number} The red component. A value between 0 and 255.
        * @param g {Number} The green component. A value between 0 and 255.
        * @param b {Number} The blue component. A value between 0 and 255.
        * @return {Object} A Object literal containing the r,g,b properties.
        * @public
        */
        Stage.prototype.setRGBColor = function (r, g, b) {
            this.rgbColor = { r: r, g: g, b: b };
            return this.rgbColor;
        };
        /**
        * Creates a debug canvas and adds it above the regular game canvas.
        * The debug canvas is not created by default (even with debugging on)
        * and rendering/clearing of the canvas is upto the developer.
        * The context for rendering can be access via the "dctx" property and
        * you can use the "clearDebugCanvas" method to clear the canvas.
        *
        * @method createDebugCanvas
        * @public
        */
        Stage.prototype.createDebugCanvas = function () {
            if (Kiwi.Utils.Common.isUndefined(this.debugCanvas) == false)
                return;
            if (this._game.deviceTargetOption === Kiwi.TARGET_COCOON) {
                // Not supported in CocoonJS only because we cannot add it to
                // the container (as a container does not exist) and position
                // will be hard.
                Kiwi.Log.log("Debug canvas not supported in cocoon, creating canvas and context anyway", "#debug-canvas");
            }
            this.debugCanvas = document.createElement("canvas");
            this.debugCanvas.id = this._game.id + "debugCanvas";
            this.debugCanvas.style.position = "absolute";
            this.debugCanvas.width = this.width;
            this.debugCanvas.height = this.height;
            this.debugCanvas.style.width = "100%";
            this.debugCanvas.style.height = "100%";
            this.dctx = this.debugCanvas.getContext("2d");
            this.clearDebugCanvas();
            if (this._game.deviceTargetOption === Kiwi.TARGET_BROWSER) {
                this.container.appendChild(this.debugCanvas);
            }
        };
        /**
        * Clears the debug canvas and fills with either the color passed.
        * If not colour is passed then Red at 20% opacity is used.
        *
        * @method clearDebugCanvas
        * @param [color="rgba(255,0,0,0.2)"] {string} The debug color to rendering on the debug canvas.
        * @public
        */
        Stage.prototype.clearDebugCanvas = function (color) {
            this.dctx.fillStyle = color || "rgba(255,0,0,.2)";
            this.dctx.clearRect(0, 0, this.width, this.height);
            this.dctx.fillRect(0, 0, this.width, this.height);
        };
        /**
        * Toggles the visibility of the debug canvas.
        * @method toggleDebugCanvas
        * @public
        */
        Stage.prototype.toggleDebugCanvas = function () {
            this.debugCanvas.style.display = (this.debugCanvas.style.display === "none") ? "block" : "none";
        };
        /**
        * Handles the scaling/sizing based upon the scaleType property.
        * @method _scaleContainer
        * @private
        */
        Stage.prototype._scaleContainer = function () {
            if (this._game.deviceTargetOption == Kiwi.TARGET_BROWSER) {
                var clientWidth = this.container.clientWidth;
                this.container.style.width = String(this._width + "px");
                this.container.style.height = String(this._height + "px");
                if (this._scaleType == Kiwi.Stage.SCALE_NONE) {
                    this.container.style.maxWidth = "";
                    this.container.style.minWidth = "";
                }
                // To Fit or STRETCH 
                if (this._scaleType == Kiwi.Stage.SCALE_STRETCH || this._scaleType == Kiwi.Stage.SCALE_FIT) {
                    this.container.style.minWidth = "100%";
                    this.container.style.maxWidth = "100%";
                }
                // If scale stretched then scale the containers height to 100%
                // of its parent's.
                if (this._scaleType == Kiwi.Stage.SCALE_STRETCH) {
                    this.container.style.minHeight = "100%";
                    this.container.style.maxHeight = "100%";
                }
                else {
                    this.container.style.minHeight = "";
                    this.container.style.maxHeight = "";
                }
                // If it is SCALE to FIT then scale the containers height in
                // ratio with the containers width.
                if (this._scaleType == Kiwi.Stage.SCALE_FIT) {
                    this.container.style.height = String((clientWidth / this._width) * this._height) + "px";
                }
            }
            if (this._game.deviceTargetOption == Kiwi.TARGET_COCOON) {
                // This has no effect in WebGL, and is thus handled separately.
                switch (this._scaleType) {
                    case Kiwi.Stage.SCALE_FIT:
                        this.canvas.style.cssText = "idtkscale:ScaleAspectFit";
                        break;
                    case Kiwi.Stage.SCALE_STRETCH:
                        this.canvas.style.cssText = "idtkscale:ScaleToFill";
                        break;
                    case Kiwi.Stage.SCALE_NONE:
                        this.canvas.style.cssText = "";
                        break;
                }
            }
        };
        Object.defineProperty(Stage.prototype, "visibility", {
            /**
            * A flag indicating if the page is currently visible
            * (using the Visiblity API).
            * If the Visiblity API is unsupported this will remain set to true
            * regardless of focus / blur events.
            *
            * @property visibility
            * @type boolean
            * @default true
            * @readOnly
            * @since 1.3.0
            * @public
            */
            get: function () {
                if (this._visibility) {
                    return !document[this._visibility];
                }
                return true;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * Fired when the page visibility changes, or the page focus/blur
        * events fire. In charge of firing the appropriate signals.
        *
        * @method _checkVisibility
        * @param event {Any}
        * @since 1.3.0
        * @private
        */
        Stage.prototype._checkVisibility = function (event) {
            if (event.type === "focus" || event.type === "pageshow") {
                this.onFocus.dispatch(event);
                return;
            }
            else if (event.type === "pagehide" || event.type === "blur") {
                this.onBlur.dispatch(event);
                return;
            }
            if (event.type === "visibilitychange" || event.type === "mozvisibilitychange" || event.type === "webkitvisibilitychange" || event.type === "msvisibilitychange") {
                this.onVisibilityChange.dispatch();
                return;
            }
        };
        /**
        * Adds the focus, blur, and visibility events to the document.
        *
        * @method _createFocusEvents
        * @since 1.3.0
        * @private
        */
        Stage.prototype._createFocusEvents = function () {
            this._visibility = "hidden";
            this._visibilityChange = this._checkVisibility.bind(this);
            if ("hidden" in document) {
                document.addEventListener("visibilitychange", this._visibilityChange);
            }
            else if ((this._visibility = "mozHidden") in document) {
                document.addEventListener("mozvisibilitychange", this._visibilityChange);
            }
            else if ((this._visibility = "webkitHidden") in document) {
                document.addEventListener("webkitvisibilitychange", this._visibilityChange);
            }
            else if ((this._visibility = "msHidden") in document) {
                document.addEventListener("msvisibilitychange", this._visibilityChange);
            }
            else {
                // Not supported. 
                this._visibility = null;
            }
            window.addEventListener('pageshow', this._visibilityChange);
            window.addEventListener('pagehide', this._visibilityChange);
            window.addEventListener('focus', this._visibilityChange);
            window.addEventListener('blur', this._visibilityChange);
        };
        /**
        * The default width of the stage.
        * @property DEFAULT_WIDTH
        * @type number
        * @default 800
        * @public
        * @static
        */
        Stage.DEFAULT_WIDTH = 800;
        /**
        * The default height of the stage.
        * @property DEFAULT_HEIGHT
        * @type number
        * @default 600
        * @public
        * @static
        */
        Stage.DEFAULT_HEIGHT = 600;
        /**
        * The default scaling method used on Kiwi Games.
        * This scaling method will set the container's width/height
        * to static values.
        *
        * @property SCALE_NONE
        * @type number
        * @default 0
        * @public
        * @static
        */
        Stage.SCALE_NONE = 0;
        /**
        * Scale Fit will scale the stage's width to fit its parents width.
        * The height is then calculated to maintain the aspect ratio of the
        * width/height of the Stage.
        * @property SCALE_FIT
        * @type number
        * @default 1
        * @public
        * @static
        */
        Stage.SCALE_FIT = 1;
        /**
        * Stretch will make the stage scale to fit its parents width/height
        * (by using max/min height of 100%).
        * If the parent doesn't have a height set then the height will be
        * the height of the stage.
        * @property SCALE_STRETCH
        * @type number
        * @default 2
        * @public
        * @static
        */
        Stage.SCALE_STRETCH = 2;
        return Stage;
    })();
    Kiwi.Stage = Stage;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
*
*/
var Kiwi;
(function (Kiwi) {
    /**
    * The component manager is a class that is used to handle components that
    * are active on a particular object. Any object that has a component
    * manager attached to it can use components. If you want to check to see if
    * a particular component is on an object you can ask the component manager.
    *
    * The component manager is updated once per frame (as part of its owner's
    * update), and updates all active components. This is very useful for
    * creating modular, customised behaviors on entities.
    *
    * @class ComponentManager
    * @namespace Kiwi
    * @constructor
    * @param type {number} - The type of object that this component manager's owner is.
    * @param owner {Object} - The owner of this component manager.
    * @return {ComponentManager}
    *
    */
    var ComponentManager = (function () {
        function ComponentManager(type, owner) {
            this._components = {};
            this._type = type;
            this._owner = owner;
        }
        /**
        * Returns the type of this object
        * @method objType
        * @return {string} "ComponentManager"
        * @public
        */
        ComponentManager.prototype.objType = function () {
            return "ComponentManager";
        };
        /**
        * Returns true if this contains the component given, false otherwise.
        * @method hasComponent
        * @param value {String} the name of the component
        * @return {boolean} True if this component manager contains the given component, false otherwise.
        * @public
        */
        ComponentManager.prototype.hasComponent = function (value) {
            if (this._components[value]) {
                return true;
            }
            return false;
        };
        /**
        * Returns true if this contains the component given and the component is active, false otherwise.
        * @method hasActiveComponent
        * @param value {String} The name of the component.
        * @return {boolean} true if this manager contains the component and it is active, false otherwise.
        * @public
        */
        ComponentManager.prototype.hasActiveComponent = function (value) {
            if (this._components[value] && this._components[value].active === true) {
                return true;
            }
            return false;
        };
        /**
        * Get an existing component that has been added to the layer by its name
        * @method getComponent
        * @param value {String} The component name
        * @return {Kiwi.Component} The component, if found, otherwise null
        * @public
        */
        ComponentManager.prototype.getComponent = function (value) {
            if (this._components[value]) {
                return this._components[value];
            }
            return null;
        };
        /**
        * Adds a Component to the manager.
        * @method add
        * @param component {Kiwi.Component} The component to add
        * @return {Kiwi.Component} The component that was added
        * @public
        */
        ComponentManager.prototype.add = function (component) {
            this._components[component.name] = component;
            return component;
        };
        /**
        * Adds a batch of components to the manager at a single time.
        * @method addBatch
        * @param value* {Kiwi.Component} The component/s that you would like to add.
        * @public
        */
        ComponentManager.prototype.addBatch = function () {
            var paramsArr = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                paramsArr[_i - 0] = arguments[_i];
            }
            for (var i = 0; i < paramsArr.length; i++) {
                this.add(paramsArr[i]);
            }
        };
        /**
        * Removes a component from the component manager
        * @method removeComponent
        * @param component {Kiwi.Component} The component to be removed.
        * @param [destroy=true] {boolean} If the destroy method is to be called on the component when it is removed.
        * @return {boolean} true if the component was removed successfully
        * @public
        */
        ComponentManager.prototype.removeComponent = function (component, destroy) {
            if (destroy === void 0) { destroy = true; }
            var name = component.name;
            if (this._components[name]) {
                if (destroy) {
                    this._components[name].destroy();
                }
                delete this._components[name];
                return true;
            }
            return false;
        };
        /**
        * Removes a component based on its name
        * @method removeComponentByName
        * @param name {String} The name of the component to be removed
        * @param [destroy=true] {boolean} If the destroy method is to be called on the component when it is removed.
        * @return {boolean} true if the component was removed successfully
        * @public
        */
        ComponentManager.prototype.removeComponentByName = function (name, destroy) {
            if (destroy === void 0) { destroy = true; }
            if (this._components[name]) {
                if (destroy) {
                    this._components[name].destroy();
                }
                delete this._components[name];
                return true;
            }
            return false;
        };
        /**
        * Removes all of the components from the component manager.
        * @method removeAll
        * @param [destroy=true] {boolean} If true will destroy all components
        * @public
        */
        ComponentManager.prototype.removeAll = function (destroy) {
            if (destroy === void 0) { destroy = true; }
            for (var key in this._components) {
                this.removeComponent(this._components[key], destroy);
            }
        };
        /**
        * Calls preUpdate on all active Components
        * @method preUpdate
        * @public
        */
        ComponentManager.prototype.preUpdate = function () {
            for (var name in this._components) {
                if (this._components[name].active) {
                    this._components[name].preUpdate();
                }
            }
        };
        /**
        * Calls update on all active Components
        * @method update
        * @public
        */
        ComponentManager.prototype.update = function () {
            for (var name in this._components) {
                if (this._components[name].active) {
                    this._components[name].update();
                }
            }
        };
        /**
        * Calls postUpdate on all active Components
        * @method postUpdate
        * @public
        */
        ComponentManager.prototype.postUpdate = function () {
            for (var name in this._components) {
                if (this._components[name].active) {
                    this._components[name].postUpdate();
                }
            }
        };
        /**
        * Calls preRender on all active Components
        * @method preRender
        * @public
        */
        ComponentManager.prototype.preRender = function () {
            for (var name in this._components) {
                if (this._components[name].active) {
                    this._components[name].preRender();
                }
            }
        };
        /**
        * Renders all active Components
        * @method render
        * @public
        */
        ComponentManager.prototype.render = function () {
            for (var name in this._components) {
                if (this._components[name].active) {
                    this._components[name].render();
                }
            }
        };
        /**
        * Calls postRender on all active Components
        * @method postRender
        * @public
        */
        ComponentManager.prototype.postRender = function () {
            for (var name in this._components) {
                if (this._components[name].active) {
                    this._components[name].postRender();
                }
            }
        };
        return ComponentManager;
    })();
    Kiwi.ComponentManager = ComponentManager;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
*
*/
var Kiwi;
(function (Kiwi) {
    /**
    * The plugin manager registers plugins, checks plugin dependencies, and calls designated functions on each registered plugin at boot time, and during the update loop if required.
    * Plugins are registered on the global Kiwi instance. Once a plugin in registered it is allocated a place on the Kiwi.Plugins name space.
    * Eg. FooPlugin will be accessible at Kiwi.Plugins.FooPlugin.
    * When a game instance is created, it can contain a list of required plugins in the configuration object. At this point the plugin manager will validate that the plugins
    * exist, and that dependencies are met (both Kiwi version and versions of other required plugins).
    * If the plugin has a "create" function, the plugin manager instance will call that function as part of the boot process. The create function may do anything, but usually it would create
    * an instance of an object.
    * The plugin manager update function is called every update loop. If an object was created by the "create" function and it has an "update" function, that function will be called in turn.
    * @class PluginManager
    * @namespace Kiwi
    * @constructor
    * @param game {Kiwi.Game} The state that this entity belongs to. Used to generate the Unique ID and for garbage collection.
    * @param plugins {string[]} The entities position on the x axis.
    * @return {Kiwi.PluginManager} This PluginManager.
    *
    */
    var PluginManager = (function () {
        function PluginManager(game, plugins) {
            this._game = game;
            this._plugins = plugins || new Array();
            this._bootObjects = new Array();
            this.validatePlugins();
            this._createPlugins();
        }
        Object.defineProperty(PluginManager, "availablePlugins", {
            /**
            * An array of objects represetning all available plugins, each containing the name and version number of an available plugin
            * @property getAvailablePlugins
            * @type Array
            * @static
            * @private
            */
            get: function () {
                var plugins = [];
                for (var i = 0; i < PluginManager._availablePlugins.length; i++) {
                    plugins.push({
                        name: PluginManager._availablePlugins[i].name, version: PluginManager._availablePlugins[i].version });
                }
                return plugins;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * Registers a plugin object as available. Any game instance can choose to use the plugin.
        * Plugins need only be registered once per webpage. If registered a second time it will be ignored.
        * Two plugins with the same names cannot be reigstered simultaneously, even if different versions.
        * @method register
        * @param {object} plugin
        * @public
        * @static
        */
        PluginManager.register = function (plugin) {
            Kiwi.Log.log("Kiwi.PluginManager: Attempting to register plugin : " + plugin.name, '#plugin');
            if (this._availablePlugins.indexOf(plugin) == -1) {
                //check if plugin with same name is registered
                var uniqueName = true;
                for (var i = 0; i < this._availablePlugins.length; i++) {
                    if (plugin.name === this._availablePlugins[i].name) {
                        uniqueName = false;
                    }
                }
                if (uniqueName) {
                    this._availablePlugins.push(plugin);
                    Kiwi.Log.log("  Kiwi.PluginManager: Registered plugin " + plugin.name + ": version " + plugin.version, '#plugin');
                }
                else {
                    Kiwi.Log.warn("  Kiwi.PluginManager: A plugin with the same name has already been registered. Ignoring this plugin.", '#plugin');
                }
            }
            else {
                Kiwi.Log.warn("  Kiwi.PluginManager: This plugin has already been registered. Ignoring second registration.", '#plugin');
            }
        };
        Object.defineProperty(PluginManager.prototype, "objType", {
            /**
            * Identifies the object as a PluginManager.
            * @property objType
            * @type {string} "PluginManager"
            * @public
            */
            get: function () {
                return "PluginManager";
            },
            enumerable: true,
            configurable: true
        });
        /**
        * Builds a list of valid plugins used by the game instance. Each plugin name that is supplied in the Kiwi.Game constructor configuration object
        * is checked against the Kiwi.Plugins namespace to ensure that a property of the same name exists.
        * This will ignore plugin that are registered but not used by the game instance.
        * @method validatePlugins
        * @public
        */
        PluginManager.prototype.validatePlugins = function () {
            var validPlugins = new Array();
            Kiwi.Log.log("Kiwi.PluginManager: Validating Plugins", '#plugins');
            for (var i = 0; i < this._plugins.length; i++) {
                var plugin = this._plugins[i];
                if (typeof plugin == 'string' || plugin instanceof String) {
                    if (Kiwi.Plugins.hasOwnProperty(plugin) && this.pluginIsRegistered(plugin)) {
                        validPlugins.push(plugin);
                        Kiwi.Log.log("  Kiwi.PluginManager: Plugin '" + plugin + "' appears to be valid.", '#plugin');
                        Kiwi.Log.log("  Kiwi.PluginManager: Name:" + Kiwi.Plugins[plugin].name, '#plugin');
                        Kiwi.Log.log("  Kiwi.PluginManager: Version:" + Kiwi.Plugins[plugin].version, '#plugin');
                        //test for kiwi version compatiblity
                        if (typeof Kiwi.Plugins[plugin].minimumKiwiVersion !== "undefined") {
                            Kiwi.Log.log("  Kiwi.PluginManager: " + plugin + " requires minimum Kiwi version " + Kiwi.Plugins[plugin].minimumKiwiVersion, '#plugin');
                            var parsedKiwiVersion = Kiwi.Utils.Version.parseVersion(Kiwi.VERSION);
                            var parsedPluginMinVersion = Kiwi.Utils.Version.parseVersion(Kiwi.Plugins[plugin].minimumKiwiVersion);
                            if (parsedKiwiVersion.majorVersion > parsedPluginMinVersion.majorVersion) {
                                Kiwi.Log.warn("  Kiwi.PluginManager: This major version of Kiwi is greater than that required by '" + plugin + "'. It is unknown whether this plugin will work with this version of Kiwi", '#plugin');
                            }
                            else {
                                if (Kiwi.Utils.Version.greaterOrEqual(Kiwi.VERSION, Kiwi.Plugins[plugin].minimumKiwiVersion)) {
                                    Kiwi.Log.log("  Kiwi.PluginManager: Kiwi version meets minimum version requirements for '" + plugin + "'.", '#plugin');
                                }
                                else {
                                    Kiwi.Log.warn("  Kiwi.PluginManager: Kiwi version (" + Kiwi.VERSION + ") does not meet minimum version requirements for the plugin (" + Kiwi.Plugins[plugin].minimumKiwiVersion + ").", '#plugin');
                                }
                            }
                        }
                        else {
                            Kiwi.Log.warn("  Kiwi.PluginManager: '" + plugin + "' is missing the minimumKiwiVersion property. It is unknown whether '" + plugin + "' will work with this version of Kiwi", '#plugin');
                        }
                    }
                    else {
                        Kiwi.Log.log("  Kiwi.PluginManager: Plugin '" + plugin + "' appears to be invalid. No property with that name exists on the Kiwi.Plugins object or the Plugin is not registered. Check that the js file containing the plugin has been included. This plugin will be ignored", '#plugin');
                    }
                }
                else {
                    Kiwi.Log.log("  Kiwi.PluginManager: The supplied plugin name at index " + i + "is not a string and will be ignored", '#plugin');
                }
            }
            this._plugins = validPlugins;
            for (var i = 0; i < this._plugins.length; i++) {
                //test for plugin dependencies on other plugins
                var pluginName = this._plugins[i];
                var plugin = Kiwi.Plugins[pluginName];
                if (typeof plugin.pluginDependencies !== "undefined") {
                    if (plugin.pluginDependencies.length === 0) {
                        Kiwi.Log.log("  Kiwi.PluginManager: '" + pluginName + "' does not depend on any other plugins.", '#plugin');
                    }
                    else {
                        Kiwi.Log.log("  Kiwi.PluginManager: '" + pluginName + "' depends on the following plugins:", '#plugin', '#dependencies');
                        for (var j = 0; j < plugin.pluginDependencies.length; j++) {
                            Kiwi.Log.log(plugin.pluginDependencies[j].name, plugin.pluginDependencies[j].minimumVersion, '#plugin', '#dependencies');
                            if (!this.validMinimumPluginVersionExists(plugin.pluginDependencies[j].name, plugin.pluginDependencies[j].minimumVersion)) {
                                Kiwi.Log.warn("  Kiwi.PluginManager: '" + plugin.pluginDependencies[j].name + " hasn't been added to this game via the config, doesn't exist, or does not meet minimum version requirement ( " + plugin.pluginDependencies[j].minimumVersion + ").", '#plugin', '#dependencies');
                            }
                        }
                    }
                }
                else {
                    Kiwi.Log.log("  Kiwi.PluginManager: '" + pluginName + "' does not depend on any other plugins.", '#plugin', '#dependencies');
                }
            }
        };
        /**
        * Returns whether a valid minimum version of a plugin exists.
        * @method validMinimumPluginVersionExists
        * @param name {string} Name of plugin
        * @param version {string} Minimum version
        * @return boolean
        * @public
        */
        PluginManager.prototype.validMinimumPluginVersionExists = function (name, version) {
            if (this._plugins.indexOf(name) !== -1) {
                if (Kiwi.Utils.Version.greaterOrEqual(Kiwi.Plugins[name].version, version)) {
                    return true;
                }
            }
            return false;
        };
        /**
        * Returns true if a plugin identified by the supplied pluginName is registered.
        * @method pluginIsRegistered
        * @param {string} pluginName
        * @public
        */
        PluginManager.prototype.pluginIsRegistered = function (pluginName) {
            var isRegistered = false;
            for (var i = 0; i < Kiwi.PluginManager._availablePlugins.length; i++) {
                if (Kiwi.PluginManager._availablePlugins[i].name === pluginName) {
                    isRegistered = true;
                }
            }
            return isRegistered;
        };
        /**
        * Called after all other core objects and services created by the Kiwi.Game constructor are created.
        * Attempts to find a "create" function on each plugin and calls it if it exists.
        * The create function may return an object on which a boot function exists - to be called during boot process.
        * @method _createPlugins
        * @private
        */
        PluginManager.prototype._createPlugins = function () {
            for (var i = 0; i < this._plugins.length; i++) {
                var plugin = this._plugins[i];
                if (Kiwi.Plugins[plugin].hasOwnProperty("create")) {
                    var bootObject = Kiwi.Plugins[plugin].create(this._game);
                    if (bootObject)
                        this._bootObjects.push(bootObject);
                }
            }
        };
        /**
        * Calls the boot functions on any objects that plugins used by the game instance have designated during creation.
        * @method boot
        * @public
        */
        PluginManager.prototype.boot = function () {
            for (var i = 0; i < this._bootObjects.length; i++) {
                if ("boot" in this._bootObjects[i]) {
                    this._bootObjects[i].boot.call(this._bootObjects[i]);
                }
                else {
                    Kiwi.Log.warn("Kiwi.PluginManager: Warning! No boot function found on boot object.", '#plugin');
                }
            }
        };
        /**
        * Calls the update functions on any objects that plugins used by the game instance have designated during creation.
        * @method update
        * @public
        */
        PluginManager.prototype.update = function () {
            for (var i = 0; i < this._bootObjects.length; i++) {
                if ("update" in this._bootObjects[i]) {
                    this._bootObjects[i].update.call(this._bootObjects[i]);
                }
            }
        };
        /**
        * An array of plugins which have been included in the webpage and registered successfully.
        * @property _availablePlugins
        * @type Array
        * @static
        * @private
        */
        PluginManager._availablePlugins = new Array();
        return PluginManager;
    })();
    Kiwi.PluginManager = PluginManager;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
*
*/
var Kiwi;
(function (Kiwi) {
    /**
    * Used to handle the creation and management of Cameras on a Game. Each Game will always have created for it a CameraManager and a default Camera on the manager.
    * Games currently only usupport the use of a single camera, the default camera. Much of this class has been written with future multiple camera support in mind.
    *
    * @class CameraManager
    * @namespace Kiwi
    * @constructor
    * @param {Kiwi.Game} game
    * @return {Kiwi.CameraManager}
    */
    var CameraManager = (function () {
        function CameraManager(game) {
            this._game = game;
            this._cameras = [];
            this._nextCameraID = 0;
        }
        /**
        * Returns the type of this object
        * @method objType
        * @return {String} "CameraManager"
        * @public
        */
        CameraManager.prototype.objType = function () {
            return "CameraManager";
        };
        /**
        * Initializes the CameraManager, creates a new camera and assigns it to the defaultCamera
        * @method boot
        * @public
        */
        CameraManager.prototype.boot = function () {
            this.create("defaultCamera", 0, 0, this._game.stage.width, this._game.stage.height);
            this.defaultCamera = this._cameras[0];
        };
        /**
        * Creates a new Camera and adds it to the collection of cameras.
        * @param {String} name. The name of the new camera.
        * @param {Number} x. The x position of the new camera.
        * @param {Number} y. The y position of the new camera.
        * @param {Number} width. The width of the new camera.
        * @param {Number} height. The height of the new camera.
        * @return {Kiwi.Camera} The new camera object.
        * @public
        */
        CameraManager.prototype.create = function (name, x, y, width, height) {
            var newCamera = new Kiwi.Camera(this._game, this._nextCameraID++, name, x, y, width, height);
            //newCamera.parent = state;
            this._cameras.push(newCamera);
            return newCamera;
        };
        /**
        * Removes the given camera, if it is present in the camera managers camera collection.
        * @method remove
        * @param camera {Kiwi.Camera}
        * @return {boolean} True if the camera was removed, false otherwise.
        * @public
        */
        CameraManager.prototype.remove = function (camera) {
            var i = this._cameras.indexOf(camera); //what if it was the default one! :(
            if (i !== -1) {
                //  Send Layer a killed call
                this._cameras.splice(i, 1);
                return true;
            }
            return false;
        };
        /**
        * Calls update on all the cameras.
        * @method update
        * @public
        */
        CameraManager.prototype.update = function () {
            if (this._cameras.length === 0) {
                return false;
            }
            for (var i = 0; i < this._cameras.length; i++) {
                this._cameras[i].update();
            }
        };
        /**
        * Calls the render method on all the cameras
        * @method render
        * @public
        */
        CameraManager.prototype.render = function () {
            if (this._cameras.length === 0) {
                return false;
            }
            //render each camera
            for (var i = 0; i < this._cameras.length; i++) {
                this._cameras[i].render();
            }
        };
        /**
        * Removes all cameras in the camera Manager except the default camera. Does nothing if in multi camera mode.
        * @method removeAll
        * @public
        */
        CameraManager.prototype.removeAll = function () {
            this._cameras = [];
        };
        /**
        * Returns all cameras to origin. Called when starting a new state.
        * @method zeroAllCameras
        * @public
        * @since 1.1.0
        */
        CameraManager.prototype.zeroAllCameras = function () {
            for (var i = 0; i < this._cameras.length; i++) {
                this.zeroCamera(this._cameras[i]);
            }
            this.zeroCamera(this.defaultCamera);
        };
        /**
        * Returns camera to origin.
        * @method zeroCamera
        * @param camera {Kiwi.Camera}
        * @public
        * @since 1.1.0
        */
        CameraManager.prototype.zeroCamera = function (camera) {
            camera.transform.x = 0;
            camera.transform.y = 0;
            camera.transform.rotation = 0;
            camera.transform.scaleX = 1;
            camera.transform.scaleY = 1;
            camera.transform.rotPointX = camera.width / 2;
            camera.transform.rotPointY = camera.height / 2;
        };
        return CameraManager;
    })();
    Kiwi.CameraManager = CameraManager;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
*
*/
var Kiwi;
(function (Kiwi) {
    /**
    * A lightweight object that contains values relating to the configuration of a State in a Kiwi Game.
    *
    * @class StateConfig
    * @namespace Kiwi
    * @constructor
    * @param parent {Kiwi.State} The State that this configuration object belongs to.
    * @param name {String} The name of the state which was created.
    * @return {Kiwi.StateConfig}
    *
    */
    var StateConfig = (function () {
        function StateConfig(parent, name) {
            /**
            * The name of the State, must be unique within your game.
            * @property name
            * @type String
            * @public
            */
            this.name = '';
            /**
            * Not used. Deprecated as of version 1.3.0
            *
            * @property isPersistent
            * @type Boolean
            * @default false
            * @deprecated
            * @since 1.3.0
            * @public
            */
            this.isPersistent = false;
            /**
            * If this State has been created (the create method has been executed).
            * Essentually has the same meaning as 'isReady'.
            * @property isCreated
            * @type boolean
            * @default false
            * @public
            */
            this.isCreated = false;
            /**
            * If the State has been initialised already (so the Boot and Init methods have been executed already).
            * A State only get Initialised once which is when it switched to for this first time.
            * @property isInitialised
            * @type boolean
            * @default false
            * @public
            */
            this.isInitialised = false;
            /**
            * If the State that this config is on is 'ready' to be used (e.g. all the assets have been loaded and libraries complied)
            * or if it isn't and so it is still at the 'loading' stage.
            * @property isReady
            * @type boolean
            * @default false
            * @public
            */
            this.isReady = false;
            /**
            * If the State that this config is on contains a Preloader Method.
            *
            * Deprecated as of 1.3.0 of Kiwi as it is not currently in use.
            *
            * @property hasPreloader
            * @type boolean
            * @default false
            * @deprecated
            * @since 1.3.0
            * @public
            */
            this.hasPreloader = false;
            /**
            * The number of times the State that this config belongs to has been active/used.
            * @property runCount
            * @type Number
            * @default 0
            * @public
            */
            this.runCount = 0;
            /*
            * Not in use.
            *
            * Deprecated as of version 1.3.0 since there is only a single type of State currently.
            *
            * @property type
            * @type Number
            * @default 0
            * @deprecated
            * @since 1.3.0
            * @public
            */
            this.type = 0;
            this._state = parent;
            this.name = name;
            //If it has a preload method.
            //*cough* of course it does.
            if (typeof this._state['preload'] === 'function') {
                this.hasPreloader = true;
            }
        }
        /**
        * The type of object that this is.
        * @method objType
        * @return {String} "StateConfig"
        * @public
        */
        StateConfig.prototype.objType = function () {
            return "StateConfig";
        };
        /**
        * Resets the properties contained on this StateConfig object.
        * This is executed when a State is about to be destroyed as so reset's it to be switched to again.
        * @method reset
        * @public
        */
        StateConfig.prototype.reset = function () {
            this.isReady = false;
            this.isCreated = false;
            this.createParams = [];
            this.initParams = [];
        };
        return StateConfig;
    })();
    Kiwi.StateConfig = StateConfig;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
*
*/
var Kiwi;
(function (Kiwi) {
    /**
    * The State Manager handles the starting, parsing, looping and swapping of game States within a Kiwi Game
    * There is only ever one State Manager per game, but a single Game can contain multiple States.
    *
    * @class StateManager
    * @namespace Kiwi
    * @constructor
    * @param game {Kiwi.Game} The game that this statemanager belongs to.
    * @return {Kiwi.StateMananger}
    *
    */
    var StateManager = (function () {
        function StateManager(game) {
            /**
            * The current State that the game is at.
            * @property current
            * @type Kiwi.State
            * @default null
            * @public
            */
            this.current = null;
            /**
            * The name of the new State that is to be switched to.
            * @property _newStateKey
            * @type string
            * @default null
            * @private
            */
            this._newStateKey = null;
            this._game = game;
            this._states = [];
        }
        /**
        * The type of object this is.
        * @method objType
        * @return {string} "StateManager"
        * @public
        */
        StateManager.prototype.objType = function () {
            return "StateManager";
        };
        /**
        * Checks to see if a key exists. Internal use only.
        * @method checkKeyExists
        * @param key {String}
        * @return {boolean}
        * @private
        */
        StateManager.prototype.checkKeyExists = function (key) {
            for (var i = 0; i < this._states.length; i++) {
                if (this._states[i].config.name === key) {
                    return true;
                }
            }
            return false;
        };
        /**
        * Checks to see if the State passed is valid or not.
        * @method checkValidState
        * @param state {Kiwi.State}
        * @return {boolean}
        * @private
        */
        StateManager.prototype.checkValidState = function (state) {
            if (!state['game'] || !state['config']) {
                return false;
            }
            return true;
        };
        /**
        * Adds the given State to the StateManager.
        * The State must have a unique key set on it, or it will fail to be added to the manager.
        * Returns true if added successfully, otherwise false (can happen if State is already in the StateManager)
        *
        * @method addState
        * @param state {Any} The Kiwi.State instance to add.
        * @param [switchTo=false] {boolean} If set to true automatically switch to the given state after adding it
        * @return {boolean} true if the State was added successfully, otherwise false
        * @public
        */
        StateManager.prototype.addState = function (state, switchTo) {
            if (switchTo === void 0) { switchTo = false; }
            Kiwi.Log.log('Kiwi.StateManager: Adding state.', '#state');
            var tempState;
            //What type is the state that was passed.
            if (typeof state === 'function') {
                tempState = new state();
            }
            else if (typeof state === 'string') {
                tempState = window[state];
            }
            else {
                tempState = state;
            }
            //Does a state with that name already exist?
            if (tempState.config.name && this.checkKeyExists(tempState.config.name) === true) {
                Kiwi.Log.error('  Kiwi.StateManager: Could not add ' + tempState.config.name + ' as a State with that name already exists.', '#state');
                return false;
            }
            tempState.game = this._game;
            //Is it a valid state?
            if (this.checkValidState(tempState) === false) {
                Kiwi.Log.error('  Kiwi.StateManager: ' + tempState.config.name + ' isn\'t a valid state. Make sure you are using the Kiwi.State class!', '#state');
                return false;
            }
            else {
                this._states.push(tempState);
                Kiwi.Log.log('  Kiwi.StateManager: ' + tempState.config.name + ' was successfully added.', '#state');
                if (switchTo === true) {
                    this.switchState(tempState.config.name);
                }
                return true;
            }
        };
        /**
        * Is executed once the DOM has finished loading.
        * This is an INTERNAL Kiwi method.
        * @method boot
        * @public
        */
        StateManager.prototype.boot = function () {
        };
        /**
        * Switches to the name (key) of the state that you pass.
        * Does not work if the state you are switching to is already the current state OR if that state does not exist yet.
        * @method setCurrentState
        * @param key {String}
        * @return {boolean}
        * @private
        */
        StateManager.prototype.setCurrentState = function (key) {
            //  Bail out if they are trying to switch to the already current state
            if (this.current !== null && this.current.config.name === key || this.checkKeyExists(key) === false) {
                return false;
            }
            Kiwi.Log.log('Kiwi.StateManager: Switching to "' + key + '" State.', '#state');
            this._newStateKey = key;
            return true;
        };
        /**
        * Actually switches to a state that is stored in the 'newStateKey' property. This method is executed after the update loops have been executed to help prevent developer errors.
        * @method bootNewState
        * @private
        */
        StateManager.prototype.bootNewState = function () {
            // Destroy the current if there is one.
            if (this.current !== null) {
                this.current.shutDown();
                this._game.input.reset(); //Reset the input component
                this.current.destroy(true); //Destroy ALL IChildren ever created on that state.
                this._game.fileStore.removeStateFiles(this.current); //Clear the fileStore of not global files.
                this.current.config.reset(); //Reset the config setting
                this._game.cameras.zeroAllCameras(); // Reset cameras
            }
            //Set the current state, reset the key
            this.current = this.getState(this._newStateKey);
            this._newStateKey = null;
            //Initalise the state and execute the preload method?
            this.checkInit();
            this.checkPreload();
        };
        /**
        * Swaps the current state.
        * If the state has already been loaded (via addState) then you can just pass the key.
        * Otherwise you can pass the state object as well and it will load it then swap to it.
        *
        * @method switchState
        * @param key {String} The name/key of the state you would like to switch to.
        * @param [state=null] {Any} The state that you want to switch to. This is only used to create the state if it doesn't exist already.
        * @param [initParams=null] {Object} Any parameters that you would like to pass to the init method of that new state.
        * @param [createParams=null] {Object} Any parameters that you would like to pass to the create method of that new state.
        * @param [preloadParams=null] {Object} Any parameters that you would like to pass to the preload method. Since 1.3.0 of Kiwi.JS
        * @return {boolean} Whether the State is going to be switched to or not.
        * @public
        */
        StateManager.prototype.switchState = function (key, state, initParams, createParams, preloadParams) {
            if (state === void 0) { state = null; }
            if (initParams === void 0) { initParams = null; }
            if (createParams === void 0) { createParams = null; }
            if (preloadParams === void 0) { preloadParams = null; }
            //  If we have a current state that isn't yet ready (preload hasn't finished) then abort now
            if (this.current !== null && this.current.config.isReady === false) {
                Kiwi.Log.error('Kiwi.StateManager: Cannot change to a new state till the current state has finished loading!', '#state');
                return false;
            }
            // If state key doesn't exist then lets add it.
            if (this.checkKeyExists(key) === false && state !== null) {
                if (this.addState(state, false) === false) {
                    return false;
                }
            }
            // Store the parameters (if any)
            if (initParams !== null || createParams !== null || preloadParams !== null) {
                var newState = this.getState(key);
                newState.config.initParams = [];
                newState.config.createParams = [];
                newState.config.preloadParams = [];
                for (var initParameter in initParams) {
                    newState.config.initParams.push(initParams[initParameter]);
                }
                for (var createParameter in createParams) {
                    newState.config.createParams.push(createParams[createParameter]);
                }
                for (var preloadParameter in preloadParams) {
                    newState.config.preloadParams.push(preloadParams[preloadParameter]);
                }
            }
            return this.setCurrentState(key);
        };
        /**
        * Gets a state by the key that is passed.
        * @method getState
        * @param key {String}
        * @return {Kiwi.State}
        * @private
        */
        StateManager.prototype.getState = function (key) {
            for (var i = 0; i < this._states.length; i++) {
                if (this._states[i].config.name === key) {
                    return this._states[i];
                }
            }
            return null;
        };
        /*
        *----------------
        * Check Methods
        *----------------
        */
        /**
        * Checks to see if the state that is being switched to needs to load some files or not.
        * If it does it loads the file, if it does not it runs the create method.
        * @method checkPreload
        * @private
        */
        StateManager.prototype.checkPreload = function () {
            //Rebuild the Libraries before the preload is executed
            this.rebuildLibraries();
            this._game.loader.onQueueProgress.add(this.onLoadProgress, this);
            this._game.loader.onQueueComplete.add(this.onLoadComplete, this);
            this.current.preload.apply(this.current, this.current.config.preloadParams);
            this._game.loader.start();
        };
        /**
        * Checks to see if the state being switched to contains a create method.
        * If it does then it calls the create method.
        * @method callCreate
        * @private
        */
        StateManager.prototype.callCreate = function () {
            Kiwi.Log.log("Kiwi.StateManager: Calling " + this.current.name + ":Create", '#state');
            this.current.create.apply(this.current, this.current.config.createParams);
            this.current.config.runCount++;
            this.current.config.isCreated = true;
        };
        /**
        * Checks to see if the state has a init method and then executes that method if it is found.
        * @method checkInit
        * @private
        */
        StateManager.prototype.checkInit = function () {
            //Has the state already been initialised?
            if (this.current.config.isInitialised === false) {
                //Boot the state.
                this.current.boot();
                //Execute the Init method with params
                this.current.init.apply(this.current, this.current.config.initParams);
                this.current.config.isInitialised = true;
            }
        };
        /**
        * Is execute whilst files are being loaded by the state.
        * @method onLoadProgress
        * @param percent {Number} The current percentage of files that have been loaded. Ranging from 0 - 1.
        * @param bytesLoaded {Number} The number of bytes that have been loaded so far.
        * @param file {Kiwi.Files.File} The last file that has been loaded.
        * @private
        */
        StateManager.prototype.onLoadProgress = function (percent, bytesLoaded, file) {
            this.current.loadProgress(percent, bytesLoaded, file);
        };
        /**
        * Executed when the preloading has completed. Then executes the loadComplete and create methods of the new State.
        * @method onLoadComplete
        * @private
        */
        StateManager.prototype.onLoadComplete = function () {
            this.current.loadComplete();
            this._game.loader.onQueueProgress.remove(this.onLoadProgress, this);
            this._game.loader.onQueueComplete.remove(this.onLoadComplete, this);
            //Rebuild the Libraries again to have access the new files that were loaded.
            this.rebuildLibraries();
            this.current.config.isReady = true;
            this.callCreate();
        };
        /**
        * Rebuilds the texture, audio and data libraries that are on the current state. Thus updating what files the user has access to.
        * @method rebuildLibraries
        * @public
        */
        StateManager.prototype.rebuildLibraries = function () {
            this.current.audioLibrary.rebuild(this._game.fileStore, this.current);
            this.current.dataLibrary.rebuild(this._game.fileStore, this.current);
            this.current.textureLibrary.rebuild(this._game.fileStore, this.current);
            if (this._game.renderOption == Kiwi.RENDERER_WEBGL) {
                this._game.renderer.initState(this.current);
            }
        };
        /**
        * The update loop that is accessible on the StateManager.
        * @method update
        * @public
        */
        StateManager.prototype.update = function () {
            if (this.current !== null) {
                //Is the state ready?
                if (this.current.config.isReady === true) {
                    this.current.preUpdate();
                    this.current.update();
                    this.current.postUpdate();
                }
                else {
                    this.current.loadUpdate();
                }
            }
            //Do we need to switch states?
            if (this._newStateKey !== null) {
                this.bootNewState();
            }
        };
        /**
        * PostRender - Called after all of the rendering has been executed in a frame.
        * @method postRender
        * @public
        */
        StateManager.prototype.postRender = function () {
            if (this.current !== null) {
                if (this.current.config.isReady === true) {
                    this.current.postRender();
                }
            }
        };
        return StateManager;
    })();
    Kiwi.StateManager = StateManager;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
*
*/
/**
*
* @module Kiwi
*
*/
var Kiwi;
(function (Kiwi) {
    /**
    * An Entity is a base class for game objects to extend from and thus you should never directly instantiate this class.
    * Every entity requires that you pass to it the state to which it belongs, so that when you switch states the appropriate entities can be deleted.
    *
    * @class Entity
    * @namespace Kiwi
    * @constructor
    * @param state {State} The state that this entity belongs to. Used to generate the Unique ID and for garbage collection.
    * @param x {Number} The entities position on the x axis.
    * @param y {Number} The entities position on the y axis.
    * @return {Kiwi.Entity} This entity.
    *
    */
    var Entity = (function () {
        function Entity(state, x, y) {
            /**
            * The group that this entity belongs to. If added onto the state then this is the state.
            * @property _parent
            * @type Kiwi.Group
            * @private
            */
            this._parent = null;
            /**
            * The alpha of this entity.
            * @property _alpha
            * @type Number
            * @private
            */
            this._alpha = 1;
            /**
            * The width of the entity in pixels, pre-transform.
            *
            * To obtain the actual width, multiply width by scaleX.
            * @property width
            * @type number
            * @default 0
            * @public
            */
            this.width = 0; //If bounds are implemented then getters and setters here would be nice.
            /**
            * The height of the entity in pixels, pre-transform.
            *
            * To obtain the actual height, multiply height by scaleY.
            * @property height
            * @type number
            * @default 0
            * @public
            */
            this.height = 0;
            /**
            * The texture atlas that is to be used on this entity.
            * @property atlas
            * @type Kiwi.Textures.TextureAtlas
            * @public
            */
            this.atlas = null;
            /**
            * Holds the current cell that is being used by the entity.
            * @property _cellIndex
            * @type number
            * @default 0
            * @private
            */
            this._cellIndex = 0;
            /**
            * A name for this Entity. This is not checked for uniqueness within the Game, but is very useful for debugging
            * @property name
            * @type string
            * @default ''
            * @public
            */
            this.name = '';
            /**
            * Any tags that are on this Entity. This can be used to grab GameObjects or Groups on the whole game which have these particular tags.
            * By default Entitys contain no tags.
            * @property _tags
            * @type Array
            * @since 1.1.0
            * @private
            */
            this._tags = [];
            /**
            * The clock that this entity use's for time based calculations. This generated by the state on instatiation.
            * @property _clock
            * @type Kiwi.Clock
            * @private
            */
            this._clock = null;
            //  Properties
            this.state = state;
            this.game = state.game;
            this.id = this.game.rnd.uuid();
            this.state.addToTrackingList(this);
            this._clock = this.game.time.clock;
            this._exists = true;
            this._active = true;
            this._visible = true;
            this.components = new Kiwi.ComponentManager(Kiwi.ENTITY, this);
            this.transform = new Kiwi.Geom.Transform();
            this.transform.x = x;
            this.transform.y = y;
        }
        Object.defineProperty(Entity.prototype, "parent", {
            get: function () {
                return this._parent;
            },
            /**
            * The group that this entity belongs to/is a child of once added to one. If added onto the state then this is the state.
            * @property parent
            * @type Group
            * @param val {Kiwi.Group}
            * @public
            */
            set: function (val) {
                this.transform.parent = (val !== null) ? val.transform : null;
                this._parent = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "x", {
            /**
            * X coordinate of this Entity. This is just aliased to the transform property.
            * @property x
            * @type Number
            * @public
            */
            get: function () {
                return this.transform.x;
            },
            set: function (value) {
                this.transform.x = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "y", {
            /**
            * Y coordinate of this Entity. This is just aliased to the transform property.
            * @property y
            * @type Number
            * @public
            */
            get: function () {
                return this.transform.y;
            },
            set: function (value) {
                this.transform.y = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "worldX", {
            /**
            * X coordinate of this Entity in world space; that is, after inheriting parent transforms. This is just aliased to the transform property. Property is READ-ONLY.
            * @property worldX
            * @type number
            * @public
            * @since 1.1.0
            */
            get: function () {
                return (this.transform.worldX);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "worldY", {
            /**
            * Y coordinate of this Entity in world space; that is, after inheriting parent transforms. This is just aliased to the transform property. Property is READ-ONLY.
            * @property worldY
            * @type number
            * @public
            * @since 1.1.0
            */
            get: function () {
                return (this.transform.worldY);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "scaleX", {
            /**
            * Scale X of this Entity. This is just aliased to the transform property.
            * @property scaleX
            * @type Number
            * @public
            */
            get: function () {
                return this.transform.scaleX;
            },
            set: function (value) {
                this.transform.scaleX = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "scaleY", {
            /**
            * Scale Y coordinate of this Entity. This is just aliased to the transform property.
            * @property scaleY
            * @type Number
            * @public
            */
            get: function () {
                return this.transform.scaleY;
            },
            set: function (value) {
                this.transform.scaleY = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "scale", {
            /**
            * Scale both axes of this Entity. This is just aliased to the transform property. This is WRITE-ONLY.
            * @property scale
            * @type number
            * @public
            * @since 1.1.0
            */
            set: function (value) {
                this.transform.scale = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "rotation", {
            /**
            * Rotation of this Entity. This is just aliased to the transform property.
            * @property rotation
            * @type Number
            * @public
            */
            get: function () {
                return this.transform.rotation;
            },
            set: function (value) {
                this.transform.rotation = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "rotPointX", {
            /**
            * The rotation point on the x-axis. This is just aliased to the rotPointX on the transform object.
            * @property rotPointX
            * @type number
            * @public
            */
            get: function () {
                return this.transform.rotPointX;
            },
            set: function (value) {
                this.transform.rotPointX = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "rotPointY", {
            /**
            * The rotation point on the y-axis. This is just aliased to the rotPointY on the transform object.
            * @property rotPointY
            * @type number
            * @public
            */
            get: function () {
                return this.transform.rotPointY;
            },
            set: function (value) {
                this.transform.rotPointY = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "anchorPointX", {
            /**
            * The anchor point on the x-axis. This is just aliased to the rotPointX on the transform object.
            * @property anchorPointX
            * @type number
            * @public
            * @since 1.1.0
            */
            get: function () {
                return this.transform.anchorPointX;
            },
            set: function (value) {
                this.transform.anchorPointX = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "anchorPointY", {
            /**
            * The anchor point on the y-axis. This is just aliased to the rotPointY on the transform object.
            * @property anchorPointY
            * @type number
            * @public
            * @since 1.1.0
            */
            get: function () {
                return this.transform.anchorPointY;
            },
            set: function (value) {
                this.transform.anchorPointY = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * Returns the type of child that this is.
        * @type Number
        * @return {Number} returns the type of child that the entity is
        * @public
        */
        Entity.prototype.childType = function () {
            return Kiwi.ENTITY;
        };
        Object.defineProperty(Entity.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            /**
            * Alpha of this entity. A number between 0 (invisible) and 1 (completely visible).
            * @property alpha
            * @type Number
            * @public
            */
            set: function (value) {
                if (value <= 0)
                    value = 0;
                if (value > 1)
                    value = 1;
                this._alpha = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "visible", {
            get: function () {
                return this._visible;
            },
            /**
            * Set the visibility of this entity. True or False.
            * @property visible
            * @type boolean
            * @default true
            * @public
            */
            set: function (value) {
                this._visible = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * Scale to desired width, preserving aspect ratio. This function changes the scale, not the width. If the width changes, for example, as part of an animation sequence, the Entity will retain the new scale.
        * @method scaleToWidth
        * @param value {Number} The desired width in pixels.
        * @public
        * @since 1.1.0
        */
        Entity.prototype.scaleToWidth = function (value) {
            this.scale = value / this.width;
        };
        /**
        * Scale to desired height, preserving aspect ratio. This function changes the scale, not the height. If the height changes, for example, as part of an animation sequence, the Entity will retain the new scale.
        * @method scaleToHeight
        * @param value {Number} The desired height in pixels.
        * @public
        * @since 1.1.0
        */
        Entity.prototype.scaleToHeight = function (value) {
            this.scale = value / this.height;
        };
        /**
        * Center the anchor point. Moves the anchor point (rotPointX and Y) to precisely halfway along the width and height properties of this Entity.
        * @method centerAnchorPoint
        * @public
        * @since 1.1.0
        */
        Entity.prototype.centerAnchorPoint = function () {
            this.anchorPointX = this.width * 0.5;
            this.anchorPointY = this.height * 0.5;
        };
        Object.defineProperty(Entity.prototype, "cellIndex", {
            /**
            * Used as a reference to a single Cell in the atlas that is to be rendered.
            *
            * E.g. If you had a spritesheet with 3 frames/cells and you wanted the second frame to be displayed you would change this value to 1
            * @property cellIndex
            * @type number
            * @default 0
            * @public
            */
            get: function () {
                return this._cellIndex;
            },
            set: function (val) {
                //If the entity has a texture atlas
                if (this.atlas !== null) {
                    var cell = this.atlas.cells[val];
                    if (cell !== undefined) {
                        //Update the width/height of the GameObject to be the same as the width/height
                        this._cellIndex = val;
                        this.width = cell.w;
                        this.height = cell.h;
                    }
                    else {
                        Kiwi.Log.error('Could not the set the cellIndex of a Entity, to cell that does not exist on its TextureAtlas.', '#entity', "#cellIndex");
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "exists", {
            get: function () {
                return this._exists;
            },
            /**
            * Toggles the existence of this Entity. An Entity that no longer exists can be garbage collected or re-allocated in a pool.
            * @property exists
            * @type boolean
            * @public
            */
            set: function (value) {
                this._exists = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * Adds a new Tag to this Entity. Useful for identifying large amounts of the same type of GameObjects.
        * You can pass multiple strings to add multiple tags.
        * @method addTag
        * @param tag {string} The tag that you would like to add to this Entity.
        * @since 1.1.0
        * @public
        */
        Entity.prototype.addTag = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            //Loop through the arguments
            for (var i = 0; i < args.length; i++) {
                if (this._tags.indexOf(args[i]) == -1) {
                    this._tags.push(args[i]);
                }
            }
        };
        /**
        * Removes a Tag from this Entity.
        * @method removeTag
        * @param tag {string} The tag that you would like to remove from this Entity.
        * @since 1.1.0
        * @public
        */
        Entity.prototype.removeTag = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            for (var i = 0; i < args.length; i++) {
                var index = this._tags.indexOf(args[i]);
                if (index !== -1)
                    this._tags.splice(index, 1);
            }
        };
        /**
        * Checks to see if this Entity has a Tag based upon a string which you pass.
        * @method hasTag
        * @param tag {string}
        * @since 1.1.0
        * @return {boolean}
        * @public
        */
        Entity.prototype.hasTag = function (tag) {
            var len = this._tags.length;
            while (len--) {
                if (this._tags[len] === tag) {
                    return true;
                }
            }
            return false;
        };
        Object.defineProperty(Entity.prototype, "active", {
            get: function () {
                return this._active;
            },
            /**
            * Toggles the active state of this Entity. An Entity that is active has its update method called by its parent.
            * This method should be over-ridden to handle specific dom/canvas/webgl implementations.
            * @property active
            * @type boolean
            * @public
            */
            set: function (value) {
                this._active = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "willRender", {
            get: function () {
                return this._willRender;
            },
            /**
            * Toggles if this Entity will be rendered.
            * @property willRender
            * @type boolean
            * @default true
            * @public
            * @deprecated Use visible instead
            */
            set: function (value) {
                this._willRender = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "inputEnabled", {
            get: function () {
                return this._inputEnabled;
            },
            /**
            * Controls if this Entity is input enabled or not (i.e. responds to touch/mouse events)
            * This method should be over-ridden to handle specific game object implementations.
            * @property inputEnabled
            * @type boolean
            * @public
            * @deprecated As of 1.2.3, nothing was found to use this.
            */
            set: function (value) {
                this._inputEnabled = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "clock", {
            get: function () {
                return this._clock;
            },
            /**
            * The Clock used to update this all of this Entities components (defaults to the Game MasterClock)
            * @property clock
            * @type Kiwi.Time.Clock
            * @public
            */
            set: function (value) {
                this._clock = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entity.prototype, "dirty", {
            get: function () {
                return this._dirty;
            },
            /**
            * A value used by components to control if the Entity needs re-rendering
            * @property dirty
            * @type boolean
            * @public
            */
            set: function (value) {
                this._dirty = value;
            },
            enumerable: true,
            configurable: true
        });
        //  Both of these methods can and often should be over-ridden by classes extending Entity to handle specific implementations
        /**
        * The type of this object.
        * @method objType
        * @return {String} "Entity"
        * @public
        */
        Entity.prototype.objType = function () {
            return "Entity";
        };
        /**
        * This isn't called until the Entity has been added to a Group or a State.
        * Note: If added to a Group, who is not 'active' (so the Groups update loop doesn't run) then each member will not execute either.
        * @method update
        * @public
        */
        Entity.prototype.update = function () {
            this.components.preUpdate();
            this.components.update();
            this.components.postUpdate();
        };
        /**
        * Renders the entity using the canvas renderer.
        * This isn't called until the Entity has been added to a Group/State which is active.
        * This functionality is handled by the sub classes.
        * @method render
        * @param {Camera} camera
        * @public
        */
        Entity.prototype.render = function (camera) {
        };
        /**
        * Renders the entity using the canvas renderer.
        * This isn't called until the Entity has been added to a Group/State which is active.
        * This functionality is handled by the sub classes.
        * @method renderGL
        * @param {Kiwi.Camera} camera
        * @param {WebGLRenderingContext} gl
        * @param [params=null] {object} params
        * @public
        */
        Entity.prototype.renderGL = function (gl, camera, params) {
            if (params === void 0) { params = null; }
        };
        /**
        * Used to completely destroy this entity and of its components.
        * Used for garbage collection and developers can also use it as needed.
        * It is more reliable to use "exists = false", as this will ensure
        * that "destroy" is called at a convenient time.
        * @method destroy
        * @param [immediate=false] {boolean} If the object should be immediately removed or if it should be removed at the end of the next update loop.
        * @public
        */
        Entity.prototype.destroy = function (immediate) {
            if (immediate === void 0) { immediate = false; }
            this._exists = false;
            this._active = false;
            this._visible = false;
            if (immediate === true) {
                if (this.parent !== null && typeof this.parent !== "undefined")
                    this.parent.removeChild(this);
                if (this.state)
                    this.state.removeFromTrackingList(this);
                delete this._parent;
                delete this.transform;
                delete this._clock;
                delete this.state;
                delete this.game;
                delete this.atlas;
                if (this.components)
                    this.components.removeAll(true);
                delete this.components;
            }
        };
        return Entity;
    })();
    Kiwi.Entity = Entity;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
*
*/
var Kiwi;
(function (Kiwi) {
    /**
    * The base class that all components extend from. It contains all of the common functionality that is required of every Component.
    * Any object
    *
    * @class Component
    * @namespace Kiwi
    * @constructor
    * @param owner {Object} The object that this component belongs to.
    * @param componentName {String} The name of this component.
    * @return {Kiwi.Component}
    */
    var Component = (function () {
        function Component(owner, name) {
            /**
            * An active Component is one that has its update method called by its parent.
            * @property active
            * @type boolean
            * @default true
            * @public
            */
            this.active = true;
            /**
            * The state of this component.
            * @property dirty
            * @type boolean
            * @default false
            * @deprecated
            * @public
            */
            this.dirty = false;
            this.owner = owner;
            this.game = this.owner.game;
            this.name = name;
            if (this.owner.state) {
                this.state = this.owner.state;
            }
            else if (this.owner.objType() === 'State') {
                this.state = this.owner;
            }
            this.active = true;
        }
        /**
        * Returns the type of this object
        * @method objType
        * @return {String} "Component"
        * @public
        */
        Component.prototype.objType = function () {
            return "Component";
        };
        /**
        * Components can preUpdate, that is update before the parent updates. This is to be overriden by subclasses.
        * @method preUpdate
        * @public
        */
        Component.prototype.preUpdate = function () { };
        /**
        * If the component is being added to a State rather than a Game Object then over-ride its update method to perform required tasks.
        * @method update
        * @public
        */
        Component.prototype.update = function () { };
        /**
        * Components can postUpdate, that is run an update after the parent has updated. This is to be overriden by subclasses.
        * @method postUpdate
        * @public
        */
        Component.prototype.postUpdate = function () { };
        /**
        * Destroys this component and all of the properties that exist on it.
        * @method destroy
        * @public
        */
        Component.prototype.destroy = function () {
            this.active = false;
            delete this.game;
            delete this.owner;
            this.name = '';
        };
        return Component;
    })();
    Kiwi.Component = Component;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
*
*/
var Kiwi;
(function (Kiwi) {
    /**
    * The group class is central to creating the scene graph that contains all objects in a state. A group can contain entities or other groups, thereby enabling a nested tree scene graph.
    * The members of the Group's coordinates are also in relation to the Group that they were added to. So if you moved an entire Group, each member of that Group would also 'move'.
    *
    * @class Group
    * @namespace Kiwi
    * @constructor
    * @param state {Kiwi.State} The State that this Group is a part of.
    * @param [name=''] {String} The name of this group.
    * @return {Kiwi.Group}
    *
    */
    var Group = (function () {
        function Group(state, name) {
            if (name === void 0) { name = ''; }
            /**
            * A name for this Group. This is not checked for uniqueness within the Game, but is very useful for debugging.
            * @property name
            * @type string
            * @default ''
            * @public
            */
            this.name = '';
            /**
            * The parent group of this group.
            * @property _parent
            * @type Kiwi.Group
            * @private
            */
            this._parent = null;
            /**
            * The game this Group belongs to
            * @property game
            * @type Kiwi.Game
            * @public
            */
            this.game = null;
            /**
            * The State that this Group belongs to
            * @property state
            * @type Kiwi.State
            * @public
            **/
            this.state = null;
            /**
            * An indication of whether or not this group is 'dirty' and thus needs to be re-rendered or not.
            * @property _dirty
            * @type boolean
            * @private
            */
            this._dirty = true;
            /**
            * ---------------
            * Tagging System
            * ---------------
            **/
            /**
            * Any tags that are on this Entity. This can be used to grab GameObjects or Groups on the whole game which have these particular tags.
            * By default Entitys contain no tags.
            * @property _tags
            * @type Array
            * @since 1.1.0
            * @private
            */
            this._tags = [];
            /**
            * A temporary property that holds a boolean indicating whether or not the group's children should be destroyed or not.
            * @property _destroyRemoveChildren
            * @type boolean
            * @private
            */
            this._tempRemoveChildren = null;
            //prevents the state going AHHH...since the state extends group.
            if (state !== null) {
                this.state = state;
                this.game = this.state.game;
                this.id = this.game.rnd.uuid();
                this.state.addToTrackingList(this);
            }
            //  Properties
            this.name = name;
            this.components = new Kiwi.ComponentManager(Kiwi.GROUP, this);
            this._exists = true;
            this._active = true;
            this._visible = true;
            this.transform = new Kiwi.Geom.Transform();
            this.members = [];
        }
        /**
        * Returns the type of this object
        * @method objType
        * @return {String} "Group"
        * @public
        */
        Group.prototype.objType = function () {
            return "Group";
        };
        /*
        * Represents the type of child that this is.
        * @method childType
        * @return number
        * @public
        */
        Group.prototype.childType = function () {
            return Kiwi.GROUP;
        };
        Object.defineProperty(Group.prototype, "parent", {
            get: function () {
                return this._parent;
            },
            /**
            * Set's the parent of this entity. Note that this also sets the transforms parent of this entity to be the passed groups transform.
            * @property parent
            * @type Kiwi.Group
            * @public
            */
            set: function (val) {
                //check to see if the parent is not an descendor
                //if (this.containsDescendant(val) === false) {
                this.transform.parent = (val !== null) ? val.transform : null;
                this._parent = val;
                //}
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "x", {
            /**
            * The X coordinate of this group. This is just aliased to the transform property.
            * @property x
            * @type Number
            * @public
            */
            get: function () {
                return this.transform.x;
            },
            set: function (value) {
                this.transform.x = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "y", {
            /**
            * The Y coordinate of this group. This is just aliased to the transform property.
            * @property y
            * @type Number
            * @public
            */
            get: function () {
                return this.transform.y;
            },
            set: function (value) {
                this.transform.y = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "worldX", {
            /**
            * The X coordinate of this group in world space; that is, after parent transforms. This is just aliased to the transform property. This is READ-ONLY.
            * @property worldX
            * @type number
            * @public
            * @since 1.1.0
            */
            get: function () {
                return this.transform.worldX;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "worldY", {
            /**
            * The Y coordinate of this group in world space; that is, after parent transforms. This is just aliased to the transform property. This is READ-ONLY.
            * @property worldY
            * @type number
            * @public
            * @since 1.1.0
            */
            get: function () {
                return this.transform.worldY;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "scaleX", {
            /*
            * The Scale X of this group. This is just aliased to the transform property.
            * @property scaleX
            * @type Number
            * @public
            */
            get: function () {
                return this.transform.scaleX;
            },
            set: function (value) {
                this.transform.scaleX = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "scaleY", {
            /*
            * The Scale Y coordinate of this group. This is just aliased to the transform property.
            * @property scaleY
            * @type Number
            * @public
            */
            get: function () {
                return this.transform.scaleY;
            },
            set: function (value) {
                this.transform.scaleY = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "scale", {
            /**
            * The scale of this group. This is just aliased to the transform property. This is WRITE-ONLY.
            * @property scale
            * @type number
            * @public
            * @since 1.1.0
            */
            set: function (value) {
                this.transform.scale = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "rotation", {
            /*
            * The rotation of this group. This is just aliased to the transform property.
            * @property rotation
            * @type Number
            * @public
            */
            get: function () {
                return this.transform.rotation;
            },
            set: function (value) {
                this.transform.rotation = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "rotPointX", {
            /**
            * The rotation offset of this group in the X axis. This is just aliased to the transform property.
            * @property rotPointX
            * @type number
            * @public
            * @since 1.1.0
            */
            get: function () {
                return this.transform.rotPointX;
            },
            set: function (value) {
                this.transform.rotPointX = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "rotPointY", {
            /**
            * The rotation offset of this group in the Y axis. This is just aliased to the transform property.
            * @property rotPointY
            * @type number
            * @public
            * @since 1.1.0
            */
            get: function () {
                return this.transform.rotPointY;
            },
            set: function (value) {
                this.transform.rotPointY = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "anchorPointX", {
            /**
            * The anchor point offset of this group in the X axis. This is just aliased to the transform property, and is in turn an alias of rotPointX.
            * @property anchorPointX
            * @type number
            * @public
            * @since 1.1.0
            */
            get: function () {
                return this.transform.anchorPointX;
            },
            set: function (value) {
                this.transform.anchorPointX = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "anchorPointY", {
            /**
            * The anchor point offset of this group in the Y axis. This is just aliased to the transform property, and is in turn an alias of rotPointY.
            * @property anchorPointY
            * @type number
            * @public
            * @since 1.1.0
            */
            get: function () {
                return this.transform.anchorPointY;
            },
            set: function (value) {
                this.transform.anchorPointY = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * Returns the total number of children in this Group. Doesn't distinguish between alive and dead children.
        * @method numChildren
        * @return {Number} The number of children in this Group
        * @public
        */
        Group.prototype.numChildren = function () {
            return this.members.length;
        };
        Object.defineProperty(Group.prototype, "dirty", {
            get: function () {
                return this._dirty;
            },
            /**
            * Sets all children of the Group to be dirty.
            * @property dirty
            * @type boolean
            * @public
            */
            set: function (value) {
                if (value !== undefined) {
                    this._dirty = value;
                    for (var i = 0; i < this.members.length; i++) {
                        this.members[i].dirty = value;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
        * Checks if the given entity is in this group
        * @method contains
        * @param child {IChild} The IChild that you want to checked.
        * @return {boolean} true if entity exists in group.
        * @public
        */
        Group.prototype.contains = function (child) {
            return (this.members.indexOf(child) === -1) ? false : true;
        };
        /**
        * Checks to see if the given object is contained in this group as a descendant
        * @method containsDescendant
        * @param child {object} The IChild that you want to check.
        * @return {boolean}
        * @public
        */
        Group.prototype.containsDescendant = function (child) {
            for (var i = 0; i < this.members.length; i++) {
                var curMember = this.members[i];
                if (curMember.id == child.id || curMember.childType() == Kiwi.Group && curMember.containsDesendant(child)) {
                    return true;
                }
            }
            return false;
        };
        /**
        * Checks to see if one child is an ansector of another child.
        * @method containsAncestor
        * @param descendant {object} The object that you are checking.
        * @param ancestor {Group} The parent (ancestor) that you are checking for.
        * @return {boolean}
        * @public
        */
        Group.prototype.containsAncestor = function (descendant, ancestor) {
            if (descendant.parent === null || descendant.parent === undefined) {
                return false;
            }
            if (descendant.parent == ancestor)
                return true; //desendants parent is the same? 
            return descendant.parent.containsAncestor(descendant.parent, ancestor); //keep going up the chain.
        };
        /**
        * -------------------------
        * Add Children methods
        * -------------------------
        **/
        /**
        * Adds an Entity to this Group. The Entity must not already be in this Group.
        * @method addChild
        * @param child {object} The child to be added.
        * @return {object} The child that was added.
        * @public
        */
        Group.prototype.addChild = function (child) {
            //Implement feature where you can pass as many children to be added. Modify this script to work via the 'arguments' property
            //make sure you aren't adding a state or itself
            if (child.childType() === Kiwi.STATE || child == this)
                return;
            //make sure it is not itself.
            if (child.parent !== null)
                child.parent.removeChild(child);
            //check to see if the child is already part of a group.
            this.members.push(child);
            child.parent = this;
            return child;
        };
        /**
        * Adds an Entity to this Group in the specific location. The Entity must not already be in this Group and it must be supported by the Group.
        * @method addChildAt
        * @param child {object} The child to be added.
        * @param index {Number} The index the child will be set at.
        * @return {object} The child.
        * @public
        */
        Group.prototype.addChildAt = function (child, index) {
            if (child.childType() === Kiwi.STATE || child == this)
                return;
            if (child.parent !== null)
                child.parent.removeChild(child);
            this.members.splice(index, 0, child);
            child.parent = this;
            return child;
        };
        /**
        * Adds an Entity to this Group before another child.
        * @method addChildBefore
        * @param child {object} The child to be added.
        * @param beforeChild {Entity} The child before which the child will be added.
        * @return {object} The child.
        * @public
        */
        Group.prototype.addChildBefore = function (child, beforeChild) {
            if (beforeChild.transform.parent === this.transform) {
                if (child.parent !== null)
                    child.parent.removeChild(child);
                var index = this.getChildIndex(beforeChild);
                this.members.splice(index, 0, child);
                child.parent = this;
            }
            return child;
        };
        /**
        * Adds an Entity to this Group after another child.
        * @method addChildAfter
        * @param child {object} The child to be added.
        * @param beforeChild {object} The child after which the child will be added.
        * @return {object} The child.
        * @public
        */
        Group.prototype.addChildAfter = function (child, afterChild) {
            if (afterChild.transform.parent === this.transform) {
                if (child.parent !== null)
                    child.parent.removeChild(child);
                var index = this.getChildIndex(afterChild) + 1;
                this.members.splice(index, 0, child);
                child.parent = this;
            }
            return child;
        };
        /**
        * --------------------
        * Remove Children Methods
        * --------------------
        **/
        /**
        * Removes an Entity from this Group if it is a child of it.
        * @method removeChild
        * @param child {object} The child to be removed.
        * @param [destroy=false] {boolean} If the entity that gets removed should be destroyed as well.
        * @return {object} The child.
        * @public
        */
        Group.prototype.removeChild = function (child, destroy) {
            if (destroy === void 0) { destroy = false; }
            if (child.parent === this) {
                var index = this.getChildIndex(child);
                if (index > -1) {
                    this.members.splice(index, 1);
                    child.parent = null;
                    if (destroy) {
                        child.destroy();
                    }
                }
            }
            return child;
        };
        /**
        * Removes the Entity from this Group at the given position.
        * @method removeChildAt
        * @param index {Number} The index of the child to be removed.
        * @return {object} The child, or null.
        */
        Group.prototype.removeChildAt = function (index) {
            if (this.members[index]) {
                var child = this.members[index];
                return this.removeChild(child);
            }
            else {
                return null;
            }
        };
        /**
        * Removes all Entities from this Group within the given range.
        * @method removeChildren
        * @param begin {Number} The begining index.
        * @param end {Number} The last index of the range.
        * @param destroy {Number} If the children should be destroyed as well.
        * @return {Number} The number of removed entities.
        * @public
        */
        Group.prototype.removeChildren = function (begin, end, destroy) {
            if (begin === void 0) { begin = 0; }
            if (end === void 0) { end = 0x7fffffff; }
            if (destroy === void 0) { destroy = false; }
            end -= begin;
            var removed = this.members.splice(begin, end);
            for (var i = 0; i < removed.length; i++) {
                removed[i].parent = null;
                if (destroy) {
                    removed[i].destroy();
                }
            }
            return removed.length;
        };
        /**
        * Removes the first Entity from this Group marked as 'alive'
        * @method removeFirstAlive
        * @param [destroy=false] {boolean} If the entity should run the destroy method when it is removed.
        * @return {object} The Entity that was removed from this Group if alive, otherwise null
        * @public
        * @deprecated in v1.1.0
        */
        Group.prototype.removeFirstAlive = function (destroy) {
            if (destroy === void 0) { destroy = false; }
            return this.removeChild(this.getFirstAlive(), destroy);
        };
        /**
        * -------------------
        * Get Children Methods
        * -------------------
        **/
        /**
        * Get all children of this Group. By default, this will search the entire sub-graph, including children of children etc.
        * @method getAllChildren
        * @param getGroups {boolean} Optional: Whether to include Groups in the results. When false, will only collect GameObjects.
        * @param destinationArray {Array} Optional: The array in which to store the results.
        * @return {Array}
        * @since 1.1.0
        */
        Group.prototype.getAllChildren = function (getGroups, destinationArray) {
            if (getGroups === void 0) { getGroups = true; }
            if (destinationArray === void 0) { destinationArray = []; }
            for (var i = 0; i < this.members.length; i++) {
                if (this.members[i].objType() == "Group") {
                    if (getGroups) {
                        destinationArray.push(this.members[i]);
                    }
                    this.members[i].getAllChildren(getGroups, destinationArray);
                }
                else {
                    destinationArray.push(this.members[i]);
                }
            }
            return destinationArray;
        };
        /**
        * Get the child at a specific position in this Group by its index.
        * @method getChildAt
        * @param index {Number} The index of the child
        * @return {object} The child, if found or null if not.
        * @public
        */
        Group.prototype.getChildAt = function (index) {
            if (this.members[index]) {
                return this.members[index];
            }
            else {
                return null;
            }
        };
        /**
        * Get a child from this Group by its name. By default this will not check sub-groups, but if you supply the correct flag it will check the entire scene graph under this object.
        * @method getChildByName
        * @param name {String} The name of the child.
        * @param recurse {Boolean} Whether to search child groups for the child. Default FALSE.
        * @return {object} The child, if found or null if not.
        * @public
        */
        Group.prototype.getChildByName = function (name, recurse) {
            if (recurse === void 0) { recurse = false; }
            for (var i = 0; i < this.members.length; i++) {
                if (this.members[i].name === name) {
                    return this.members[i];
                }
                else if (this.members[i].objType() == "Group" && recurse) {
                    var groupResponse = this.members[i].getChildByName(name, true);
                    if (groupResponse !== null) {
                        return groupResponse;
                    }
                }
            }
            return null;
        };
        /**
        * Get a child from this Group by its UUID. By default this will not check sub-groups, but if you supply the correct flag it will check the entire scene graph under this object.
        * @method getChildByID
        * @param id {String} The ID of the child.
        * @param recurse {Boolean} Whether to search child groups for the child. Default FALSE.
        * @return {object} The child, if found or null if not.
        * @public
        */
        Group.prototype.getChildByID = function (id, recurse) {
            if (recurse === void 0) { recurse = false; }
            for (var i = 0; i < this.members.length; i++) {
                if (this.members[i].id === id) {
                    return this.members[i];
                }
                else if (this.members[i].objType() == "Group" && recurse) {
                    var groupResponse = this.members[i].getChildByID(id, true);
                    if (groupResponse !== null) {
                        return groupResponse;
                    }
                }
            }
            return null;
        };
        /**
        * Returns the index position of the Entity or -1 if not found.
        * @method getChildIndex
        * @param child {object} The child.
        * @return {Number} The index of the child or -1 if not found.
        * @public
        */
        Group.prototype.getChildIndex = function (child) {
            return this.members.indexOf(child);
        };
        /**
        * Returns the first Entity from this Group marked as 'alive' or null if no members are alive
        * @method getFirstAlive
        * @return {object}
        * @public
        * @deprecated in v1.1.0
        */
        Group.prototype.getFirstAlive = function () {
            for (var i = 0; i < this.members.length; i++) {
                if (this.members[i].exists === true) {
                    return this.members[i];
                }
            }
            return null;
        };
        /**
        * Returns the first member of the Group which is not 'alive', returns null if all members are alive.
        * @method getFirstDead
        * @return {object}
        * @public
        * @deprecated in v1.1.0
        */
        Group.prototype.getFirstDead = function () {
            for (var i = 0; i < this.members.length; i++) {
                if (this.members[i].exists === false) {
                    return this.members[i];
                }
            }
            return null;
        };
        /**
        * Returns a member at random from the group.
        * @param {Number}	StartIndex	Optional offset off the front of the array. Default value is 0, or the beginning of the array.
        * @param {Number}	Length		Optional restriction on the number of values you want to randomly select from.
        * @return {object}	A child from the members list.
        * @public
        */
        Group.prototype.getRandom = function (start, length) {
            if (start === void 0) { start = 0; }
            if (length === void 0) { length = 0; }
            if (this.members.length === 0) {
                return null;
            }
            /*
            if (length === 0) {
                length = this.members.length;
            }

            if (start < 0 || start > length) {
                start = 0;
            }

            var rnd = start + (Math.random() * (start + length));

            if (rnd > this.members.length) {
                return this.members[this.members.length - 1];

            } else {
                return this.members[rnd];
            }
            */
            // Comply start to viable range
            start = Kiwi.Utils.GameMath.clamp(start, this.members.length - 1);
            // Comply length to fit
            if (length === 0) {
                length = this.members.length;
            }
            if (this.members.length <= start + length) {
                length = this.members.length - start - 1;
            }
            // Create and truncate random index
            var rnd = start + Math.random() * length;
            rnd = Math.floor(rnd);
            // Return
            return this.members[rnd];
        };
        /**
        * Returns an array of children which contain the tag which is passed.
        * @method getChildrenByTag
        * @param tag {string}
        * @return {Array}
        * @public
        * @since 1.1.0
        */
        Group.prototype.getChildrenByTag = function (tag) {
            var children = [];
            for (var i = 0; i < this.members.length; i++) {
                if (this.members[i].hasTag(tag)) {
                    children.push(this.members[i]);
                }
                if (this.members[i].childType() == Kiwi.GROUP) {
                    children = children.concat(this.members[i].getChildrenByTag(tag));
                }
            }
            return children;
        };
        /**
        * Returns the first child which contains the tag passed.
        * @method getFirstChildByTag
        * @param tag {String}
        * @return {IChild}
        * @public
        * @since 1.3.0
        */
        Group.prototype.getFirstChildByTag = function (tag) {
            for (var i = 0; i < this.members.length; i++) {
                if (this.members[i].hasTag(tag)) {
                    return this.members[i];
                }
                if (this.members[i].childType() == Kiwi.GROUP) {
                    var child = (this.members[i].getFirstChildByTag(tag));
                    if (child) {
                        return child;
                    }
                }
            }
            return null;
        };
        /**
        * Returns the last child which contains the tag passed.
        * @method getLastChildByTag
        * @param tag {String}
        * @return {IChild}
        * @public
        * @since 1.3.0
        */
        Group.prototype.getLastChildByTag = function (tag) {
            for (var i = this.members.length - 1; i >= 0; i--) {
                if (this.members[i].hasTag(tag)) {
                    return this.members[i];
                }
                if (this.members[i].childType() == Kiwi.GROUP) {
                    var child = (this.members[i].getLastChildByTag(tag));
                    if (child) {
                        return child;
                    }
                }
            }
            return null;
        };
        /**
        * --------------------
        * Child Depth Sorting Methods
        * --------------------
        **/
        /**
        * Sets a new position of an existing Entity within the Group.
        * @method setChildIndex
        * @param child {object} The child in this Group to change.
        * @param index {Number} The index for the child to be set at.
        * @return {boolean} true if the Entity was moved to the new position, otherwise false.
        * @public
        */
        Group.prototype.setChildIndex = function (child, index) {
            //  If the Entity isn't in this Group, or is already at that index then bail out
            if (child.parent !== this || this.getChildIndex(child) === index) {
                return false;
            }
            this.removeChild(child);
            this.addChildAt(child, index);
            return true;
        };
        /**
        * Swaps the position of two existing Entities that are a direct child of this group.
        * @method swapChildren
        * @param child1 {object} The first child in this Group to swap.
        * @param child2 {object} The second child in this Group to swap.
        * @return {boolean} true if the Entities were swapped successfully, otherwise false.
        * @public
        */
        Group.prototype.swapChildren = function (child1, child2) {
            //  If either Entity isn't in this Group, or is already at that index then bail out
            if (child1.parent !== this || child2.parent !== this) {
                return false;
            }
            var index1 = this.getChildIndex(child1);
            var index2 = this.getChildIndex(child2);
            if (index1 !== -1 && index2 !== -1 && index1 !== index2) {
                this.members[index1] = child2;
                this.members[index2] = child1;
                return true;
            }
            return false;
        };
        /**
        * Swaps the position of two existing Entities within the Group based on their index.
        * @method swapChildrenAt
        * @param index1 {Number} The position of the first Entity in this Group to swap.
        * @param index2 {Number} The position of the second Entity in this Group to swap.
        * @return {boolean} true if the Entities were swapped successfully, otherwise false.
        * @public
        */
        Group.prototype.swapChildrenAt = function (index1, index2) {
            var child1 = this.getChildAt(index1);
            var child2 = this.getChildAt(index2);
            if (child1 !== null && child2 !== null) {
                //  If either Entity isn't in this Group, or is already at that index then bail out
                if (child1 == child2 || child1.parent !== this || child2.parent !== this) {
                    return false;
                }
                this.members[index1] = child2;
                this.members[index2] = child1;
                return true;
            }
            return false;
        };
        /**
        * Replaces a child Entity in this Group with a new one.
        * @method replaceChild
        * @param oldChild {object} The Entity in this Group to be removed.
        * @param newChild {object} The new Entity to insert into this Group at the old Entities position.
        * @return {boolean} true if the Entities were replaced successfully, otherwise false.
        * @public
        */
        Group.prototype.replaceChild = function (oldChild, newChild) {
            //fall through if replacing child with the same child
            if (oldChild === newChild)
                return false;
            // get the index of the existing child
            var index = this.getChildIndex(oldChild);
            if (index > -1) {
                // remove the new child from the group if the group contains it, so it can be reinserted in new position
                if (newChild.parent) {
                    newChild.parent.removeChild(newChild);
                }
                this.removeChildAt(index);
                this.addChildAt(newChild, index);
                newChild.parent = null;
                return true;
            }
            return false;
        };
        /**
        * Loops through each member in the group and run a method on for each one.
        * @method forEach
        * @param context {any} The context that the callbacks are to have when called.
        * @param callback {any} The callback method to execute on each member.
        * @param [params]* {any} Any extra parameters.
        * @public
        */
        Group.prototype.forEach = function (context, callback) {
            var params = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                params[_i - 2] = arguments[_i];
            }
            if (this.members.length > 0) {
                this.members.forEach(function (child) { return callback.apply(context, [child].concat(params)); });
            }
        };
        /**
        * Loop through each member of the groups that is alive.
        * @method forEachAlive
        * @param context {any} The context that the callbacks are to have when called.
        * @param callback {any} The callback method to execute on each member.
        * @param [params]* {any} Any extra parameters.
        * @public
        */
        Group.prototype.forEachAlive = function (context, callback) {
            var params = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                params[_i - 2] = arguments[_i];
            }
            if (this.members.length > 0) {
                this.members.forEach(function (child) {
                    if (child.exists)
                        callback.apply(context, [child].concat(params));
                });
            }
        };
        /**
        * Sets a property on every member. If componentName is null the property is set on the entity itself, otherwise it is set on the named component. Uses runtime string property lookups. Not optimal for large groups if speed is an issue.
        * @method setAll
        * @param componentName {string} The name of the component to set the property on - set to null to set a property on the entity.
        * @param property {string} The name of the property to set.
        * @param value {any} The value to set the property to.
        * @public
        */
        Group.prototype.setAll = function (componentName, property, value) {
            if (componentName === null) {
                for (var i = 0; i < this.members.length; i++) {
                    this.members[i][property] = value;
                }
            }
            else {
                for (var i = 0; i < this.members.length; i++) {
                    this.members[i][componentName][property] = value;
                }
            }
        };
        /**
        * Calls a function on every member. If componentName is null the function is called on the entity itself, otherwise it is called on the named component. Uses runtime string property lookups. Not optimal for large groups if speed is an issue.
        * @method callAll
        * @param componentName {string} The name of the component to call the function on - set to null to call a function on the entity.
        * @param functionName {string} The name of the function to call.
        * @param args {Array} An array of arguments to pas to the function.
        * @public
        */
        Group.prototype.callAll = function (componentName, functionName, args) {
            if (componentName === null) {
                for (var i = 0; i < this.members.length; i++) {
                    this.members[i][functionName].apply(this.members[i], args);
                }
            }
            else {
                for (var i = 0; i < this.members.length; i++) {
                    this.members[i][componentName][functionName].apply(this.members[i][componentName], args);
                }
            }
        };
        /**
        * The update loop for this group.
        * @method update
        * @public
        */
        Group.prototype.update = function () {
            this.components.preUpdate();
            this.components.update();
            if (this.members.length > 0) {
                for (var i = 0; i < this.members.length; i++) {
                    if (this.members[i].active === true) {
                        this.members[i].update();
                    }
                    if (this.members[i].exists === false) {
                        this.members[i].destroy(true);
                    }
                }
            }
            this.components.postUpdate();
        };
        Object.defineProperty(Group.prototype, "exists", {
            get: function () {
                return this._exists;
            },
            /**
            * Toggles the exitence of this Group. An Entity that no longer exists can be garbage collected or re-allocated in a pool
            * This method should be over-ridden to handle specific canvas/webgl implementations.
            * @property exists
            * @type boolean
            * @public
            */
            set: function (value) {
                this._exists = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "active", {
            get: function () {
                return this._active;
            },
            /**
            * Toggles the active state of this Entity. An Entity that is active has its update method called by its parent.
            * This method should be over-ridden to handle specific dom/canvas/webgl implementations.
            * @property active
            * @type boolean
            * @default true
            * @public
            */
            set: function (value) {
                this._active = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * The render method that is required by the IChild.
        * This method never gets called as the render is only worried about rendering entities.
        * @method render
        * @param camera {Kiwi.Camera}
        * @public
        * @deprecated
        */
        Group.prototype.render = function (camera) {
        };
        /**
        * Returns the number of member which are marked as 'alive'
        * @method countLiving
        * @return {Number}
        * @public
        */
        Group.prototype.countLiving = function () {
            var total = 0;
            for (var i = 0; i < this.members.length; i++) {
                if (this.members[i].exists === true) {
                    total++;
                }
            }
            return total;
        };
        /**
        * Returns the number of member which are not marked as 'alive'
        * @method countDead
        * @return {Number}
        * @public
        */
        Group.prototype.countDead = function () {
            var total = 0;
            for (var i = 0; i < this.members.length; i++) {
                if (this.members[i].exists === false) {
                    total++;
                }
            }
            return total;
        };
        /**
        * Clear all children from this Group
        * @method clear
        * @public
        */
        Group.prototype.clear = function () {
            this.members.length = 0;
        };
        Object.defineProperty(Group.prototype, "willRender", {
            get: function () {
                return this._willRender;
            },
            /**
            * Controls whether render is automatically called by the parent.
            * @property willRender
            * @type boolean
            * @return {boolean}
            * @public
            * @deprecated Use visible instead
            */
            set: function (value) {
                this._willRender = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "visible", {
            get: function () {
                return this._visible;
            },
            /**
            * Set the visibility of this entity. True or False.
            * @property visible
            * @type boolean
            * @default true
            * @public
            * @since 1.0.1
            */
            set: function (value) {
                this._visible = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * Adds a new Tag to this Entity. Useful for identifying large amounts of the same type of GameObjects.
        * You can pass multiple strings to add multiple tags.
        * @method addTag
        * @param tag {string} The tag that you would like to add to this Entity.
        * @since 1.1.0
        * @public
        */
        Group.prototype.addTag = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            //Loop through the arguments
            for (var i = 0; i < args.length; i++) {
                if (this._tags.indexOf(args[i]) == -1) {
                    this._tags.push(args[i]);
                }
            }
        };
        /**
        * Removes a Tag from this Entity.
        * @method removeTag
        * @param tag {string} The tag that you would like to remove from this Entity.
        * @since 1.1.0
        * @public
        */
        Group.prototype.removeTag = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            for (var i = 0; i < args.length; i++) {
                var index = this._tags.indexOf(args[i]);
                if (index !== -1)
                    this._tags.splice(index, 1);
            }
        };
        /**
        * Checks to see if this Entity has a Tag based upon a string which you pass.
        * @method hasTag
        * @param tag {string}
        * @since 1.1.0
        * @return {boolean}
        * @public
        */
        Group.prototype.hasTag = function (tag) {
            var len = this._tags.length;
            while (len--) {
                if (this._tags[len] === tag) {
                    return true;
                }
            }
            return false;
        };
        /**
        * Removes all children and destroys the Group.
        * @method destroy
        * @param [immediate=false] {boolean} If the object should be immediately removed or if it should be removed at the end of the next update loop.
        * @param [destroyChildren=true] {boolean} If all of the children on the group should also have their destroy methods called.
        * @public
        */
        Group.prototype.destroy = function (immediate, destroyChildren) {
            if (immediate === void 0) { immediate = false; }
            if (destroyChildren === void 0) { destroyChildren = true; }
            this._exists = false;
            this._active = false;
            this._visible = false;
            if (immediate === true) {
                if (this._tempRemoveChildren !== null)
                    destroyChildren = this._tempRemoveChildren;
                if (destroyChildren == true) {
                    //Remove all of the children.
                    for (var i = 0; i < this.members.length; i++) {
                        this.members[i].destroy(true);
                    }
                }
                else {
                    this.removeChildren();
                }
                if (this.parent !== null)
                    this.parent.removeChild(this);
                if (this.state)
                    this.state.removeFromTrackingList(this);
                delete this.transform;
                if (this.components)
                    this.components.removeAll();
                delete this.components;
                delete this.game;
                delete this.state;
            }
            else {
                this._tempRemoveChildren = destroyChildren;
            }
        };
        return Group;
    })();
    Kiwi.Group = Group;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
*
*/
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Kiwi;
(function (Kiwi) {
    /**
    * A State in Kiwi.JS is the main class that developers use when wanting to create a Game.
    * States in Kiwi are used keep different sections of a game seperated. So a single game maybe comprised of many different States.
    * Such as one for the menu, in-game, leaderboard, e.t.c.
    * There can only ever be a single State active at a given time.
    *
    * @class State
    * @namespace Kiwi
    * @extends Kiwi.Group
    * @constructor
    * @param name {String} Name of this State. Should be unique to differentiate itself from other States.
    * @return {Kiwi.State}
    */
    var State = (function (_super) {
        __extends(State, _super);
        function State(name) {
            _super.call(this, null, name);
            /**
            * A reference to the Kiwi.Game that this State belongs to.
            * @property game
            * @type Kiwi.Game
            * @public
            */
            this.game = null;
            this.config = new Kiwi.StateConfig(this, name);
            this.components = new Kiwi.ComponentManager(Kiwi.STATE, this);
            this.transform.parent = null;
            this._trackingList = [];
        }
        /**
        * Returns the type of object this state is.
        * @method objType
        * @return {String} "State"
        * @public
        */
        State.prototype.objType = function () {
            return "State";
        };
        /**
        * Returns the type of child this is.
        * @method childType
        * @return {Number} Kiwi.GROUP
        * @public
        */
        State.prototype.childType = function () {
            return Kiwi.GROUP;
        };
        /**
        * This method is executed when this State is about to be switched too. This is the first method to be executed, and happens before the Init method.
        * Is called each time a State is switched to.
        * @method boot
        * @public
        */
        State.prototype.boot = function () {
            this.textureLibrary = new Kiwi.Textures.TextureLibrary(this.game);
            this.textures = this.textureLibrary.textures;
            this.audioLibrary = new Kiwi.Sound.AudioLibrary(this.game);
            this.audio = this.audioLibrary.audio;
            this.dataLibrary = new Kiwi.Files.DataLibrary(this.game);
            this.data = this.dataLibrary.data;
        };
        /*
        * Currently unused.
        */
        State.prototype.setType = function (value) {
            if (this.config.isInitialised === false) {
                this.config.type = value;
            }
        };
        /*
        *--------------
        * Methods that are to be Over-Ridden by Devs.
        *--------------
        */
        /**
        * Gets executed when the state has been initalised and gets switched to for the first time.
        * This method only ever gets called once and it is before the preload method.
        * Can have parameters passed to it by the previous state that switched to it.
        * @method init
        * @param [values] { Any }
        * @public
        */
        State.prototype.init = function () {
            var paramsArr = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                paramsArr[_i - 0] = arguments[_i];
            }
        };
        /**
        * This method is where you would load of all the assets that are requried for this state or in the entire game.
        *
        * @method preload
        * @public
        */
        State.prototype.preload = function () { };
        /**
        * This method is progressively called whilst loading files and is executed each time a file has been loaded.
        * This can be used to create a 'progress' bar during the loading stage of a game.
        * @method loadProgress
        * @param percent {Number} The percent of files that have been loaded so far. This is a number from 0 - 1.
        * @param bytesLoaded {Number} The number of bytes that have been loaded so far.
        * @param file {Kiwi.Files.File} The last file to have been loaded.
        * @public
        */
        State.prototype.loadProgress = function (percent, bytesLoaded, file) { };
        /**
        * Gets executed when the game is finished loading and it is about to 'create' the state.
        * @method loadComplete
        * @public
        */
        State.prototype.loadComplete = function () { };
        /**
        * The game loop that gets executed while the game is loading.
        * @method loadUpdate
        * @public
        */
        State.prototype.loadUpdate = function () {
            for (var i = 0; i < this.members.length; i++) {
                if (this.members[i].active === true) {
                    this.members[i].update();
                }
            }
        };
        /**
        * Is executed once all of the assets have loaded and the game is ready to be 'created'.
        * @method create
        * @param [values]* {Any}
        * @public
        */
        State.prototype.create = function () {
            var paramsArr = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                paramsArr[_i - 0] = arguments[_i];
            }
        };
        /**
        * Is called every frame before the update loop. When overriding make sure you include a super call.
        * @method preUpdate
        * @public
        */
        State.prototype.preUpdate = function () {
            this.components.preUpdate();
        };
        /**
        * The update loop that is executed every frame while the game is 'playing'. When overriding make sure you include a super call too.
        * @method update
        * @public
        */
        State.prototype.update = function () {
            this.components.update();
            for (var i = 0; i < this.members.length; i++) {
                //Should the update loop be executed?
                if (this.members[i].active === true) {
                    this.members[i].update();
                }
                //Does the child need to be destroyed?
                if (this.members[i].exists === false) {
                    this.members[i].destroy(true);
                }
            }
        };
        /**
        * The post update loop is executed every frame after the update method.
        * When overriding make sure you include a super call at the end of the method.
        * @method postUpdate
        * @public
        */
        State.prototype.postUpdate = function () {
            this.components.postUpdate();
        };
        /**
        * Called after all of the layers have rendered themselves, useful for debugging.
        * @method postRender
        * @public
        */
        State.prototype.postRender = function () { };
        /**
        * Called just before this State is going to be Shut Down and another one is going to be switched too.
        * @method shutDown
        * @public
        */
        State.prototype.shutDown = function () { };
        /*
        *--------------
        * Loading Methods
        *--------------
        */
        /**
        * Adds a new image file that is be loaded when the state gets up to the loading all of the assets.
        *
        * @method addImage
        * @param key {String} A key for this image so that you can access it when the loading has finished.
        * @param url {String} The location of the image.
        * @param [storeAsGlobal=true] {boolean} If the image should be deleted when switching to another state or if the other states should still be able to access this image.
        * @param [width] {Number} The width of the image. If not passed the width will be automatically calculated.
        * @param [height] {Number} The height of the image. If not passed the height will be automatically calculated.
        * @param [offsetX] {Number} The offset of the image when rendering on the x axis.
        * @param [offsetY] {Number} The offset of the image when rendering on the y axis.
        * @public
        */
        State.prototype.addImage = function (key, url, storeAsGlobal, width, height, offsetX, offsetY) {
            if (storeAsGlobal === void 0) { storeAsGlobal = true; }
            return this.game.loader.addImage(key, url, width, height, offsetX, offsetY, storeAsGlobal);
        };
        /**
        * Adds a new spritesheet image file that is be loaded when the state gets up to the loading all of the assets.
        *
        * @method addSpriteSheet
        * @param key {String} A key for this image so that you can access it when the loading has finished.
        * @param url {String} The location of the image.
        * @param frameWidth {Number} The width of a single frame in the spritesheet
        * @param frameHeight {Number} The height of a single frame in the spritesheet
        * @param [storeAsGlobal=true] {boolean} If the image should be deleted when switching to another state or if the other states should still be able to access this image.
        * @param [numCells] {Number} The number of cells/frames that are in the spritesheet. If not specified will calculate this based of the width/height of the image.
        * @param [rows] {Number} The number of cells that are in a row. If not specified will calculate this based of the width/height of the image.
        * @param [cols] {Number} The number of cells that are in a column. If not specified will calculate this based of the width/height of the image.
        * @param [sheetOffsetX=0] {Number} The offset of the whole spritesheet on the x axis.
        * @param [sheetOffsetY=0] {Number} The offset of the whole spritesheet on the y axis.
        * @param [cellOffsetX=0] {Number} The spacing between cells on the x axis.
        * @param [cellOffsetY=0] {Number} The spacing between cells on the y axis.
        * @public
        */
        State.prototype.addSpriteSheet = function (key, url, frameWidth, frameHeight, storeAsGlobal, numCells, rows, cols, sheetOffsetX, sheetOffsetY, cellOffsetX, cellOffsetY) {
            if (storeAsGlobal === void 0) { storeAsGlobal = true; }
            return this.game.loader.addSpriteSheet(key, url, frameWidth, frameHeight, numCells, rows, cols, sheetOffsetX, sheetOffsetY, cellOffsetX, cellOffsetY, storeAsGlobal);
        };
        /**
        * Adds a new texture atlas that is to be loaded when the states gets up to the stage of loading the assets.
        *
        * @method addTextureAtlas
        * @param key {String} A key for this image so that you can access it when the loading has finished.
        * @param imageURL {String} The location of the image.
        * @param [jsonID] {String} The id for the json file that is to be loaded. So that you can access it outside of the texture atlas.
        * @param [jsonURL] {String} The location of the json file you have loaded.
        * @param [storeAsGlobal=true] {boolean} If the image should be delete when switching to another state or if the other states should still be able to access this image.
        * @public
        */
        State.prototype.addTextureAtlas = function (key, imageURL, jsonID, jsonURL, storeAsGlobal) {
            if (storeAsGlobal === void 0) { storeAsGlobal = true; }
            return this.game.loader.addTextureAtlas(key, imageURL, jsonID, jsonURL, storeAsGlobal);
        };
        /**
        * Adds a json file that is to be loaded when the state gets up to the stage of loading the assets.
        *
        * @method addJSON
        * @param key {string} A key for this json so that you can access it when the loading has finished
        * @param url {string} The location of the JSON file.
        * @param [storeAsGlobal=true] {boolean} If the json should be deleted when switching to another state or if the other states should still be able to access this json.
        * @public
        */
        State.prototype.addJSON = function (key, url, storeAsGlobal) {
            if (storeAsGlobal === void 0) { storeAsGlobal = true; }
            return this.game.loader.addJSON(key, url, storeAsGlobal);
        };
        /**
        * Adds a new audio file that is to be loaded when the state gets up to the stage of loading the assets.
        *
        * @method addAudio
        * @param key {string} A key for this audio so that you can access it when the loading has finished
        * @param url {string} The location of the audio file. You can pass a array of urls, in which case the first supported filetype will be used.
        * @param [storeAsGlobal=true] {boolean} If the audio should be deleted when switching to another state or if the other states should still be able to access this audio.
        */
        State.prototype.addAudio = function (key, url, storeAsGlobal) {
            if (storeAsGlobal === void 0) { storeAsGlobal = true; }
            return this.game.loader.addAudio(key, url, storeAsGlobal);
        };
        /**
        * Adds a new Objects to the tracking list.
        * This is an INTERNAL Kiwi method and DEVS shouldn't need to worry about it.
        * @method addToTrackingList
        * @param child {Object} The Object which you are adding to the tracking list.
        * @public
        */
        State.prototype.addToTrackingList = function (child) {
            //check to see that its not already in the tracking list.
            if (this._trackingList.indexOf(child) !== -1)
                return;
            //add to the list
            this._trackingList.push(child);
        };
        /**
        * Removes a Object from the tracking list. This should only need to happen when a child is being destroyed.
        * This is an INTERNAL Kiwi method and DEVS shouldn't really need to worry about it.
        * @method removeFromTrackingList
        * @param child {Object} The object which is being removed from the tracking list.
        * @public
        */
        State.prototype.removeFromTrackingList = function (child) {
            //check to see that it is in the tracking list.
            var n = this._trackingList.indexOf(child);
            if (n > -1) {
                this._trackingList.splice(n, 1);
            }
        };
        /**
        * Destroys all of Objects in the tracking list that are not currently on stage.
        * All that currently don't have this STATE as an ancestor.
        * Returns the number of Objects removed.
        * @method destroyUnused
        * @return {Number} The amount of objects removed.
        * @public
        */
        State.prototype.destroyUnused = function () {
            var d = 0;
            for (var i = 0; i < this._trackingList.length; i++) {
                if (this.containsAncestor(this._trackingList[i], this) === false) {
                    this._trackingList[i].destroy();
                    this._trackingList.splice(i, 1);
                    i--;
                    d++;
                }
            }
            return d;
        };
        /**
        * Used to mark all Entities that have been created for deletion, regardless of it they are on the stage or not.
        * @method destroy
        * @param [deleteAll=true] If all of the Objects ever created should have the destroy method executed also.
        * @public
        */
        State.prototype.destroy = function (deleteAll) {
            if (deleteAll === void 0) { deleteAll = true; }
            if (deleteAll == true) {
                //destroy all of the tracking list
                while (this._trackingList.length > 0) {
                    //If the item is a group then we don't want it to destroy it's children, as this method will do that eventually anyway.
                    this._trackingList[0].destroy(true, false);
                }
                this._trackingList = [];
                //destroy all of the groups members. Usually they would be apart of the trackingList 
                while (this.members.length > 0) {
                    //If the item is a group then we don't want it to destroy it's children, as this method will do that eventually anyway.
                    this.members[0].destroy(true, false);
                }
                this.members = [];
            }
        };
        /**
        * Recursively goes through a child given and runs the destroy method on all that are passed.
        * @method _destroyChildren
        * @param child {Object}
        * @private
        */
        State.prototype._destroyChildren = function (child) {
            if (child.childType() == Kiwi.GROUP) {
                for (var i = 0; i < child.members.length; i++) {
                    this._destroyChildren(child.members[i]);
                }
            }
            child.destroy(true);
        };
        return State;
    })(Kiwi.Group);
    Kiwi.State = State;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
*
*/
var Kiwi;
(function (Kiwi) {
    /**
    * A Camera is used to render a particular section of the game world on the stage. Each Camera has a coordinates which are held in the transform property, and a width/height. Note: This class should never be directly instantiated but instead should be made through a CameraManager's 'create' method.
    *
    * @class Camera
    * @namespace Kiwi
    * @constructor
    * @param game {Kiwi.Game} The game that this camera belongs to.
    * @param id {Number} A unique ID for this camera
    * @param name {String} The name this camera goes by
    * @param x {Number} The x coordinate of the camera
    * @param y {Number} The y coordinate of the camera
    * @param width {Number} The width of the camera
    * @param height {Number} The cameras height
    * @return {Kiwi.Camera}
    *
    */
    var Camera = (function () {
        function Camera(game, id, name, x, y, width, height) {
            /**
            * If true then the camera will be resized to fit the stage when the stage is resized
            * @property fitToStage
            * @type boolean
            * @default true
            * @public
            */
            this.fitToStage = true;
            this._game = game;
            this.id = id;
            this.name = name;
            //size could autoresize to fit stage
            this.width = width;
            this.height = height;
            this.transform = new Kiwi.Geom.Transform(x, y);
            this.transform.rotPointX = x + width / 2;
            this.transform.rotPointY = y + height / 2;
            this._game.stage.onResize.add(this._updatedStageSize, this);
            this._scratchMatrix = new Kiwi.Geom.Matrix();
        }
        /**
        * The type of object this is.
        * @method objType
        * @return {String} "Camera"
        * @public
        */
        Camera.prototype.objType = function () {
            return "Camera";
        };
        /**
        * Updates the width/height of this camera. Is used when the stage resizes.
        * @method _updatedStageSize
        * @param width {Number} The new width of the camera.
        * @param height {Number} The new height of the camera.
        * @private
        */
        Camera.prototype._updatedStageSize = function (width, height) {
            this.width = width;
            this.height = height;
        };
        Object.defineProperty(Camera.prototype, "visible", {
            /**
            * Controls whether this Camera is rendered.
            * @property visible
            * @type boolean
            * @public
            */
            get: function () {
                return this._visible;
            },
            set: function (val) {
                this._visible = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "dirty", {
            /**
            * A value used by components to control if the camera needs re-rendering.
            * @property dirty
            * @type boolean
            * @public
            * @deprecated As of 1.1.0, no use has been found for this property.
            */
            get: function () {
                return this._dirty;
            },
            set: function (val) {
                this._dirty = val;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * Convert from screen coordinates to world coordinates.
        * Apply this camera's inverted matrix to an object with x and y
        * properties representing a point and return the transformed point.
        * Useful for calculating coordinates with the mouse.
        * @method transformPoint
        * @param point {Kiwi.Geom.Point}
        * @return {Kiwi.Geom.Point} Transformed clone of the original Point.
        * @public
        */
        Camera.prototype.transformPoint = function (point) {
            var m, np = point.clone();
            this._scratchMatrix.copyFrom(this.transform.getConcatenatedMatrix());
            m = this._scratchMatrix;
            m.append(1, 0, 0, 1, -this.transform.rotPointX, -this.transform.rotPointY);
            m.invert();
            return m.transformPoint(np);
        };
        /**
        * Convert from world coordinates to screen coordinates.
        * Useful for assessing visibility.
        * Similar to "transformPoint", but in reverse.
        * @method transformPointToScreen
        * @param point {Kiwi.Geom.Point}
        * @return {Kiwi.Geom.Point} Transformed clone of the original Point.
        * @public
        * @since 1.2.0
        */
        Camera.prototype.transformPointToScreen = function (point) {
            var m, np = point.clone();
            this._scratchMatrix.copyFrom(this.transform.getConcatenatedMatrix());
            m = this._scratchMatrix;
            m.append(1, 0, 0, 1, -this.transform.rotPointX, -this.transform.rotPointY);
            return m.transformPoint(np);
        };
        /**
        * The update loop that is executed every frame.
        * @method update
        * @public
        */
        Camera.prototype.update = function () {
        };
        /**
        * The render loop that is executed whilst the game is playing.
        * @method render
        * @public
        */
        Camera.prototype.render = function () {
            this._game.renderer.render(this);
        };
        return Camera;
    })();
    Kiwi.Camera = Camera;
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
*
*/
var Kiwi;
(function (Kiwi) {
    /**
    * A TypeScript conversion of JS Signals by Miller Medeiros.
    * Released under the MIT license
    * http://millermedeiros.github.com/js-signals/
    *
    * @class Signal
    * @namespace Kiwi
    * @constructor
    *
    * @author Miller Medeiros, JS Signals
    */
    var Signal = (function () {
        function Signal() {
            /**
            * A list of all of the signal bindings that have been attached.
            * @property _bindings
            * @type Array
            * @private
            */
            this._bindings = [];
            /**
            *
            * @property _prevParams
            * @type Any
            * @private
            */
            this._prevParams = null;
            /**
            * If Signal should keep record of previously dispatched parameters.
            * @property memorize
            * @type boolean
            * @default false
            * @public
            */
            this.memorize = false;
            /**
            * If the callbacks should propagate or not.
            * @property _shouldPropagate
            * @type boolean
            * @default true
            * @private
            */
            this._shouldPropagate = true;
            /**
            * If Signal is active and should broadcast events.
            * Note: Setting this property during a dispatch will only affect the next dispatch,
            * if you want to stop the propagation of a signal use `halt()` instead.
            * @property active
            * @type boolean
            * @default true
            * @public
            */
            this.active = true;
        }
        /**
        * Returns the type of this object
        * @method objType
        * @return {String} "Signal"
        * @public
        */
        Signal.prototype.objType = function () {
            return "Signal";
        };
        /**
        * Validates a event listener an is used to check to see if it is valid or not.
        * An event listener is not valid if it is not a function.
        * If a event listener is not valid, then a Error is thrown.
        *
        * @method validateListener
        * @param listener {Any} The event listener to be validated.
        * @param fnName {Any} The name of the function.
        * @public
        */
        Signal.prototype.validateListener = function (listener, fnName) {
            if (typeof listener !== 'function') {
                throw new Error('listener is a required param of {fn}() and should be a Function.'.replace('{fn}', fnName));
            }
        };
        /**
        * Internal Code which handles the registeration of a new callback (known as a "listener").
        * Creates a new SignalBinding for the Signal and then adds the binding to the list by its priority level.
        *
        * @method _registerListener
        * @param listener {Function} The method that is to be dispatched.
        * @param isOnce {boolean} If the method should only be dispatched a single time or not.
        * @param listenerContext {Object} The context that the callback should be executed with when called.
        * @param priority {Number} The priority of this callback when Bindings are dispatched.
        * @return {Kiwi.SignalBinding} The new SignalBinding that was created.
        * @private
        */
        Signal.prototype._registerListener = function (listener, isOnce, listenerContext, priority) {
            var prevIndex = this._indexOfListener(listener, listenerContext);
            var binding;
            if (prevIndex !== -1) {
                binding = this._bindings[prevIndex];
                if (binding.isOnce() !== isOnce) {
                    throw new Error('You cannot add' + (isOnce ? '' : 'Once') + '() then add' + (!isOnce ? '' : 'Once') + '() the same listener without removing the relationship first.');
                }
            }
            else {
                binding = new Kiwi.SignalBinding(this, listener, isOnce, listenerContext, priority);
                this._addBinding(binding);
            }
            if (this.memorize && this._prevParams) {
                binding.execute(this._prevParams);
            }
            return binding;
        };
        /**
        * Handles the process of adding a new SignalBinding to the bindings list by the new Bindings priority.
        *
        * @method _addBinding
        * @param binding {Kiwi.SignalBinding}
        * @private
        */
        Signal.prototype._addBinding = function (binding) {
            //simplified insertion sort
            var n = this._bindings.length;
            do {
                --n;
            } while (this._bindings[n] && binding.priority <= this._bindings[n].priority);
            this._bindings.splice(n + 1, 0, binding);
        };
        /**
        * Returns the index of any Binding which matches the listener and context that is passed.
        * If none match then this method returns -1.
        *
        * @method _indexOfListener
        * @param listener {Function} The method that we are checking to see.
        * @param context {any} The context of the method we are checking.
        * @return {number} The index of listener/context.
        * @private
        */
        Signal.prototype._indexOfListener = function (listener, context) {
            var n = this._bindings.length;
            var cur;
            while (n--) {
                cur = this._bindings[n];
                if (cur.getListener() === listener && cur.context === context) {
                    return n;
                }
            }
            return -1;
        };
        /**
        * Accepts a function and returns a boolean indicating if the function
        * has already been attached to this Signal.
        *
        * @method has
        * @param listener {Function} The method you are checking for.
        * @param [context=null] {Any} The context of the listener.
        * @return {boolean} If this Signal already has the specified listener.
        * @public
        */
        Signal.prototype.has = function (listener, context) {
            if (context === void 0) { context = null; }
            return this._indexOfListener(listener, context) !== -1;
        };
        /**
        * Adds a new listener/callback to this Signal.
        * The listener attached will be executed whenever this Signal dispatches an event.
        *
        * @method add
        * @param listener {Function} Signal handler function.
        * @param [listenerContext=null] {Any} Context on which listener will be executed. (object that should represent the `this` variable inside listener function).
        * @param [priority=0] {Number} The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
        * @return {Kiwi.SignalBinding} An Object representing the binding between the Signal and listener.
        * @public
        */
        Signal.prototype.add = function (listener, listenerContext, priority) {
            if (listenerContext === void 0) { listenerContext = null; }
            if (priority === void 0) { priority = 0; }
            this.validateListener(listener, 'add');
            return this._registerListener(listener, false, listenerContext, priority);
        };
        /**
        * Add listener to the signal that should be removed after first execution (will be executed only once).
        *
        * @method addOnce
        * @param listener {Function} Signal handler function.
        * @param [listenerContext=null] {Any} Context on which listener will be executed (object that should represent the `this` variable inside listener function).
        * @param [priority=0] {Number} The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)
        * @return {Kiwi.SignalBinding} An Object representing the binding between the Signal and listener.
        * @public
        */
        Signal.prototype.addOnce = function (listener, listenerContext, priority) {
            if (listenerContext === void 0) { listenerContext = null; }
            if (priority === void 0) { priority = 0; }
            this.validateListener(listener, 'addOnce');
            return this._registerListener(listener, true, listenerContext, priority);
        };
        /**
        * Remove a single listener from the dispatch queue.
        *
        * @method remove
        * @param listener {Function} Handler function that should be removed.
        * @param [context=null] {Any} Execution context (since you can add the same handler multiple times if executing in a different context).
        * @return {Function} Listener handler function.
        * @public
        */
        Signal.prototype.remove = function (listener, context) {
            if (context === void 0) { context = null; }
            this.validateListener(listener, 'remove');
            var i = this._indexOfListener(listener, context);
            if (i !== -1) {
                this._bindings[i]._destroy(); //no reason to a SignalBinding exist if it isn't attached to a signal
                this._bindings.splice(i, 1);
            }
            return listener;
        };
        /**
        * Remove all listeners from the Signal.
        * @method removeAll
        * @public
        */
        Signal.prototype.removeAll = function () {
            var n = this._bindings.length;
            while (n--) {
                this._bindings[n]._destroy();
            }
            this._bindings.length = 0;
        };
        /**
        * Returns the number of listeners that have been attached to this Signal.
        *
        * @method getNumListeners
        * @return {number} Number of listeners attached to the Signal.
        * @public
        */
        Signal.prototype.getNumListeners = function () {
            return this._bindings.length;
        };
        /**
        * Stop propagation of the event, blocking the dispatch to next listeners on the queue.
        * Note: should be called only during signal dispatch, calling it before/after dispatch won't affect signal broadcast.
        *
        * @method halt
        * @public
        */
        Signal.prototype.halt = function () {
            this._shouldPropagate = false;
        };
        /**
        * Resume propagation of the event, resuming the dispatch to next listeners on the queue.
        * Note: should be called only during signal dispatch, calling it before/after dispatch won't affect signal broadcast.
        *
        * @method resume
        * @public
        */
        Signal.prototype.resume = function () {
            this._shouldPropagate = true;
        };
        /**
        * Dispatch/Broadcast to all listeners added to this Signal.
        * Parameters passed to this method will also be passed to each handler.
        *
        * @method dispatch
        * @param [params]* {any} Parameters that should be passed to each handler.
        * @public
        */
        Signal.prototype.dispatch = function () {
            var paramsArr = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                paramsArr[_i - 0] = arguments[_i];
            }
            if (!this.active) {
                return;
            }
            var n = this._bindings.length;
            var bindings;
            if (this.memorize) {
                this._prevParams = paramsArr;
            }
            if (!n) {
                //should come after memorize
                return;
            }
            bindings = this._bindings.slice(0); //clone array in case add/remove items during dispatch
            this._shouldPropagate = true; //in case `halt` was called before dispatch or during the previous dispatch.
            //execute all callbacks until end of the list or until a callback returns `false` or stops propagation
            //reverse loop since listeners with higher priority will be added at the end of the list
            do {
                n--;
            } while (bindings[n] && this._shouldPropagate && bindings[n].execute(paramsArr) !== false);
        };
        /**
        * Forget memorized arguments. See the 'memorize' property.
        * @method forget
        * @public
        */
        Signal.prototype.forget = function () {
            this._prevParams = null;
        };
        /**
        * Remove all bindings from signal and destroy any reference to external objects (destroy Signal object).
        * Note: calling any method on the signal instance after calling dispose will throw errors.
        * @method dispose
        * @public
        */
        Signal.prototype.dispose = function () {
            this.removeAll();
            delete this._bindings;
            delete this._prevParams;
        };
        /**
        * Signals Version Number
        * @property VERSION
        * @type String
        * @default '1.0.0'
        * @final
        * @static
        * @public
        */
        Signal.VERSION = '1.0.0';
        return Signal;
    })();
    Kiwi.Signal = Signal;
})(Kiwi || (Kiwi = {}));
/**
* Module - Kiwi (Core)
* @module Kiwi
*
*/
var Kiwi;
(function (Kiwi) {
    /**
    * An object that represents a binding between a Signal and a listener function.
    * <br />- <strong>This is an internal constructor and shouldn't be called by regular users.</strong>
    * <br />- inspired by Joa Ebert AS3 SignalBinding and Robert Penner's Slot classes.
    *
    * Released under the MIT license
    * http://millermedeiros.github.com/js-signals/
    *
    * @class SignalBinding
    * @namespace Kiwi
    *
    * @author Miller Medeiros, JS Signals
    * @constructor
    * @internal
    * @name SignalBinding
    * @param signal {Kiwi.Signal} Reference to Signal object that listener is currently bound to.
    * @param listener {Function} Handler function bound to the signal.
    * @param isOnce {boolean} If binding should be executed just once.
    * @param [listenerContext] {Object} Context on which listener will be executed (object that should represent the `this` variable inside listener function).
    * @param [priority=0] {Number} The priority level of the event listener. (default = 0).
    * @return {Kiwi.SignalBinding}
    */
    var SignalBinding = (function () {
        function SignalBinding(signal, listener, isOnce, listenerContext, priority) {
            if (priority === void 0) { priority = 0; }
            /**
            * If binding is active and should be executed.
            * @property active
            * @type boolean
            * @default true
            * @public
            */
            this.active = true;
            /**
            * Default parameters passed to listener during `Signal.dispatch` and `SignalBinding.execute`. (curried parameters)
            * @property params
            * @type Any
            * @default null
            * @public
            */
            this.params = null;
            this._listener = listener;
            this._isOnce = isOnce;
            this.context = listenerContext;
            this._signal = signal;
            this.priority = priority || 0;
        }
        /**
        * The type of object that this is.
        * @method objType
        * @return {String} "SignalBinding"
        * @public
        */
        SignalBinding.prototype.objType = function () {
            return "SignalBinding";
        };
        /**
        * Call listener passing arbitrary parameters.
        * If this binding was added using `Signal.addOnce()` it will be automatically removed from signal dispatch queue,
        * this method is used internally for the signal dispatch.
        *
        * @method execute
        * @param [paramsArr]* {Array} Array of parameters that should be passed to the listener
        * @return {*} Value returned by the listener.
        * @public
        */
        SignalBinding.prototype.execute = function (paramsArr) {
            var handlerReturn;
            var params;
            if (this.active && !!this._listener) {
                params = this.params ? this.params.concat(paramsArr) : paramsArr;
                handlerReturn = this._listener.apply(this.context, params);
                if (this._isOnce) {
                    this.detach();
                }
            }
            return handlerReturn;
        };
        /**
        * Detach this binding from the Signal it is attached to.
        * Alias for 'Signal.remove()'
        *
        * @method detach
        * @return {Function|null} Handler function bound to the signal or `null` if binding was previously detached.
        * @public
        */
        SignalBinding.prototype.detach = function () {
            return this.isBound() ? this._signal.remove(this._listener, this.context) : null;
        };
        /**
        * Checks to see if this Binding is still bound to a Signal and contains a listener.
        * @method isBound
        * @return {boolean} `true` if binding is still bound to the signal and have a listener.
        * @public
        */
        SignalBinding.prototype.isBound = function () {
            return (!!this._signal && !!this._listener);
        };
        /**
        * Returns a boolean indicating whether this event will be exectued just once or not.
        * @method isOnce
        * @return {boolean} If SignalBinding will only be executed once.
        * @public
        */
        SignalBinding.prototype.isOnce = function () {
            return this._isOnce;
        };
        /**
        * Returns the Handler function bound to the Signal.
        * @method getListener
        * @return {Function} Handler function bound to the signal.
        * @public
        */
        SignalBinding.prototype.getListener = function () {
            return this._listener;
        };
        /**
        * Returns the signal which this Binding is currently attached to.
        * @method getSignal
        * @return {Kiwi.Signal} Signal that listener is currently bound to.
        * @public
        */
        SignalBinding.prototype.getSignal = function () {
            return this._signal;
        };
        /**
        * Delete instance properties
        * @method _destory
        * @public
        */
        SignalBinding.prototype._destroy = function () {
            delete this._signal;
            delete this._listener;
            delete this.context;
        };
        return SignalBinding;
    })();
    Kiwi.SignalBinding = SignalBinding;
})(Kiwi || (Kiwi = {}));
/**
* The GameObject namespace holds classes which are designed to be added to a State (either directly, or as an ancestor of a Group) and are the Objects that are used when wanting to render anything visual onto the current State. Each GameObject is a representation of a particular item in a game and as such has information that corresponds to that item (like where they are in the 'GameWorld', the scale of the GameObject, who their parent is, e.t.c). For Example: If you wanted to have a massive background image then you can use the StaticImage GameObject, as that is a relatively light-weight object). Or if you had Player with an Animation, which user's could interactive with, then you would use a Sprite, which is more robust.
*
* @module Kiwi
* @submodule GameObjects
* @main GameObjects
*/
var Kiwi;
(function (Kiwi) {
    var GameObjects;
    (function (GameObjects) {
        /**
        * A Sprite is a general purpose GameObject that contains majority of the functionality that is needed/would be wanted and as such should be used only when you are wanting a GameObject with a lot of interaction. When creating a Sprite you pass to it as TextureAtlas (for the image you want to render), now if that Texture Atlas isn't a SINGLE_IMAGE then the Sprite will have an AnimationManager Component to handle any SpriteSheet animations you need.
        *
        * @class Sprite
        * @namespace Kiwi.GameObjects
        * @extends Kiwi.Entity
        * @constructor
        * @param state {Kiwi.State} The state that this sprite belongs to
        * @param atlas {Kiwi.Textures.TextureAtlas} The texture you want to apply to this entity
        * @param [x=0] {Number} The sprites initial coordinates on the x axis.
        * @param [y=0] {Number} The sprites initial coordinates on the y axis.
        * @param [enableInput=false] {boolean} If the input component should be enabled or not.
        * @return {Sprite}
        */
        var Sprite = (function (_super) {
            __extends(Sprite, _super);
            function Sprite(state, atlas, x, y, enableInput) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (enableInput === void 0) { enableInput = false; }
                _super.call(this, state, x, y);
                if (Kiwi.Utils.Common.isString(atlas)) {
                    atlas = this.state.textures[atlas];
                }
                //Texture atlas error check
                if (typeof atlas == "undefined") {
                    Kiwi.Log.error('A Texture Atlas was not passed when instantiating a new Sprite.', '#sprite', '#texture');
                    this.visible = false;
                    this.active = false;
                    return;
                }
                if (this.game.renderOption === Kiwi.RENDERER_WEBGL) {
                    this.glRenderer = this.game.renderer.requestSharedRenderer("TextureAtlasRenderer");
                }
                this.atlas = atlas;
                this.name = this.atlas.name;
                this.cellIndex = this.atlas.cellIndex;
                //may need to add an optional other cell frame index here
                this.width = atlas.cells[this.cellIndex].w;
                this.height = atlas.cells[this.cellIndex].h;
                this.transform.rotPointX = this.width / 2;
                this.transform.rotPointY = this.height / 2;
                //Create the components needed
                this.box = this.components.add(new Kiwi.Components.Box(this, x, y, this.width, this.height));
                this.input = this.components.add(new Kiwi.Components.Input(this, this.box, enableInput));
                //Check to see if this sprite could be animated or not
                if (this.atlas.type === Kiwi.Textures.TextureAtlas.SINGLE_IMAGE) {
                    this.animation = null;
                    this._isAnimated = false;
                }
                else {
                    this.animation = this.components.add(new Kiwi.Components.AnimationManager(this));
                    this._isAnimated = true;
                }
            }
            /**
            * Returns the type of object that this is.
            * @method objType
            * @return {string} "Sprite"
            * @public
            */
            Sprite.prototype.objType = function () {
                return "Sprite";
            };
            /**
            * Called by parent when its update loop gets executed.
            * @method update
            * @public
            */
            Sprite.prototype.update = function () {
                _super.prototype.update.call(this);
                if (this._isAnimated) {
                    this.width = this.atlas.cells[this.cellIndex].w;
                    this.height = this.atlas.cells[this.cellIndex].h;
                }
            };
            /**
            * Renders the GameObject using Canvas.
            * @method render
            * @param {Kiwi.Camera} camera
            * @public
            */
            Sprite.prototype.render = function (camera) {
                _super.prototype.render.call(this, camera);
                //if it is would even be visible.
                if (this.alpha > 0) {
                    var ctx = this.game.stage.ctx;
                    ctx.save();
                    if (this.alpha > 0 && this.alpha <= 1) {
                        ctx.globalAlpha = this.alpha;
                    }
                    //get entity/view matrix
                    var t = this.transform;
                    var m = t.getConcatenatedMatrix();
                    ctx.transform(m.a, m.b, m.c, m.d, m.tx, m.ty);
                    var cell = this.atlas.cells[this.cellIndex];
                    ctx.drawImage(this.atlas.image, cell.x, cell.y, cell.w, cell.h, -t.rotPointX, -t.rotPointY, cell.w, cell.h);
                    ctx.restore();
                }
            };
            /**
            * Renders the GameObject using WebGL.
            * @method renderGL
            * @param {WebGLRenderingContext} gl
            * @param {Kiwi.Camera} camera
            * @param {Object} params
            * @public
            */
            Sprite.prototype.renderGL = function (gl, camera, params) {
                if (params === void 0) { params = null; }
                this.glRenderer.addToBatch(gl, this, camera);
            };
            return Sprite;
        })(Kiwi.Entity);
        GameObjects.Sprite = Sprite;
    })(GameObjects = Kiwi.GameObjects || (Kiwi.GameObjects = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule GameObjects
*
*/
var Kiwi;
(function (Kiwi) {
    var GameObjects;
    (function (GameObjects) {
        /**
        * A light weight game object for displaying static images that would have little or no interaction with other GameObjects. An Example of this would be a background image. Note: Since a StaticImage is lightweight it doesn't have any AnimationManager to handle the switching of cells (If you were using a SpriteSheet/TextureAtlas). In order to switch cells you can change the value of the cellIndex property.
        *
        * @class StaticImage
        * @namespace Kiwi.GameObjects
        * @extends Kiwi.Entity
        * @constructor
        * @param state {Kiwi.State} The state that this static image belongs to
        * @param atlas {Kiwi.Textures.TextureAtlas} The texture atlas to use as the image.
        * @param [x=0] {Number} Its coordinates on the x axis
        * @param [y=0] {Number} The coordinates on the y axis
        * @return {StaticImage}
        */
        var StaticImage = (function (_super) {
            __extends(StaticImage, _super);
            function StaticImage(state, atlas, x, y) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                _super.call(this, state, x, y);
                if (this.game.renderOption === Kiwi.RENDERER_WEBGL) {
                    this.glRenderer = this.game.renderer.requestSharedRenderer("TextureAtlasRenderer");
                }
                if (Kiwi.Utils.Common.isString(atlas)) {
                    atlas = this.state.textures[atlas];
                }
                //Texture atlas error check.
                if (typeof atlas == "undefined") {
                    Kiwi.Log.error('A Texture Atlas was not passed when instantiating a new Static Image.', '#static-image', '#texture');
                    this.visible = false;
                    this.active = false;
                    return;
                }
                //Set coordinates and texture
                this.atlas = atlas;
                this.cellIndex = this.atlas.cellIndex;
                this.width = atlas.cells[this.cellIndex].w;
                this.height = atlas.cells[this.cellIndex].h;
                this.transform.rotPointX = this.width / 2;
                this.transform.rotPointY = this.height / 2;
                this.box = this.components.add(new Kiwi.Components.Box(this, x, y, this.width, this.height));
            }
            /**
            * Returns the type of object that this is.
            * @method objType
            * @return {string} "StaticImage"
            * @public
            */
            StaticImage.prototype.objType = function () {
                return "StaticImage";
            };
            /**
            * Called by the Layer to which this Game Object is attached
            * @method render
            * @param {Kiwi.Camara} camera
            * @public
            */
            StaticImage.prototype.render = function (camera) {
                _super.prototype.render.call(this, camera);
                //if it is would even be visible.
                if (this.alpha > 0) {
                    var ctx = this.game.stage.ctx;
                    ctx.save();
                    if (this.alpha > 0 && this.alpha <= 1) {
                        ctx.globalAlpha = this.alpha;
                    }
                    //get entity/view matrix
                    var t = this.transform;
                    var m = t.getConcatenatedMatrix();
                    ctx.transform(m.a, m.b, m.c, m.d, m.tx, m.ty);
                    var cell = this.atlas.cells[this.cellIndex];
                    ctx.drawImage(this.atlas.image, cell.x, cell.y, cell.w, cell.h, -t.rotPointX, -t.rotPointY, cell.w, cell.h);
                    ctx.restore();
                }
            };
            /**
            * Renders the GameObject using WebGL.
            * @method renderGL
            * @param {WebGLRenderingContext} gl
            * @param {Kiwi.Camera} camera
            * @param {Object} params
            * @public
            */
            StaticImage.prototype.renderGL = function (gl, camera, params) {
                if (params === void 0) { params = null; }
                this.glRenderer.addToBatch(gl, this, camera);
            };
            return StaticImage;
        })(Kiwi.Entity);
        GameObjects.StaticImage = StaticImage;
    })(GameObjects = Kiwi.GameObjects || (Kiwi.GameObjects = {}));
})(Kiwi || (Kiwi = {}));
/**
* Kiwi - GameObjects
* @module Kiwi
* @submodule GameObjects
*
*/
var Kiwi;
(function (Kiwi) {
    var GameObjects;
    (function (GameObjects) {
        /**
        * TextField is a GameObject that is used when you are wanting to render
        * text onto the current State.
        *
        * TextField has width/height and a hitbox, but because text is difficult
        * to measure, these may not be 100% accurate. It does not have an
        * "Input" component either, although you may choose to add one. Be aware
        * of these limitations.
        *
        * Note that there also exists a "Textfield" object. This is simply a
        * legacy alias of "TextField", which was renamed in v1.2.0 for naming
        * standardization purposes.
        *
        * @class TextField
        * @namespace Kiwi.GameObjects
        * @extends Kiwi.Entity
        * @constructor
        * @param state {Kiwi.State} The state that this TextField belongs to
        * @param text {String} The text that is contained within this textfield.
        * @param [x=0] {Number} The new x coordinate from the Position component
        * @param [y=0] {Number} The new y coordinate from the Position component
        * @param [color="#000000"] {String} The color of the text.
        * @param [size=32] {Number} The size of the text in pixels.
        * @param [weight="normal"] {String} The weight of the text.
        * @param [fontFamily="sans-serif"] {String} The font family that is to be used when rendering.
        * @return {TextField} This Game Object.
        */
        var TextField = (function (_super) {
            __extends(TextField, _super);
            function TextField(state, text, x, y, color, size, weight, fontFamily) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (color === void 0) { color = "#000000"; }
                if (size === void 0) { size = 32; }
                if (weight === void 0) { weight = "normal"; }
                if (fontFamily === void 0) { fontFamily = "sans-serif"; }
                _super.call(this, state, x, y);
                /**
                * If the temporary canvas is dirty and needs to be re-rendered. Only used when the text field rendering is being optimised.
                * @property _tempDirty
                * @type boolean
                * @private
                */
                this._tempDirty = true;
                /**
                * Geometry point used in rendering.
                *
                * @property _pt1
                * @type Kiwi.Geom.Point
                * @private
                */
                this._pt1 = new Kiwi.Geom.Point(0, 0);
                /**
                * Geometry point used in rendering.
                *
                * @property _pt2
                * @type Kiwi.Geom.Point
                * @private
                */
                this._pt2 = new Kiwi.Geom.Point(0, 0);
                /**
                * Geometry point used in rendering.
                *
                * @property _pt3
                * @type Kiwi.Geom.Point
                * @private
                */
                this._pt3 = new Kiwi.Geom.Point(0, 0);
                /**
                * Geometry point used in rendering.
                *
                * @property _pt4
                * @type Kiwi.Geom.Point
                * @private
                */
                this._pt4 = new Kiwi.Geom.Point(0, 0);
                if (this.game.renderOption === Kiwi.RENDERER_WEBGL) {
                    this.glRenderer = this.game.renderer.requestSharedRenderer("TextureAtlasRenderer");
                }
                this._text = text;
                this._fontWeight = weight;
                this._fontSize = size;
                this._fontColor = new Kiwi.Utils.Color(color);
                this._fontFamily = fontFamily;
                this._textAlign = "left";
                this._baseline = "top";
                this._tempDirty = true;
                // Create the canvas
                this._canvas = document.createElement("canvas");
                this._canvas.width = 2;
                this._canvas.height = 2;
                this._ctx = this._canvas.getContext("2d");
                // Add it to the TextureLibrary
                this.atlas = new Kiwi.Textures.SingleImage(this.game.rnd.uuid(), this._canvas);
                this.state.textureLibrary.add(this.atlas);
                this.atlas.dirty = true;
                // Track actual text width - not canvas width (which rounds up to powers of 2), necessary for proper alignment
                this._alignWidth = 0;
                // Setup components
                this.box = this.components.add(new Kiwi.Components.Box(this, x, y, this.width, this.height));
            }
            /**
            * Returns the type of object that this is.
            *
            * Note: This is not camel-cased because of an error in early development.
            * To preserve API compatibility, all 1.x.x releases retail this form.
            * This will be fixed in v2.
            * @method objType
            * @return {string} "Textfield"
            * @public
            */
            TextField.prototype.objType = function () {
                return "Textfield";
            };
            Object.defineProperty(TextField.prototype, "text", {
                get: function () {
                    return this._text;
                },
                /**
                * The text that you would like to appear in this textfield.
                * @property text
                * @type string
                * @public
                */
                set: function (value) {
                    this._text = value;
                    this._tempDirty = true;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextField.prototype, "color", {
                get: function () {
                    return "#" + this._fontColor.getHex();
                },
                /**
                * The color of the font that is contained in this textfield.
                * May be set with a string, or an array of any valid
                * Kiwi.Utils.Color arguments.
                * Returns a hex string prepended with "#".
                * @property color
                * @type string
                * @public
                */
                set: function (val) {
                    if (!Kiwi.Utils.Common.isArray(val)) {
                        val = [val];
                    }
                    this._fontColor.set.apply(this._fontColor, val);
                    this._tempDirty = true;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextField.prototype, "fontWeight", {
                get: function () {
                    return this._fontWeight;
                },
                /**
                * The weight of the font.
                * @property fontWeight
                * @type string
                * @public
                */
                set: function (val) {
                    this._fontWeight = val;
                    this._tempDirty = true;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextField.prototype, "fontSize", {
                get: function () {
                    return this._fontSize;
                },
                /**
                * The size on font when being displayed onscreen.
                * @property fontSize
                * @type number
                * @public
                */
                set: function (val) {
                    this._fontSize = val;
                    this._tempDirty = true;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextField.prototype, "fontFamily", {
                get: function () {
                    return this._fontFamily;
                },
                /**
                * The font family that is being used to render the text.
                * @property fontFamily
                * @type string
                * @public
                */
                set: function (val) {
                    this._fontFamily = val;
                    this._tempDirty = true;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextField.prototype, "textAlign", {
                get: function () {
                    return this._textAlign;
                },
                /**
                * Alignment of the text. You can either use the static TEXT_ALIGN constants or pass a string.
                * @property textAlign
                * @type string
                * @public
                */
                set: function (val) {
                    this._textAlign = val;
                    this._tempDirty = true;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * This method is used to render the text to an offscreen-canvas which is held in a TextureAtlas (which is generated upon the instanitation of this class).
            * This is so that the canvas doesn't render it every frame as it can be costly and so that it can be used in WebGL with the TextureAtlasRenderer.
            *
            * @method _renderText
            * @private
            */
            TextField.prototype._renderText = function () {
                //Get/Set the width
                this._ctx.font = this._fontWeight + " " + this._fontSize + "px " + this._fontFamily;
                // Get the size of the text.
                var _measurements = this._ctx.measureText(this._text); //when you measure the text for some reason it resets the values?! 
                var width = _measurements.width;
                var height = this._fontSize * 1.3; //Need to find a better way to calculate
                // Cache alignment width
                this._alignWidth = width;
                // Is the width base2?
                if (Kiwi.Utils.Common.base2Sizes.indexOf(width) == -1) {
                    var i = 0;
                    while (width > Kiwi.Utils.Common.base2Sizes[i])
                        i++;
                    width = Kiwi.Utils.Common.base2Sizes[i];
                }
                // Is the height base2?
                if (Kiwi.Utils.Common.base2Sizes.indexOf(height) == -1) {
                    var i = 0;
                    while (height > Kiwi.Utils.Common.base2Sizes[i])
                        i++;
                    height = Kiwi.Utils.Common.base2Sizes[i];
                }
                // Apply the width/height
                this._canvas.width = width;
                this._canvas.height = height;
                // Clear the canvas
                this._ctx.clearRect(0, 0, width, height);
                // Reapply the styles....cause it unapplies after a measurement...?!?
                this._ctx.font = this._fontWeight + " " + this._fontSize + "px " + this._fontFamily;
                this._ctx.fillStyle = this.color.slice(0, 7);
                this._ctx.textBaseline = this._baseline;
                // Draw the text.
                this._ctx.fillText(this._text, 0, 0);
                // Update inherited properties
                this.width = this._alignWidth;
                this.height = this._canvas.height;
                //Update the cell and dirty/undirtyfiy
                this.atlas.cells[0] = {
                    x: 0,
                    y: 0,
                    w: this._canvas.width,
                    h: this._canvas.height,
                    hitboxes: [{
                            x: this._textAlign === Kiwi.GameObjects.TextField.TEXT_ALIGN_LEFT ? 0 :
                                this._textAlign === Kiwi.GameObjects.TextField.TEXT_ALIGN_CENTER ?
                                    -this._alignWidth * 0.5 : -this._alignWidth,
                            y: 0,
                            w: this.width,
                            h: this.height
                        }] };
                this._tempDirty = false;
                this.atlas.dirty = true;
            };
            /**
            * Called by the Layer to which this Game Object is attached
            * @method render
            * @param {Kiwi.Camera}
            * @public
            */
            TextField.prototype.render = function (camera) {
                if (this.alpha > 0 && this.visible) {
                    //render on stage
                    var ctx = this.game.stage.ctx;
                    ctx.save();
                    var t = this.transform;
                    if (this.alpha > 0 && this.alpha <= 1) {
                        ctx.globalAlpha = this.alpha;
                    }
                    //Does the text need re-rendering
                    if (this._tempDirty)
                        this._renderText();
                    //Align the text
                    var x = 0;
                    switch (this._textAlign) {
                        case Kiwi.GameObjects.TextField.TEXT_ALIGN_LEFT:
                            x = 0;
                            break;
                        case Kiwi.GameObjects.TextField.TEXT_ALIGN_CENTER:
                            x = this._alignWidth * 0.5;
                            break;
                        case Kiwi.GameObjects.TextField.TEXT_ALIGN_RIGHT:
                            x = this._alignWidth;
                            break;
                    }
                    //Draw the Image
                    var m = t.getConcatenatedMatrix();
                    ctx.transform(m.a, m.b, m.c, m.d, m.tx, m.ty);
                    ctx.drawImage(this._canvas, 0, 0, this._canvas.width, this._canvas.height, -t.rotPointX - x, -t.rotPointY, this._canvas.width, this._canvas.height);
                    ctx.restore();
                }
            };
            /**
            * Renders the GameObject using WebGL.
            * @method renderGL
            * @param {WebGLRenderingContext} gl
            * @param {Kiwi.Camera} camera
            * @param {Object} params
            * @public
            */
            TextField.prototype.renderGL = function (gl, camera, params) {
                if (params === void 0) { params = null; }
                //Does the text need re-rendering
                if (this._tempDirty)
                    this._renderText();
                //Set-up the xyuv and alpha
                var vertexItems = [];
                //Transform/Matrix
                var t = this.transform;
                var m = t.getConcatenatedMatrix();
                //See where the text should be.
                var x = 0;
                switch (this._textAlign) {
                    case Kiwi.GameObjects.TextField.TEXT_ALIGN_LEFT:
                        x = 0;
                        break;
                    case Kiwi.GameObjects.TextField.TEXT_ALIGN_CENTER:
                        x = -(this._alignWidth * 0.5);
                        break;
                    case Kiwi.GameObjects.TextField.TEXT_ALIGN_RIGHT:
                        x = -(this._alignWidth);
                        break;
                }
                //Create the Point Objects.
                this._pt1.setTo(x - t.rotPointX, 0 - t.rotPointY);
                this._pt2.setTo(this._canvas.width + x - t.rotPointX, 0 - t.rotPointY);
                this._pt3.setTo(this._canvas.width + x - t.rotPointX, this._canvas.height - t.rotPointY);
                this._pt4.setTo(x - t.rotPointX, this._canvas.height - t.rotPointY);
                //Add on the matrix to the points
                m.transformPoint(this._pt1);
                m.transformPoint(this._pt2);
                m.transformPoint(this._pt3);
                m.transformPoint(this._pt4);
                //Append to the xyuv and alpha arrays 
                vertexItems.push(this._pt1.x, this._pt1.y, 0, 0, this.alpha, 
                //Top Left Point
                this._pt2.x, this._pt2.y, this._canvas.width, 0, this.alpha, 
                //Top Right Point
                this._pt3.x, this._pt3.y, this._canvas.width, this._canvas.height, this.alpha, //Bottom Right Point
                this._pt4.x, this._pt4.y, 0, this._canvas.height, this.alpha);
                //Add to the batch!
                this.glRenderer.concatBatch(vertexItems);
            };
            /**
            * A static property that contains the string to center align the text.
            * @property TEXT_ALIGN_CENTER
            * @type string
            * @static
            * @final
            * @public
            */
            TextField.TEXT_ALIGN_CENTER = "center";
            /**
            * A static property that contains the string to right align the text.
            * @property TEXT_ALIGN_RIGHT
            * @type string
            * @static
            * @final
            * @public
            */
            TextField.TEXT_ALIGN_RIGHT = "right";
            /**
            * A static property that contains the string to left align the text.
            * @property TEXT_ALIGN_LEFT
            * @type string
            * @static
            * @final
            * @public
            */
            TextField.TEXT_ALIGN_LEFT = "left";
            return TextField;
        })(Kiwi.Entity);
        GameObjects.TextField = TextField;
        // Alias and reiteration for YuiDoc purposes
        GameObjects.Textfield = Kiwi.GameObjects.TextField;
    })(GameObjects = Kiwi.GameObjects || (Kiwi.GameObjects = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module GameObjects
* @submodule Tilemap
*
*/
var Kiwi;
(function (Kiwi) {
    var GameObjects;
    (function (GameObjects) {
        var Tilemap;
        (function (Tilemap) {
            /**
            * Define's the properties of a single Type of Tile for a TileMap. This class should not be directly instanted,
            * but instead when wanting to create new TileType's you should use the 'createdTileType' methods on a TileMap object.
            *
            * @class TileType
            * @namespace Kiwi.GameObjects.Tilemap
            * @constructor
            * @param tilemap {Kiwi.GameObjects.Tilemap.TileMap} The TileMap that this TileType is a part of.
            * @param index {Number} The index of this TileType, which Tiles use when wanting to use this TileType.
            * @param cellIndex {Number} The cell number to use when rendering this Type of Tile.
            * @return {TileType} This TileType
            * @public
            */
            var TileType = (function () {
                function TileType(tilemap, index, cellIndex) {
                    if (cellIndex === void 0) { cellIndex = -1; }
                    /**
                    * The collision information for this type of tile.
                    * It's values are the same as the Static properties inside of the ArcadePhysics Component.
                    * @property allowCollisions
                    * @type number
                    * @default NONE
                    * @public
                    */
                    this.allowCollisions = Kiwi.Components.ArcadePhysics.NONE;
                    /**
                    * The properties associated with this type of tile.
                    * These are set when loading a JSON file that had properties associated with a TileType.
                    * @property properties
                    * @type Object
                    * @public
                    */
                    this.properties = {};
                    this.tilemap = tilemap;
                    this.index = index;
                    this.cellIndex = cellIndex;
                    this.offset = new Kiwi.Geom.Point(0, 0);
                }
                /**
                * The type of object that it is.
                * @method objType
                * @return {String} "TileType"
                * @public
                */
                TileType.prototype.objType = function () {
                    return "TileType";
                };
                return TileType;
            })();
            Tilemap.TileType = TileType;
        })(Tilemap = GameObjects.Tilemap || (GameObjects.Tilemap = {}));
    })(GameObjects = Kiwi.GameObjects || (Kiwi.GameObjects = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module GameObjects
* @submodule Tilemap
* @main Tilemap
*/
var Kiwi;
(function (Kiwi) {
    var GameObjects;
    (function (GameObjects) {
        var Tilemap;
        (function (Tilemap) {
            /**
            * A TileMap handles the creation of TileMapLayers and the TileTypes that they use.
            * Since a TileMap isn't a Entity itself you cannot add it to the Stage inorder to render that it manages,
            * Instead you have to add each layer lies within it. This way you can have other GameObjects behind/in-front of layers.
            *
            * @class TileMap
            * @namespace Kiwi.GameObjects.Tilemap
            * @constructor
            * @param state {Kiwi.State} The state that this Tilemap is on.
            * @param [tileMapDataKey] {String} The Data key for the JSON you would like to use.
            * @param [atlas] {Kiwi.Textures.TextureAtlas} The texture atlas that you would like the tilemap layers to use.
            * @param [startingCell=0] {number} The number for the initial cell that the first TileType should use. See 'createFromFileStore' for more information.
            * @return {TileMap}
            */
            var TileMap = (function () {
                function TileMap(state, tileMapData, atlas, startingCell) {
                    if (startingCell === void 0) { startingCell = 0; }
                    /**
                    * The default width of a single tile that a TileMapLayer is told to have upon its creation.
                    * @property tileWidth
                    * @type Number
                    * @default 0
                    * @public
                    */
                    this.tileWidth = 0;
                    /**
                    * The default height of a single tile that a TileMapLayer is told to have upon its creation.
                    * @property tileHeight
                    * @type Number
                    * @default 0
                    * @public
                    */
                    this.tileHeight = 0;
                    /**
                    * The default width of all TileMapLayers when they are created.
                    * This value is in Tiles.
                    * @property width
                    * @type Number
                    * @default 0
                    * @public
                    */
                    this.width = 0;
                    /**
                    * The default height of all TileMapLayers when they are created.
                    * This value is in Tiles.
                    * @property height
                    * @type Number
                    * @default 0
                    * @public
                    */
                    this.height = 0;
                    /**
                    * Any properties that were found in the JSON during creation.
                    * @property properties
                    * @type Object
                    * @public
                    */
                    this.properties = {};
                    this.tileTypes = [];
                    this.createTileType(-1);
                    this.layers = [];
                    this.state = state;
                    this.game = state.game;
                    if (tileMapData !== undefined && atlas !== undefined) {
                        this.createFromFileStore(tileMapData, atlas, startingCell);
                    }
                    else if (tileMapData !== undefined || atlas !== undefined) {
                        Kiwi.Log.warn('You must pass BOTH the TileMapDataKey and TextureAtlas inorder to create a TileMap from the File Store.', '#tilemap');
                    }
                }
                Object.defineProperty(TileMap.prototype, "widthInPixels", {
                    /**
                    * The width of the tilemap in pixels. This value is READ ONLY.
                    * @property widthInPixels
                    * @type Number
                    * @public
                    */
                    get: function () {
                        return this.width * this.tileWidth;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TileMap.prototype, "heightInPixels", {
                    /**
                    * The height of the tilemap in pixels. This value is READ ONLY.
                    * @property heightInPixels
                    * @type Number
                    * @public
                    */
                    get: function () {
                        return this.height * this.tileHeight;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                * Creates new tilemap layers from a JSON file that you pass (has to be in the Tiled Format).
                * The texture atlas you pass is that one that each TileMapLayer found in the JSON will use, You can change the TextureAtlas afterwards.
                * New TileTypes will automatically be created. The number is based on the Tileset parameter of the JSON.
                * The cell used for new TileTypes will begin at 0 and increment each time a new TileType is created (and a cell exists). Otherwise new TileTypes will start will a cell of -1 (none).
                * @method createFromFileStore
                * @param tileMapData {Any} This can either
                * @param atlas {Kiwi.Textures.TextureAtlas} The texture atlas that you would like the tilemap layers to use.
                * @param [startingCell=0] {number} The number for the initial cell that the first TileType should use. If you pass -1 then no new TileTypes will be created.
                * @public
                */
                TileMap.prototype.createFromFileStore = function (tileMapData, atlas, startingCell) {
                    if (startingCell === void 0) { startingCell = 0; }
                    var json = null;
                    if (Kiwi.Utils.Common.isString(atlas)) {
                        atlas = this.state.textures[atlas];
                    }
                    //Does the JSON exist?
                    switch (typeof tileMapData) {
                        case 'string':
                            if (this.game.fileStore.exists(tileMapData) == false) {
                                Kiwi.Log.error('The JSON file you have told to use for a TileMap does not exist.', '#tilemap', '#json');
                                return false;
                            }
                            json = JSON.parse(this.game.fileStore.getFile(tileMapData).data);
                            break;
                        case 'object':
                            //Is it a KiwiJS file?
                            if (tileMapData.isData && tileMapData.dataType === Kiwi.Files.File.JSON) {
                                if (Kiwi.Utils.Common.isString(tileMapData.parse)) {
                                    json = JSON.parse(tileMapData.data);
                                }
                                else {
                                    json = tileMapData.data;
                                }
                            }
                            else {
                                json = tileMapData;
                            }
                            break;
                        default:
                            Kiwi.Log.error('The type of TileMapData passed could not be idenified. Please either pass a name of JSON file to use OR an object to be used.', '#tilemap');
                    }
                    //Get the map information
                    this.orientation = (json.orientation == undefined) ? Tilemap.ORTHOGONAL : json.orientation;
                    this.tileWidth = (json.tilewidth == undefined) ? 32 : json.tilewidth;
                    this.tileHeight = (json.tileheight == undefined) ? 32 : json.tileheight;
                    this.width = json.width;
                    this.height = json.height;
                    //Add the properties
                    for (var prop in json.properties) {
                        this.properties[prop] = json.properties[prop];
                    }
                    //Generate the Tiles needed.
                    if (json.tilesets !== "undefined" && startingCell !== -1)
                        this._generateTypesFromTileset(json.tilesets, atlas, startingCell);
                    //Generate the layers we need
                    for (var i = 0; i < json.layers.length; i++) {
                        var layerData = json.layers[i];
                        //Check what type it is.
                        switch (json.layers[i].type) {
                            case "tilelayer":
                                var w = (layerData.width !== undefined) ? layerData.width : this.width;
                                var h = (layerData.height !== undefined) ? layerData.height : this.height;
                                var layer = this.createNewLayer(layerData.name, atlas, layerData.data, w, h, layerData.x * this.tileWidth, layerData.y * this.tileHeight);
                                //Add the extra data...
                                layer.visible = (layerData.visible == undefined) ? true : layerData.visible;
                                layer.alpha = (layerData.opacity == undefined) ? 1 : layerData.opacity;
                                if (layerData.properties !== undefined)
                                    layer.properties = layerData.properties;
                                break;
                            case "objectgroup":
                                this.createNewObjectLayer();
                                break;
                            case "imagelayer":
                                this.createNewImageLayer();
                                break;
                        }
                    }
                };
                /**
                * Generates new TileTypes based upon the Tileset information that lies inside the Tiled JSON.
                * This is an INTERNAL method, which is used when the createFromFileStore method is executed.
                * @method _generateTypesFromTileset
                * @param tilesetData {Array} The tileset part of the JSON.
                * @param atlas {Kiwi.Textures.TextureAtlas} The Texture atlas which contains the cells that the new TileTypes will use.
                * @param startingCell {Number} The first cell number that would be used.
                * @private
                */
                TileMap.prototype._generateTypesFromTileset = function (tilesetData, atlas, startingCell) {
                    //Loop through the tilesets
                    for (var i = 0; i < tilesetData.length; i++) {
                        var tileset = tilesetData[i];
                        //Tileset Information
                        var m = tileset.margin;
                        var s = tileset.spacing;
                        var tw = tileset.tilewidth;
                        var th = tileset.tileheight;
                        var iw = tileset.imagewidth - m;
                        var ih = tileset.imageheight - m;
                        //Drawing offsets
                        var offset = (tileset.tileoffset == undefined) ? { x: 0, y: 0 } : tileset.tileoffset;
                        //Calculate how many tiles there are in this tileset and thus how many different tile type there can be.
                        for (var y = m; y < ih; y += th) {
                            for (var x = m; x < iw; x += tw) {
                                //Does the cell exist? Then use that.
                                var cell = (atlas.cells[startingCell] == undefined) ? -1 : startingCell;
                                var tileType = this.createTileType(cell);
                                tileType.offset.x = offset.x;
                                tileType.offset.y = offset.y;
                                startingCell++; //Increase the cell to use by one.
                            }
                        }
                        //Add tile properties
                        for (var tp in tileset.tileproperties) {
                            var tileType = this.tileTypes[(parseInt(tileset.firstgid) + parseInt(tp))];
                            tileType.properties = tileset.tileproperties[tp];
                        }
                    }
                };
                /**
                * Method to set the default TileMap properties. Useful when wanting to create tilemaps programmatically.
                * @method setTo
                * @param tileWidth {Number} The width of a single tile.
                * @param tileHeight {Number} The height of a single tile.
                * @param width {Number} The width of the whole map.
                * @param height {Number} The height of the whole map.
                * @public
                */
                TileMap.prototype.setTo = function (tileWidth, tileHeight, width, height) {
                    this.tileWidth = tileWidth;
                    this.tileHeight = tileHeight;
                    this.width = width;
                    this.height = height;
                };
                /**
                *-----------------------
                * Creation of Tile Types
                *-----------------------
                **/
                /**
                * Generates a single new TileType. Returns the TileType that was generated.
                * @method createTileType
                * @param [cell=-1] {Number} The cell that is to be used. Default is -1 (which means none)
                * @return {TileType} The TileType generated.
                * @public
                */
                TileMap.prototype.createTileType = function (cell) {
                    if (cell === void 0) { cell = -1; }
                    var tileType = new Tilemap.TileType(this, this.tileTypes.length, cell);
                    this.tileTypes.push(tileType);
                    return tileType;
                };
                /**
                * Creates a new TileType for each cell that you pass.
                * @method createTileTypes
                * @param cells {Number[]} The cells that you want a new TileType created for.
                * @return {TileTypes[]} The TileTypes generated.
                * @public
                */
                TileMap.prototype.createTileTypes = function (cells) {
                    var types = [];
                    for (var i = 0; i < cells.length; i++) {
                        types.push(this.createTileType(cells[i]));
                    }
                    return types;
                };
                /**
                * Used to create a number of TileTypes based starting cell number and how many you want from there.
                * @method createTileTypesByRange
                * @param cellStart {Number} The starting number of the cell.
                * @param range {Number} How many cells (from the starting cell) should be created.
                * @return {TileTypes[]} The TileTypes generated.
                */
                TileMap.prototype.createTileTypesByRange = function (cellStart, range) {
                    var types = [];
                    for (var i = cellStart; i <= cellStart + range; i++) {
                        types.push(this.createTileType(i));
                    }
                    return types;
                };
                /**
                *-----------------------
                * Cell Modifications
                *-----------------------
                **/
                /**
                * Changes a single cellIndex that a TileType is to use when it is rendered.
                * @method setCell
                * @param type {number} The number of the TileType that is to change.
                * @param cell {number} The new cellIndex it should have.
                * @public
                */
                TileMap.prototype.setCell = function (type, cell) {
                    this.tileTypes[type].cellIndex = cell;
                };
                /**
                * Changes a range of cellIndexs for Tiles the same range of TileTypes.
                * @method setCellsByRange
                * @param typeStart {number} The starting TileType that is to be modified.
                * @param cellStart {number} The starting cellIndex that the first TileType should have.
                * @param range {number} How many times it should run.
                * @public
                */
                TileMap.prototype.setCellsByRange = function (typeStart, cellStart, range) {
                    for (var i = typeStart; i < typeStart + range; i++) {
                        this.tileTypes[i].cellIndex = cellStart;
                        cellStart++;
                    }
                };
                /**
                *-----------------------
                * Creation of Tilemap Layers
                *-----------------------
                **/
                /**
                * Creates a new TileMapLayer with the details that are provided.
                * If no width/height/tileWidth/tileHeight parameters are passed then the values will be what this TileMap has.
                * If no 'data' is provided then the map will be automatically filled with empty Types of Tiles.
                * Returns the new TileMapLayer that was created.
                * @method createNewLayer
                * @param name {String} Name of the TileMap.
                * @param atlas {Kiwi.Textures.TextureAtlas} The TextureAtlas that this layer should use.
                * @param data {Number[]} The tile information.
                * @param [w=this.width] {Number} The width of the whole tile map. In Tiles.
                * @param [h=this.height] {Number} The height of the whole tile map. In Tiles.
                * @param [x=0] {Number} The position of the tilemap on the x axis. In pixels.
                * @param [y=0] {Number} The position of the tilemap on the y axis. In pixels.
                * @param [tw=this.tileWidth] {Number} The width of a single tile.
                * @param [th=this.tileHeight] {Number} The height of a single tile.
                * @param [orientation] {String} The orientation of the tilemap. Defaults to the same as this TileMap.
                * @return {TileMapLayer} The TileMapLayer that was created.
                * @public
                */
                TileMap.prototype.createNewLayer = function (name, atlas, data, w, h, x, y, tw, th, orientation) {
                    if (data === void 0) { data = []; }
                    if (w === void 0) { w = this.width; }
                    if (h === void 0) { h = this.height; }
                    if (x === void 0) { x = 0; }
                    if (y === void 0) { y = 0; }
                    if (tw === void 0) { tw = this.tileWidth; }
                    if (th === void 0) { th = this.tileHeight; }
                    if (orientation === void 0) { orientation = this.orientation; }
                    //Did the user provide enough data?
                    if (data.length < w * h) {
                        //No... So push empty cells instead
                        var i = data.length - 1;
                        while (++i < w * h) {
                            data.push(0);
                        }
                    }
                    //Create the new layer
                    var layer;
                    if (orientation == Tilemap.ISOMETRIC) {
                        layer = new Kiwi.GameObjects.Tilemap.TileMapLayerIsometric(this, name, atlas, data, tw, th, x, y, w, h);
                    }
                    else {
                        layer = new Kiwi.GameObjects.Tilemap.TileMapLayerOrthogonal(this, name, atlas, data, tw, th, x, y, w, h);
                    }
                    //Add the new layer to the array
                    this.layers.push(layer);
                    return layer;
                };
                /**
                * Eventually will create a new object layer. Currently does nothing.
                * @method createNewObjectLayer
                * @public
                */
                TileMap.prototype.createNewObjectLayer = function () {
                    Kiwi.Log.log("OBJECT GROUP layers are currently not supported.", '#tilemap');
                };
                /**
                * Eventually will create a new image layer. Currently does nothing.
                * @method createNewObjectLayer
                * @public
                */
                TileMap.prototype.createNewImageLayer = function () {
                    Kiwi.Log.log("IMAGE layers are currently not supported.", '#tilemap');
                };
                /**
                *-----------------------
                * TileMapLayer Management Functions
                *-----------------------
                **/
                /**
                * Get a layer by the name that it was given upon creation.
                * Returns null if no layer with that name was found.
                * @method getLayerByName
                * @param name {String} Name of the layer you would like to select.
                * @return {TileMapLayer} Either the layer with the name passed, or null if no Layer with that name was found.
                * @public
                */
                TileMap.prototype.getLayerByName = function (name) {
                    for (var i = 0; i < this.layers.length; i++) {
                        if (this.layers[i].name == name) {
                            return this.layers[i];
                        }
                    }
                    return null;
                };
                /**
                * Returns the layer with the number associated with it in the layers array.
                * @method getLayer
                * @param num {Number} Number of the Layer you would like to get.
                * @return {TileMapLayer}
                * @public
                */
                TileMap.prototype.getLayer = function (num) {
                    return (this.layers[num] !== undefined) ? this.layers[num] : null;
                };
                /**
                * The type of object that it is.
                * @method objType
                * @return {String} "TileMap"
                * @public
                */
                TileMap.prototype.objType = function () {
                    return "TileMap";
                };
                return TileMap;
            })();
            Tilemap.TileMap = TileMap;
            Tilemap.ISOMETRIC = "isometric";
            Tilemap.ORTHOGONAL = "orthogonal";
        })(Tilemap = GameObjects.Tilemap || (GameObjects.Tilemap = {}));
    })(GameObjects = Kiwi.GameObjects || (Kiwi.GameObjects = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module GameObjects
* @submodule Tilemap
*
*/
var Kiwi;
(function (Kiwi) {
    var GameObjects;
    (function (GameObjects) {
        var Tilemap;
        (function (Tilemap) {
            /**
            * GameObject containing the core functionality for every type of tilemap layer that can be generated.
            * This class should not be directly used. Classes extending this should be used instead.
            *
            * @class TileMapLayer
            * @extends Kiwi.Entity
            * @namespace Kiwi.GameObjects.Tilemap
            * @since 1.3.0
            * @constructor
            * @param tilemap {Kiwi.GameObjects.Tilemap.TileMap} The TileMap that this layer belongs to.
            * @param name {String} The name of this TileMapLayer.
            * @param atlas {Kiwi.Textures.TextureAtlas} The texture atlas that should be used when rendering this TileMapLayer onscreen.
            * @param data {Number[]} The information about the tiles.
            * @param tw {Number} The width of a single tile in pixels. Usually the same as the TileMap unless told otherwise.
            * @param th {Number} The height of a single tile in pixels. Usually the same as the TileMap unless told otherwise.
            * @param [x=0] {Number} The x coordinate of the tilemap in pixels.
            * @param [y=0] {Number} The y coordinate of the tilemap in pixels.
            * @param [w=0] {Number} The width of the whole tilemap in tiles. Usually the same as the TileMap unless told otherwise.
            * @param [h=0] {Number} The height of the whole tilemap in tiles. Usually the same as the TileMap unless told otherwise.
            * @return {TileMapLayer}
            */
            var TileMapLayer = (function (_super) {
                __extends(TileMapLayer, _super);
                function TileMapLayer(tilemap, name, atlas, data, tw, th, x, y, w, h) {
                    if (x === void 0) { x = 0; }
                    if (y === void 0) { y = 0; }
                    if (w === void 0) { w = 0; }
                    if (h === void 0) { h = 0; }
                    _super.call(this, tilemap.state, x, y);
                    /**
                    * Properties about that this TileMapLayer has when it was created from a JSON file.
                    * @property properties
                    * @type Object
                    * @public
                    */
                    this.properties = {};
                    /**
                    * The orientation of the of tilemap.
                    * TileMaps can be either 'orthogonal' (normal) or 'isometric'.
                    * @property orientation
                    * @type String
                    * @public
                    */
                    this.orientation = null;
                    //Request the Shared Texture Atlas renderer.
                    if (this.game.renderOption === Kiwi.RENDERER_WEBGL) {
                        this.glRenderer = this.game.renderer.requestSharedRenderer("TextureAtlasRenderer");
                    }
                    if (Kiwi.Utils.Common.isString(atlas)) {
                        atlas = this.state.textures[atlas];
                    }
                    this.name = name;
                    this.atlas = atlas;
                    this.tilemap = tilemap;
                    this._data = data;
                    this.tileWidth = tw;
                    this.tileHeight = th;
                    this.width = w;
                    this.height = h;
                    this._corner1 = new Kiwi.Geom.Point(0, 0);
                    this._corner2 = new Kiwi.Geom.Point(0, 0);
                    this._corner3 = new Kiwi.Geom.Point(0, 0);
                    this._corner4 = new Kiwi.Geom.Point(0, 0);
                    this.physics = this.components.add(new Kiwi.Components.ArcadePhysics(this, null));
                    this.physics.immovable = true;
                }
                /**
                * Returns the type of child that this is.
                * @type Number
                * @return {Number} returns the type of child that the entity is
                * @public
                */
                TileMapLayer.prototype.childType = function () {
                    return Kiwi.TILE_LAYER;
                };
                /**
                * The type of object that it is.
                * @method objType
                * @return {String} "TileMapLayer"
                * @public
                */
                TileMapLayer.prototype.objType = function () {
                    return "TileMapLayer";
                };
                Object.defineProperty(TileMapLayer.prototype, "widthInPixels", {
                    /**
                    * The width of the layer in pixels. This property is READ ONLY.
                    * @property widthInPixels
                    * @type number
                    * @public
                    */
                    get: function () {
                        return this.width * this.tilemap.tileWidth;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TileMapLayer.prototype, "heightInPixels", {
                    /**
                    * The height of the layer in pixels. This property is READ ONLY.
                    * @property heightInPixels
                    * @type number
                    * @public
                    */
                    get: function () {
                        return this.height * this.tilemap.tileHeight;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TileMapLayer.prototype, "cellIndex", {
                    /**
                    * Override function to prevent unwanted inherited behaviour. Do not call.
                    * Because TileMapLayer extends Entity, it has a cellIndex parameter.
                    * However, it does not use a single atlas index, so this parameter is meaningless. It has deliberately been set to do nothing.
                    *
                    * @property cellIndex
                    * @type number
                    * @public
                    * @deprecated Not functional on this object.
                    * @since 1.1.0
                    */
                    get: function () {
                        return null;
                    },
                    set: function (val) { },
                    enumerable: true,
                    configurable: true
                });
                /**
                * Scales the tilemap to the value passed.
                * @method scaleToWidth
                * @param value {Number}
                * @public
                */
                TileMapLayer.prototype.scaleToWidth = function (value) {
                    this.scale = value / this.widthInPixels;
                };
                /**
                * Scales the tilemaps to the value passed.
                * @method scaleToHeight
                * @param value {Number}
                * @public
                */
                TileMapLayer.prototype.scaleToHeight = function (value) {
                    this.scale = value / this.heightInPixels;
                };
                /**
                * Centers the anchor point to the middle of the width/height of the tilemap.
                * @method centerAnchorPoint
                * @public
                */
                TileMapLayer.prototype.centerAnchorPoint = function () {
                    this.anchorPointX = this.widthInPixels * 0.5;
                    this.anchorPointY = this.heightInPixels * 0.5;
                };
                Object.defineProperty(TileMapLayer.prototype, "data", {
                    /**
                    * READ ONLY: Returns the raw data for this tilemap.
                    * @property data
                    * @type Array
                    * @readOnly
                    * @public
                    * @since 1.3.0
                    */
                    get: function () {
                        return this._data;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TileMapLayer.prototype, "tileData", {
                    /**
                    * READ ONLY: A list containing all of the types of tiles found on this TileMapLayer.
                    * Same as the `data` property.
                    *
                    * @property tileData
                    * @type Array
                    * @readOnly
                    * @public
                    */
                    get: function () {
                        return this._data;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                * Returns the total number of tiles. Either for a particular type if passed, otherwise of any type if not passed.
                * @method countTiles
                * @param [type] {Number} The type of tile you want to count.
                * @return {Number} The number of tiles on this layer.
                * @public
                */
                TileMapLayer.prototype.countTiles = function (type) {
                    var cnt = 0;
                    for (var i = 0; i < this._data.length; i++) {
                        if (type == undefined && this._data[i] !== 0)
                            cnt++;
                        else if (type === this._data[i])
                            cnt++;
                    }
                    return cnt;
                };
                /**
                *-----------------------
                * Getting Tiles
                *-----------------------
                */
                /**
                * Returns the index of the tile based on the x and y coordinates of the tile passed.
                * If no tile is a the coordinates given then -1 is returned instead.
                * Coordinates are in tiles not pixels.
                * @method getIndexFromXY
                * @param x {Number} The x coordinate of the Tile you would like to retrieve.
                * @param y {Number} The y coordinate of the Tile you would like to retrieve.
                * @return {Number} Either the index of the tile retrieved or -1 if none was found.
                * @public
                */
                TileMapLayer.prototype.getIndexFromXY = function (x, y) {
                    var num = x + y * this.width;
                    //Does the index exist?
                    if (num < 0 || num >= this._data.length)
                        return -1;
                    else
                        return num;
                };
                /**
                * Returns the TileType for a tile that is at a particular set of coordinates passed.
                * If no tile is found the null is returned instead.
                * Coordinates passed are in tiles.
                * @method getTileFromXY
                * @param x {Number}
                * @param y {Number}
                * @return {Kiwi.GameObjects.Tilemap.TileType}
                * @public
                */
                TileMapLayer.prototype.getTileFromXY = function (x, y) {
                    var t = this.getIndexFromXY(x, y);
                    return (t !== -1) ? this.tilemap.tileTypes[this._data[t]] : null;
                };
                /**
                * Returns the indexes of every tile of a type you pass.
                * @method getIndexsByType
                * @param type {Number}
                * @return {Number[]}
                * @public
                */
                TileMapLayer.prototype.getIndexesByType = function (type) {
                    var tiles = [];
                    for (var i = 0; i < this._data.length; i++) {
                        if (this._data[i] == type)
                            tiles.push(i);
                    }
                    return tiles;
                };
                /**
                * Returns the TileType of a tile by an index passed.
                * Thanks to @rydairegames
                *
                * @method getTileFromIndex
                * @param index {Number}
                * @return {Kiwi.GameObjects.Tilemap.TileType}
                * @public
                */
                TileMapLayer.prototype.getTileFromIndex = function (index) {
                    return (index !== -1) ? this.tilemap.tileTypes[this._data[index]] : null;
                };
                /**
                * Returns the index of the tile based on the x and y pixel coordinates that are passed.
                * If no tile is a the coordinates given then -1 is returned instead.
                * Coordinates are in pixels not tiles and use the world coordinates of the tilemap.
                *
                * Functionality needs to be added by classes extending this class.
                *
                * @method getIndexFromCoords
                * @param x {Number} The x coordinate of the Tile you would like to retrieve.
                * @param y {Number} The y coordinate of the Tile you would like to retrieve.
                * @return {Number} Either the index of the tile retrieved or -1 if none was found.
                * @public
                */
                TileMapLayer.prototype.getIndexFromCoords = function (x, y) {
                    return -1;
                };
                /**
                * Returns the TileType for a tile that is at a particular coordinate passed.
                * If no tile is found then null is returned instead.
                * Coordinates passed are in pixels and use the world coordinates of the tilemap.
                *
                * @method getTileFromCoords
                * @param x {Number}
                * @param y {Number}
                * @return {Kiwi.GameObjects.Tilemap.TileType}
                * @public
                */
                TileMapLayer.prototype.getTileFromCoords = function (x, y) {
                    var t = this.getIndexFromCoords(x, y);
                    return (t !== -1) ? this.tilemap.tileTypes[this.data[t]] : null;
                };
                /**
                *-----------------------
                * Tiles Manipulation
                *-----------------------
                */
                /**
                * Sets the tile to be used at the coordinates provided.
                * Can be used to override a tile that may already exist at the location.
                * @method setTile
                * @param x {Number} The coordinate of the tile on the x axis.
                * @param y {Number} The coordinate of the tile on the y axis.
                * @param tileType {Number} The type of tile that should be now used.
                * @return {Boolean} If a tile was changed or not.
                * @public
                */
                TileMapLayer.prototype.setTile = function (x, y, tileType) {
                    var x = this.getIndexFromXY(x, y);
                    if (x !== -1) {
                        this._data[x] = tileType;
                        return true;
                    }
                    return false;
                };
                /**
                * Sets the tile to be used at the index provided.
                * Can be used to override a tile that may already exist at the location.
                * @method setTileByIndex
                * @param index {Number} The index of the tile that you want to change.
                * @param tileType {Number} The new tile type to be used at that position.
                * @public
                */
                TileMapLayer.prototype.setTileByIndex = function (index, tileType) {
                    this._data[index] = tileType;
                };
                /**
                * Randomizes the types of tiles used in an area of the layer. You can choose which types of tiles to use, and the area.
                * Default tile types used are everyone avaiable.
                * @method randomizeTiles
                * @param [types] {Number[]} A list of TileTypes that can be used. Default is every tiletype on the TileMap.
                * @param [x=0] {Number} The starting tile on the x axis to fill.
                * @param [y=0] {Number} The starting tile on the y axis to fill.
                * @param [width=this.width] {Number} How far across you want to go.
                * @param [height=this.height] {Number} How far down you want to go.
                * @public
                */
                TileMapLayer.prototype.randomizeTiles = function (types, x, y, width, height) {
                    if (x === void 0) { x = 0; }
                    if (y === void 0) { y = 0; }
                    if (width === void 0) { width = this.width; }
                    if (height === void 0) { height = this.height; }
                    if (types == undefined) {
                        types = [];
                        var i = 0;
                        while (i++ < this.tilemap.tileTypes.length) {
                            types.push(i);
                        }
                    }
                    for (var j = y; j < y + height; j++) {
                        for (var i = x; i < x + width; i++) {
                            var tile = this.getIndexFromXY(i, j);
                            if (tile !== -1)
                                this._data[tile] = this.game.rnd.pick(types);
                        }
                    }
                };
                /**
                * Makes all of the tiles in the area specified a single type that is passed.
                * @method fill
                * @param type {Number} The type of tile you want to fill in the area with.
                * @param [x=0] {Number} The starting tile on the x axis to fill.
                * @param [y=0] {Number} The starting tile on the y axis to fill.
                * @param [width=this.width] {Number} How far across you want to go.
                * @param [height=this.height] {Number} How far down you want to go.
                * @public
                */
                TileMapLayer.prototype.fill = function (type, x, y, width, height) {
                    if (x === void 0) { x = 0; }
                    if (y === void 0) { y = 0; }
                    if (width === void 0) { width = this.width; }
                    if (height === void 0) { height = this.height; }
                    for (var j = y; j < y + height; j++) {
                        for (var i = x; i < x + width; i++) {
                            var tile = this.getIndexFromXY(i, j);
                            if (tile !== -1)
                                this._data[tile] = type;
                        }
                    }
                };
                /**
                * Replaces all tiles of typeA to typeB in the area specified. If no area is specified then it is on the whole layer.
                * @method replaceTiles
                * @param typeA {Number} The type of tile you want to be replaced.
                * @param typeB {Number} The type of tile you want to be used instead.
                * @param [x=0] {Number} The starting tile on the x axis to fill.
                * @param [y=0] {Number} The starting tile on the y axis to fill.
                * @param [width=this.width] {Number} How far across you want to go.
                * @param [height=this.height] {Number} How far down you want to go.
                * @public
                */
                TileMapLayer.prototype.replaceTiles = function (typeA, typeB, x, y, width, height) {
                    if (x === void 0) { x = 0; }
                    if (y === void 0) { y = 0; }
                    if (width === void 0) { width = this.width; }
                    if (height === void 0) { height = this.height; }
                    for (var j = y; j < y + height; j++) {
                        for (var i = x; i < x + width; i++) {
                            var tile = this.getIndexFromXY(i, j);
                            if (tile !== -1 && this._data[tile] == typeA)
                                this._data[tile] = typeB;
                        }
                    }
                };
                /**
                * Swaps all the tiles that are typeA -> typeB and typeB -> typeA inside the area specified. If no area is specified then it is on the whole layer.
                * @method swapTiles
                * @param typeA {number} The type of tile you want to be replaced with typeB.
                * @param typeB {number} The type of tile you want to be replaced with typeA.
                * @param [x=0] {number} The starting tile on the x axis to fill.
                * @param [y=0] {number} The starting tile on the y axis to fill.
                * @param [width=this.width] {number} How far across you want to go.
                * @param [height=this.height] {number} How far down you want to go.
                * @public
                */
                TileMapLayer.prototype.swapTiles = function (typeA, typeB, x, y, width, height) {
                    if (x === void 0) { x = 0; }
                    if (y === void 0) { y = 0; }
                    if (width === void 0) { width = this.width; }
                    if (height === void 0) { height = this.height; }
                    for (var j = y; j < y + height; j++) {
                        for (var i = x; i < x + width; i++) {
                            var tile = this.getIndexFromXY(i, j);
                            if (tile !== -1) {
                                if (this._data[tile] == typeA)
                                    this._data[tile] = typeB;
                                else if (this._data[tile] == typeB)
                                    this._data[tile] = typeA;
                            }
                        }
                    }
                };
                /**
                *-----------------------
                * Get Tiles By Collision Methods
                *-----------------------
                */
                /**
                * Returns the tiles which overlap with a provided entities hitbox component.
                * Only collidable tiles on ANY side will be returned unless you pass a particular side.
                * Note: Classes extending this class need to
                *
                * @method getOverlappingTiles
                * @param entity {Kiwi.Entity} The entity you would like to check for the overlap.
                * @param [collisionType=ANY] {Number} The particular type of collidable tiles which you would like to check for.
                * @return {Object[]} Returns an Array of Objects containing information about the tiles which were found. Index/X/Y information is contained within each Object.
                * @public
                */
                TileMapLayer.prototype.getOverlappingTiles = function (entity, collisionType) {
                    if (collisionType === void 0) { collisionType = Kiwi.Components.ArcadePhysics.ANY; }
                    return [];
                };
                /**
                * Returns the tiles which can collide with other objects (on ANY side unless otherwise specified) within an area provided.
                * By default the area is the whole tilemap.
                *
                * @method getCollidableTiles
                * @param [x=0] {Number} The x coordinate of the first tile to check.
                * @param [y=0] {Number} The y coordinate of the first tile to check.
                * @param [width=widthOfMap] {Number} The width from the x coordinate.
                * @param [height=heightOfmap] {Number} The height from the y coordinate.
                * @param [collisionType=ANY] {Number} The type of collidable tiles that should be return. By default ANY type of collidable tiles will be returned.
                * @return {Object[]} Returns an Array of Objects containing information about the tiles which were found. Index/X/Y information is contained within each Object.
                * @public
                */
                TileMapLayer.prototype.getCollidableTiles = function (x, y, width, height, collisionType) {
                    if (x === void 0) { x = 0; }
                    if (y === void 0) { y = 0; }
                    if (width === void 0) { width = this.width; }
                    if (height === void 0) { height = this.height; }
                    if (collisionType === void 0) { collisionType = Kiwi.Components.ArcadePhysics.ANY; }
                    var tiles = [];
                    //Make sure its within the map.
                    if (x > this.width || y > this.height)
                        return;
                    if (x < 0)
                        x = 0;
                    if (y < 0)
                        y = 0;
                    if (x + width > this.width)
                        width = this.width - x;
                    if (y + height > this.height)
                        height = this.height - y;
                    //Loop through and of the tiles.
                    for (var j = y; j < y + height; j++) {
                        for (var i = x; i < x + width; i++) {
                            //Get the tile index.
                            var index = this.getIndexFromXY(i, j);
                            //Does that index exist? Should do but just in case.
                            if (index === -1)
                                continue;
                            var type = this.tileData[index];
                            //If the collision type matches the one passed. 
                            if ((this.tilemap.tileTypes[type].allowCollisions & collisionType) !== Kiwi.Components.ArcadePhysics.NONE) {
                                tiles.push({
                                    index: index,
                                    type: type,
                                    x: i * this.tileWidth,
                                    y: j * this.tileHeight
                                });
                            }
                        }
                    }
                    return tiles;
                };
                /**
                * The update loop that is executed when this TileMapLayer is add to the Stage.
                * @method update
                * @public
                */
                TileMapLayer.prototype.update = function () {
                    _super.prototype.update.call(this);
                };
                /**
                * Used to calculate the position of the tilemap on the stage as well as how many tiles can fit on the screen.
                * All coordinates calculated are stored as temporary properties (maxX/Y, startX/Y).
                *
                * @method _calculateBoundaries
                * @param camera {Camera}
                * @param matrix {Matrix}
                * @protected
                */
                TileMapLayer.prototype._calculateBoundaries = function (camera, matrix) {
                    this._startX = 0;
                    this._startY = 0;
                    this._maxX = this.width;
                    this._maxY = this.height;
                };
                /**
                * The render loop which is used when using the Canvas renderer.
                * @method render
                * @param camera {Camera}
                * @public
                */
                TileMapLayer.prototype.render = function (camera) {
                };
                TileMapLayer.prototype.renderGL = function (gl, camera, params) {
                    if (params === void 0) { params = null; }
                };
                /**
                * Deprecated on the TileMapLayer class since it is for 'Isometric' maps only.
                *
                * @method chartToScreen
                * @param chartPt {any} A Object containing x/y properties of the tile.
                * @param [tileW] {Number} The width of the tile
                * @param [tileH] {Number} The height of the tile
                * @return {Object} With x/y properties of the location of the map onscreen.
                * @deprecated
                * @since 1.3.0
                * @public
                */
                TileMapLayer.prototype.chartToScreen = function (chartPt, tileW, tileH) {
                    if (tileW === void 0) { tileW = this.tileWidth / 2; }
                    if (tileH === void 0) { tileH = this.tileHeight; }
                    return {
                        x: chartPt.x * tileW - chartPt.y * tileW,
                        y: chartPt.x * tileH / 2 + chartPt.y * tileH / 2
                    };
                };
                /**
                * Deprecated on the TileMapLayer class since it is for 'Isometric' maps only.
                *
                * @method screenToChart
                * @param scrPt {any} An object containing x/y coordinates of the point on the screen you want to convert to tile coordinates.
                * @param [tileW] {Number} The width of a single tile.
                * @param [tileH] {Number} The height of a single tile.
                * @return {Object} With x/y properties of the location of tile on the screen.
                * @deprecated
                * @since 1.3.0
                * @public
                */
                TileMapLayer.prototype.screenToChart = function (scrPt, tileW, tileH) {
                    if (tileW === void 0) { tileW = this.tileWidth / 2; }
                    if (tileH === void 0) { tileH = this.tileHeight; }
                    var column = Math.floor(scrPt.x / tileW);
                    var row = Math.floor((scrPt.y - column * (tileH / 2)) / tileH);
                    return { x: column + row, y: row };
                };
                return TileMapLayer;
            })(Kiwi.Entity);
            Tilemap.TileMapLayer = TileMapLayer;
        })(Tilemap = GameObjects.Tilemap || (GameObjects.Tilemap = {}));
    })(GameObjects = Kiwi.GameObjects || (Kiwi.GameObjects = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module GameObjects
* @submodule Tilemap
*
*/
var Kiwi;
(function (Kiwi) {
    var GameObjects;
    (function (GameObjects) {
        var Tilemap;
        (function (Tilemap) {
            /**
            * Contains the code for managing and rendering Orthogonal types of TileMaps.
            * This class should not be directly created, but instead should be created via methods on the TileMap class.
            *
            * @class TileMapLayerOrthogonal
            * @extends Kiwi.GameObjects.Tilemap.TileMapLayer
            * @namespace Kiwi.GameObjects.Tilemap
            * @since 1.3.0
            * @constructor
            * @param tilemap {Kiwi.GameObjects.Tilemap.TileMap} The TileMap that this layer belongs to.
            * @param name {String} The name of this TileMapLayer.
            * @param atlas {Kiwi.Textures.TextureAtlas} The texture atlas that should be used when rendering this TileMapLayer onscreen.
            * @param data {Number[]} The information about the tiles.
            * @param tw {Number} The width of a single tile in pixels. Usually the same as the TileMap unless told otherwise.
            * @param th {Number} The height of a single tile in pixels. Usually the same as the TileMap unless told otherwise.
            * @param [x=0] {Number} The x coordinate of the tilemap in pixels.
            * @param [y=0] {Number} The y coordinate of the tilemap in pixels.
            * @param [w=0] {Number} The width of the whole tilemap in tiles. Usually the same as the TileMap unless told otherwise.
            * @param [h=0] {Number} The height of the whole tilemap in tiles. Usually the same as the TileMap unless told otherwise.
            * @return {TileMapLayer}
            */
            var TileMapLayerOrthogonal = (function (_super) {
                __extends(TileMapLayerOrthogonal, _super);
                function TileMapLayerOrthogonal(tilemap, name, atlas, data, tw, th, x, y, w, h) {
                    if (x === void 0) { x = 0; }
                    if (y === void 0) { y = 0; }
                    if (w === void 0) { w = 0; }
                    if (h === void 0) { h = 0; }
                    _super.call(this, tilemap, name, atlas, data, tw, th, x, y, w, h);
                    /**
                    * The orientation of the of tilemap.
                    * TileMaps can be either 'orthogonal' (normal) or 'isometric'.
                    * @property orientation
                    * @type String
                    * @default 'orthogonal'
                    * @public
                    */
                    this.orientation = Tilemap.ORTHOGONAL;
                }
                /**
                * The type of object that it is.
                * @method objType
                * @return {String} "TileMapLayer"
                * @public
                */
                TileMapLayerOrthogonal.prototype.objType = function () {
                    return "TileMapLayer";
                };
                /**
                * Returns the index of the tile based on the x and y pixel coordinates that are passed.
                * If no tile is a the coordinates given then -1 is returned instead.
                * Coordinates are in pixels not tiles and use the world coordinates of the tilemap.
                *
                * @method getIndexFromCoords
                * @param x {Number} The x coordinate of the Tile you would like to retrieve.
                * @param y {Number} The y coordinate of the Tile you would like to retrieve.
                * @return {Number} Either the index of the tile retrieved or -1 if none was found.
                * @public
                */
                TileMapLayerOrthogonal.prototype.getIndexFromCoords = function (x, y) {
                    //Not with the bounds?
                    if (x > this.transform.worldX + this.widthInPixels || y > this.transform.worldY + this.heightInPixels || x < this.transform.worldX || y < this.transform.worldY)
                        return -1;
                    //Is so get the tile
                    var tx = Kiwi.Utils.GameMath.snapToFloor(x - this.transform.worldX, this.tileWidth) / this.tileWidth;
                    var ty = Kiwi.Utils.GameMath.snapToFloor(y - this.transform.worldY, this.tileHeight) / this.tileHeight;
                    return this.getIndexFromXY(tx, ty);
                };
                /**
                * Returns the tiles which overlap with a provided entities hitbox component.
                * Only collidable tiles on ANY side will be returned unless you pass a particular side.
                *
                * @method getOverlappingTiles
                * @param entity {Kiwi.Entity} The entity you would like to check for the overlap.
                * @param [collisionType=ANY] {Number} The particular type of collidable tiles which you would like to check for.
                * @return {Object[]} Returns an Array of Objects containing information about the tiles which were found. Index/X/Y information is contained within each Object.
                * @public
                */
                TileMapLayerOrthogonal.prototype.getOverlappingTiles = function (entity, collisionType) {
                    if (collisionType === void 0) { collisionType = Kiwi.Components.ArcadePhysics.ANY; }
                    //Do they have a box?
                    if (entity.components.hasComponent("Box") == false)
                        return [];
                    //Get the box off them
                    var b = entity.components.getComponent('Box').worldHitbox;
                    var worldX = this.transform.worldX;
                    var worldY = this.transform.worldY;
                    //Is the person within the map's bounds?    
                    if (b.left > worldX + this.widthInPixels || b.right < worldX || b.bottom < worldY || b.top > worldY + this.heightInPixels)
                        return [];
                    var nx = b.x - worldX;
                    var ny = b.y - worldY;
                    //Get starting location and now many tiles from there we will check. 
                    var x = Kiwi.Utils.GameMath.snapToFloor(nx, this.tileWidth) / this.tileWidth;
                    var y = Kiwi.Utils.GameMath.snapToFloor(ny, this.tileHeight) / this.tileHeight;
                    var w = Kiwi.Utils.GameMath.snapToCeil(b.width, this.tileWidth) / this.tileWidth;
                    var h = Kiwi.Utils.GameMath.snapToCeil(b.height, this.tileHeight) / this.tileHeight;
                    //Add one, because we want to include the very end tile.
                    var tiles = this.getCollidableTiles(x, y, w + 1, h + 1, collisionType);
                    //Loop through the tiles and make sure they are actually overlapping with the Entity.
                    for (var i = 0; i < tiles.length; i++) {
                        var t = tiles[i];
                        if (t.x + worldX > b.right || t.x + this.tileWidth + worldX < b.left || t.y + worldY > b.bottom || t.y + this.tileHeight + worldY < b.top) {
                            tiles.splice(i, 1);
                            i--;
                        }
                    }
                    return tiles;
                };
                /**
                * Used to calculate the position of the tilemap on the stage as well as how many tiles can fit on the screen.
                * All coordinates calculated are stored as temporary properties (maxX/Y, startX/Y).
                *
                * @method _calculateBoundaries
                * @param camera {Camera}
                * @param matrix {Matrix}
                * @protected
                */
                TileMapLayerOrthogonal.prototype._calculateBoundaries = function (camera, matrix) {
                    //If we are calculating the coordinates for 'regular' then we can do that rather easy
                    // Account for camera and object transformation
                    // Initialise corners...
                    this._corner1.setTo(0, 0);
                    this._corner2.setTo(this.game.stage.width, 0);
                    this._corner3.setTo(this.game.stage.width, this.game.stage.height);
                    this._corner4.setTo(0, this.game.stage.height);
                    // Transform corners by camera...
                    this._corner1 = camera.transformPoint(this._corner1);
                    this._corner2 = camera.transformPoint(this._corner2);
                    this._corner3 = camera.transformPoint(this._corner3);
                    this._corner4 = camera.transformPoint(this._corner4);
                    // Transform corners by object...
                    var m = matrix.clone();
                    m.invert();
                    this._corner1 = m.transformPoint(this._corner1);
                    this._corner2 = m.transformPoint(this._corner2);
                    this._corner3 = m.transformPoint(this._corner3);
                    this._corner4 = m.transformPoint(this._corner4);
                    // Find min/max values in X and Y...
                    this._startX = Math.min(this._corner1.x, this._corner2.x, this._corner3.x, this._corner4.x);
                    this._startY = Math.min(this._corner1.y, this._corner2.y, this._corner3.y, this._corner4.y);
                    this._maxX = Math.max(this._corner1.x, this._corner2.x, this._corner3.x, this._corner4.x);
                    this._maxY = Math.max(this._corner1.y, this._corner2.y, this._corner3.y, this._corner4.y);
                    // Convert to tile units...
                    this._startX /= this.tileWidth;
                    this._startY /= this.tileHeight;
                    this._maxX /= this.tileWidth;
                    this._maxY /= this.tileHeight;
                    // Truncate units...
                    this._startX = Math.floor(this._startX);
                    this._startY = Math.floor(this._startY);
                    this._maxX = Math.ceil(this._maxX);
                    this._maxY = Math.ceil(this._maxY);
                    // Clamp values to tilemap range...
                    this._startX = Kiwi.Utils.GameMath.clamp(this._startX, this.width);
                    this._startY = Kiwi.Utils.GameMath.clamp(this._startY, this.height);
                    this._maxX = Kiwi.Utils.GameMath.clamp(this._maxX, this.width);
                    this._maxY = Kiwi.Utils.GameMath.clamp(this._maxY, this.height);
                };
                /**
                * The render loop which is used when using the Canvas renderer.
                * @method render
                * @param camera {Camera}
                * @public
                */
                TileMapLayerOrthogonal.prototype.render = function (camera) {
                    //When not to render the map.
                    if (this.visible === false || this.alpha < 0.1 || this.exists === false) {
                        return;
                    }
                    //Get the context.
                    var ctx = this.game.stage.ctx;
                    ctx.save();
                    //Make the map alphed out.
                    if (this.alpha > 0 && this.alpha <= 1) {
                        ctx.globalAlpha = this.alpha;
                    }
                    // Transform
                    var t = this.transform;
                    var m = t.getConcatenatedMatrix();
                    ctx.transform(m.a, m.b, m.c, m.d, m.tx, m.ty);
                    this._calculateBoundaries(camera, m);
                    for (var y = this._startY; y < this._maxY; y++) {
                        for (var x = this._startX; x < this._maxX; x++) {
                            if ((this._temptype = this.getTileFromXY(x, y)) && this._temptype.cellIndex !== -1) {
                                var cell = this.atlas.cells[this._temptype.cellIndex];
                                var drawX = x * this.tileWidth + this._temptype.offset.x;
                                var drawY = y * this.tileHeight - (cell.h - this.tileHeight) + this._temptype.offset.y;
                                ctx.drawImage(this.atlas.image, cell.x, cell.y, cell.w, cell.h, drawX, drawY, cell.w, cell.h);
                            }
                        }
                    }
                    ctx.restore();
                    return true;
                };
                TileMapLayerOrthogonal.prototype.renderGL = function (gl, camera, params) {
                    if (params === void 0) { params = null; }
                    //Setup
                    var vertexItems = [];
                    //Transform/Matrix
                    var t = this.transform;
                    var m = t.getConcatenatedMatrix();
                    //Find which ones we need to render.
                    this._calculateBoundaries(camera, m);
                    //Loop through the tiles.
                    for (var y = this._startY; y < this._maxY; y++) {
                        for (var x = this._startX; x < this._maxX; x++) {
                            //Get the tile type
                            this._temptype = this.getTileFromXY(x, y);
                            //Skip tiletypes that don't use a cellIndex.
                            if (this._temptype.cellIndex == -1)
                                continue;
                            //Get the cell index
                            var cell = this.atlas.cells[this._temptype.cellIndex];
                            var tx = x * this.tileWidth + this._temptype.offset.x;
                            var ty = y * this.tileHeight + this._temptype.offset.y;
                            //Set up the points
                            this._corner1.setTo(tx - t.rotPointX, ty - t.rotPointY - (cell.h - this.tileHeight));
                            this._corner2.setTo(tx + cell.w - t.rotPointX, ty - t.rotPointY - (cell.h - this.tileHeight));
                            this._corner3.setTo(tx + cell.w - t.rotPointX, ty + cell.h - t.rotPointY - (cell.h - this.tileHeight));
                            this._corner4.setTo(tx - t.rotPointX, ty + cell.h - t.rotPointY - (cell.h - this.tileHeight));
                            //Add on the matrix to the points
                            m.transformPoint(this._corner1);
                            m.transformPoint(this._corner2);
                            m.transformPoint(this._corner3);
                            m.transformPoint(this._corner4);
                            //Append to the xyuv array
                            vertexItems.push(this._corner1.x + t.rotPointX, this._corner1.y + t.rotPointY, cell.x, cell.y, this.alpha, //Top Left Point
                            this._corner2.x + t.rotPointX, this._corner2.y + t.rotPointY, cell.x + cell.w, cell.y, this.alpha, //Top Right Point
                            this._corner3.x + t.rotPointX, this._corner3.y + t.rotPointY, cell.x + cell.w, cell.y + cell.h, this.alpha, //Bottom Right Point
                            this._corner4.x + t.rotPointX, this._corner4.y + t.rotPointY, cell.x, cell.y + cell.h, this.alpha //Bottom Left Point
                            );
                        }
                    }
                    //Concat points to the Renderer.
                    this.glRenderer.concatBatch(vertexItems);
                };
                return TileMapLayerOrthogonal;
            })(Tilemap.TileMapLayer);
            Tilemap.TileMapLayerOrthogonal = TileMapLayerOrthogonal;
        })(Tilemap = GameObjects.Tilemap || (GameObjects.Tilemap = {}));
    })(GameObjects = Kiwi.GameObjects || (Kiwi.GameObjects = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module GameObjects
* @submodule Tilemap
*
*/
var Kiwi;
(function (Kiwi) {
    var GameObjects;
    (function (GameObjects) {
        var Tilemap;
        (function (Tilemap) {
            /**
            * Contains the code for managing and rendering Isometric types of TileMaps.
            * This class should not be directly created, but instead should be created via methods on the TileMap class.
            *
            *
            * @class TileMapLayerIsometric
            * @extends Kiwi.GameObjects.Tilemap.TileMapLayer
            * @namespace Kiwi.GameObjects.Tilemap
            * @since 1.3.0
            * @constructor
            * @param tilemap {Kiwi.GameObjects.Tilemap.TileMap} The TileMap that this layer belongs to.
            * @param name {String} The name of this TileMapLayer.
            * @param atlas {Kiwi.Textures.TextureAtlas} The texture atlas that should be used when rendering this TileMapLayer onscreen.
            * @param data {Number[]} The information about the tiles.
            * @param tw {Number} The width of a single tile in pixels. Usually the same as the TileMap unless told otherwise.
            * @param th {Number} The height of a single tile in pixels. Usually the same as the TileMap unless told otherwise.
            * @param [x=0] {Number} The x coordinate of the tilemap in pixels.
            * @param [y=0] {Number} The y coordinate of the tilemap in pixels.
            * @param [w=0] {Number} The width of the whole tilemap in tiles. Usually the same as the TileMap unless told otherwise.
            * @param [h=0] {Number} The height of the whole tilemap in tiles. Usually the same as the TileMap unless told otherwise.
            * @return {TileMapLayer}
            */
            var TileMapLayerIsometric = (function (_super) {
                __extends(TileMapLayerIsometric, _super);
                function TileMapLayerIsometric(tilemap, name, atlas, data, tw, th, x, y, w, h) {
                    if (x === void 0) { x = 0; }
                    if (y === void 0) { y = 0; }
                    if (w === void 0) { w = 0; }
                    if (h === void 0) { h = 0; }
                    _super.call(this, tilemap, name, atlas, data, tw, th, x, y, w, h);
                    /**
                    * The orientation of the of tilemap.
                    * TileMaps can be either 'orthogonal' (normal) or 'isometric'.
                    * @property orientation
                    * @type String
                    * @default 'isometric'
                    * @public
                    */
                    this.orientation = Tilemap.ISOMETRIC;
                }
                /**
                * The type of object that it is.
                * @method objType
                * @return {String} "TileMapLayer"
                * @public
                */
                TileMapLayerIsometric.prototype.objType = function () {
                    return "TileMapLayer";
                };
                /**
                * Returns the index of the tile based on the x and y pixel coordinates that are passed.
                * If no tile is a the coordinates given then -1 is returned instead.
                * Coordinates are in pixels not tiles and use the world coordinates of the tilemap.
                *
                * Functionality needs to be added by classes extending this class.
                *
                * @method getIndexFromCoords
                * @param x {Number} The x coordinate of the Tile you would like to retrieve.
                * @param y {Number} The y coordinate of the Tile you would like to retrieve.
                * @return {Number} Either the index of the tile retrieved or -1 if none was found.
                * @public
                */
                TileMapLayerIsometric.prototype.getIndexFromCoords = function (x, y) {
                    //Not within the bounds?
                    var halfWidth = this.widthInPixels * 0.5;
                    var halfHeight = this.heightInPixels * 0.5;
                    if (Math.abs(x) > halfWidth - halfWidth * Math.abs(y - halfHeight) / halfHeight)
                        return -1;
                    var point = this.screenToChart({ x: x, y: y });
                    return this.getIndexFromXY(point.x, point.y);
                };
                /**
                * ChartToScreen maps a point in the game tile coordinates into screen pixel
                * coordinates that indicate where the tile should be drawn.
                *
                * @method chartToScreen
                * @param chartPt {any} A Object containing x/y properties of the tile.
                * @param [tileW] {Number} The width of the tile
                * @param [tileH] {Number} The height of the tile
                * @return {Object} With x/y properties of the location of the map onscreen.
                * @public
                */
                TileMapLayerIsometric.prototype.chartToScreen = function (chartPt, tileW, tileH) {
                    if (tileW === void 0) { tileW = this.tileWidth; }
                    if (tileH === void 0) { tileH = this.tileHeight; }
                    return {
                        x: (chartPt.x - chartPt.y) * tileW * 0.5,
                        y: (chartPt.x + chartPt.y) * tileH * 0.5
                    };
                };
                /**
                * ScreenToChart maps a point in screen coordinates into the game tile chart
                * coordinates for the tile on which the screen point falls on.
                *
                * @method screenToChart
                * @param scrPt {any} An object containing x/y coordinates of the point on the screen you want to convert to tile coordinates.
                * @param [tileW] {Number} The width of a single tile.
                * @param [tileH] {Number} The height of a single tile.
                * @return {Object} With x/y properties of the location of tile on the screen.
                * @public
                */
                TileMapLayerIsometric.prototype.screenToChart = function (scrPt, tileW, tileH) {
                    if (tileW === void 0) { tileW = this.tileWidth; }
                    if (tileH === void 0) { tileH = this.tileHeight; }
                    var xht = scrPt.x / (tileW * 0.5);
                    var yht = scrPt.y / (tileH * 0.5);
                    var col = Math.floor((xht + yht) * 0.5);
                    var row = Math.floor((yht - xht) * 0.5);
                    return {
                        x: col,
                        y: row
                    };
                };
                /**
                * The render loop which is used when using the Canvas renderer.
                * @method render
                * @param camera {Camera}
                * @public
                */
                TileMapLayerIsometric.prototype.render = function (camera) {
                    //When not to render the map.
                    if (this.visible === false || this.alpha < 0.1 || this.exists === false) {
                        return;
                    }
                    //Get the context.
                    var ctx = this.game.stage.ctx;
                    ctx.save();
                    //Make the map alphed out.
                    if (this.alpha > 0 && this.alpha <= 1) {
                        ctx.globalAlpha = this.alpha;
                    }
                    // Transform
                    var t = this.transform;
                    var m = t.getConcatenatedMatrix();
                    ctx.transform(m.a, m.b, m.c, m.d, m.tx, m.ty);
                    this._calculateBoundaries(camera, m);
                    for (var y = this._startY; y < this._maxY; y++) {
                        for (var x = this._startX; x < this._maxX; x++) {
                            if ((this._temptype = this.getTileFromXY(x, y)) && this._temptype.cellIndex !== -1) {
                                var cell = this.atlas.cells[this._temptype.cellIndex];
                                var offsetX = this._temptype.offset.x;
                                var offsetY = this._temptype.offset.y;
                                var w = this.tileWidth * (this.width * 2 - 1);
                                var h = this.tileHeight * this.height;
                                // We want <0,0>'s horizontal center point to be in the screen center, hence the -tileWidth/2.
                                var shiftX = this.tileWidth / 2;
                                var screenPos = this.chartToScreen({ x: x, y: y }, this.tileWidth, this.tileHeight);
                                var drawX = screenPos.x + this._temptype.offset.x - shiftX;
                                var drawY = screenPos.y - (cell.h - this.tileHeight) + this._temptype.offset.y;
                                ctx.drawImage(this.atlas.image, cell.x, cell.y, cell.w, cell.h, drawX, drawY, cell.w, cell.h);
                            }
                        }
                    }
                    ctx.restore();
                    return true;
                };
                TileMapLayerIsometric.prototype.renderGL = function (gl, camera, params) {
                    if (params === void 0) { params = null; }
                    //Setup
                    var vertexItems = [];
                    //Transform/Matrix
                    var t = this.transform;
                    var m = t.getConcatenatedMatrix();
                    //Find which ones we need to render.
                    this._calculateBoundaries(camera, m);
                    //Loop through the tiles.
                    for (var y = this._startY; y < this._maxY; y++) {
                        for (var x = this._startX; x < this._maxX; x++) {
                            //Get the tile type
                            this._temptype = this.getTileFromXY(x, y);
                            //Skip tiletypes that don't use a cellIndex.
                            if (this._temptype.cellIndex == -1)
                                continue;
                            //Get the cell index
                            var cell = this.atlas.cells[this._temptype.cellIndex];
                            // Isometric maps
                            var offsetX = this._temptype.offset.x;
                            var offsetY = this._temptype.offset.y;
                            var w = this.tileWidth * (this.width * 2 - 1);
                            var h = this.tileHeight * this.height;
                            // We want <0,0>'s horizontal center point to be in the screen center, hence the -tileWidth/2.
                            var shiftX = this.tileWidth / 2;
                            var screenPos = this.chartToScreen({ x: x, y: y }, this.tileWidth, this.tileHeight);
                            var tx = screenPos.x + this._temptype.offset.x - shiftX;
                            var ty = screenPos.y + this._temptype.offset.y;
                            //Set up the points
                            this._corner1.setTo(tx - t.rotPointX, ty - t.rotPointY - (cell.h - this.tileHeight));
                            this._corner2.setTo(tx + cell.w - t.rotPointX, ty - t.rotPointY - (cell.h - this.tileHeight));
                            this._corner3.setTo(tx + cell.w - t.rotPointX, ty + cell.h - t.rotPointY - (cell.h - this.tileHeight));
                            this._corner4.setTo(tx - t.rotPointX, ty + cell.h - t.rotPointY - (cell.h - this.tileHeight));
                            //Add on the matrix to the points
                            m.transformPoint(this._corner1);
                            m.transformPoint(this._corner2);
                            m.transformPoint(this._corner3);
                            m.transformPoint(this._corner4);
                            //Append to the xyuv array
                            vertexItems.push(this._corner1.x + t.rotPointX, this._corner1.y + t.rotPointY, cell.x, cell.y, this.alpha, //Top Left Point
                            this._corner2.x + t.rotPointX, this._corner2.y + t.rotPointY, cell.x + cell.w, cell.y, this.alpha, //Top Right Point
                            this._corner3.x + t.rotPointX, this._corner3.y + t.rotPointY, cell.x + cell.w, cell.y + cell.h, this.alpha, //Bottom Right Point
                            this._corner4.x + t.rotPointX, this._corner4.y + t.rotPointY, cell.x, cell.y + cell.h, this.alpha //Bottom Left Point
                            );
                        }
                    }
                    //Concat points to the Renderer.
                    this.glRenderer.concatBatch(vertexItems);
                };
                return TileMapLayerIsometric;
            })(Tilemap.TileMapLayer);
            Tilemap.TileMapLayerIsometric = TileMapLayerIsometric;
        })(Tilemap = GameObjects.Tilemap || (GameObjects.Tilemap = {}));
    })(GameObjects = Kiwi.GameObjects || (Kiwi.GameObjects = {}));
})(Kiwi || (Kiwi = {}));
/**
* Component's are a snipnets of code which are designed to provide extra functionality to various objects that contain a ComponentManager. Objects do not have to have Components in order to preform their main function, but are instead provided to make common task's that you may want to do with those Objects a bit easier. For example: Some times you would like to easily listen for when a GameObject has been 'clicked'. So you can attach a 'InputComponent' to a GameObject (Sprites have them by default) which will then do hit-detector code for you. All you have to do is Subscribe to the events on the InputComponent.
*
* @module Kiwi
* @submodule Components
* @main Components
*/
var Kiwi;
(function (Kiwi) {
    var Components;
    (function (Components) {
        /**
        * The AnimationManager is used to handle the creation and use of spritesheet Animations on a GameObject based on the TextureAtlas it has.
        * If the When the AnimationManager is instantiated it will loop through all of the Sequences on the TextureAtlas of the GameObject being used and will create a new Animation for each one.
        * Now when you create a new Animation that animation will automatically be added as a new Sequence to the corresponding Texture.
        * This way you don't need to create new Animations for a each Sprite that use's the same Texture.
        *
        * @class AnimationManager
        * @extends Kiwi.Component
        * @namespace Kiwi.Components
        * @constructor
        * @param entity {Kiwi.Entity} The entity that this animation component belongs to.
        * @param [inheritSequences=true] {Boolean} If a new Animation should be created for each Sequence on the Entities TextureAtlas it is a part of or not.
        * @return {Kiwi.Components.AnimationManager}
        */
        var AnimationManager = (function (_super) {
            __extends(AnimationManager, _super);
            function AnimationManager(entity, inheritSequences) {
                if (inheritSequences === void 0) { inheritSequences = true; }
                _super.call(this, entity, 'Animation');
                /**
                * A reference to the animation that is currently being played.
                * @property currentAnimation
                * @type Kiwi.Animations.Animation
                * @public
                */
                this.currentAnimation = null;
                //Get the entity and the animation.
                this.entity = entity;
                this._atlas = this.entity.atlas;
                this._animations = {};
                //Create all of the default animations.
                if (inheritSequences == true) {
                    for (var i = 0; i < this._atlas.sequences.length; i++) {
                        this.createFromSequence(this._atlas.sequences[i], false);
                    }
                }
                //If a default animation already exists
                if (this._animations['default']) {
                    this.currentAnimation = this._animations['default'];
                }
                else {
                    var defaultCells = [];
                    for (var i = 0; i < this._atlas.cells.length; i++) {
                        defaultCells.push(i);
                    }
                    this.currentAnimation = this.add('default', defaultCells, 0.1, true, false);
                }
                //Signals
                this.onChange = new Kiwi.Signal;
                this.onPlay = new Kiwi.Signal;
                this.onStop = new Kiwi.Signal;
                this.onUpdate = new Kiwi.Signal;
            }
            Object.defineProperty(AnimationManager.prototype, "isPlaying", {
                /**
                * Returns a boolean indicating whether or not the current animation is playing. This is READ ONLY.
                * @property isPlaying
                * @type boolean
                * @public
                */
                get: function () {
                    return this.currentAnimation.isPlaying;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Returns a string indicating the type of object that this is.
            * @method objType
            * @return {String} "AnimationManager"
            * @public
            */
            AnimationManager.prototype.objType = function () {
                return "AnimationManager";
            };
            /**
            * Creates a new Animation (by creating a Sequence) that can then be played on this AnimationManager.
            * If you pass to this the name of a Animation that already exists, then the previous Animation will be overridden by this new one.
            * Note: If the Animation you have overridden was the currentAnimation, then the previous Animation will keep playing until a different Animation is switched to.
            * By default new Animation Sequences are also added to the TextureAtlas, which can then be inherited.
            * Returns the Animation that was created.
            *
            * @method add
            * @param name {string} The name of the animation that is to be created.
            * @param cells {Array} An array of numbers, which are reference to each cell that is to be played in the Animation in order.
            * @param speed {number} The amount of time that each cell in the Animation should stay on screen for. In seconds.
            * @param [loop=false] {boolean} If when the Animation reaches the last frame, it should go back to the start again.
            * @param [play=false] {boolean} If once created the animation should played right away.
            * @param [addToAtlas=true] {boolean} If the new Sequence created should be added to the TextureAtlas or not.
            * @return {Kiwi.Animations.Animation} The Animation that was created.
            * @public
            */
            AnimationManager.prototype.add = function (name, cells, speed, loop, play, addToAtlas) {
                if (loop === void 0) { loop = false; }
                if (play === void 0) { play = false; }
                if (addToAtlas === void 0) { addToAtlas = true; }
                var newSequence = new Kiwi.Animations.Sequence(name, cells, speed, loop);
                if (addToAtlas == true)
                    this._atlas.sequences.push(newSequence);
                return this.createFromSequence(newSequence, play);
            };
            /**
            * Creates a new Animation based on a Sequence that is passed.
            * If you pass to this the name of a Animation that already exists, then the previous Animation will be overridden by this new one.
            * Note: If the Animation you have overridden was the currentAnimation, then the previous Animation will keep playing until a different Animation is switched to.
            * Returns the Animation that was created.
            *
            * @method createFromSequence
            * @param sequence {Kiwi.Sequence} The sequence that the Animation is based on.
            * @param [play=false] {boolean} If the Animation should played once it has been created
            * @return {Kiwi.Animations.Animation} The Animation that was created.
            * @public
            */
            AnimationManager.prototype.createFromSequence = function (sequence, play) {
                if (play === void 0) { play = false; }
                this._animations[sequence.name] = new Kiwi.Animations.Animation(sequence.name, sequence, null, this);
                if (play)
                    this.play(sequence.name);
                return this._animations[sequence.name];
            };
            /**
            * Plays either the current animation or the name of the animation that you pass.
            *
            * @method play
            * @param [name] {String} The name of the animation that you want to play. If not passed it plays the current animation.
            * @param [resetTime=true] {Boolean} When set to false, this will prevent a new Animation from playing if it is already the currentAnimation that is already playing.
            * @return {Kiwi.Animations.Animation} Returns the current Animation that is now playing.
            * @public
            */
            AnimationManager.prototype.play = function (name, resetTime) {
                if (name === void 0) { name = this.currentAnimation.name; }
                if (resetTime === void 0) { resetTime = true; }
                //If the current animation playing 
                if (resetTime == false && this.currentAnimation.name === name && this.currentAnimation.isPlaying == true) {
                    return this.currentAnimation;
                }
                else {
                    return this._play(name);
                }
            };
            /**
            * Plays an Animation at a particular frameIndex.
            * Note: The frameIndex is a particular index of a cell in the Sequence of the Animation you would like to play.
            * Example: If you had a Animation with a Sequence [0, 1, 2, 3] and you told it to play at index '2', then the cell that it would be at is '3'.
            *
            * @method playAt
            * @param index {Number} The index of the frame in the Sequence that you would like to play.
            * @param [name] {String} The name of the animation that you want to play. If not passed, it attempts to play it on the current animation.
            * @return {Kiwi.Animations.Animation} Returns the current Animation that is now playing.
            * @public
            */
            AnimationManager.prototype.playAt = function (index, name) {
                if (name === void 0) { name = this.currentAnimation.name; }
                return this._play(name, index);
            };
            /**
            * An internal method used to actually play a Animation at a Index.
            *
            * @method _play
            * @param name {string} The name of the animation that is to be switched to.
            * @param [index=null] {number} The index of the frame in the Sequence that is to play. If null, then it restarts the animation at the cell it currently is at.
            * @return {Kiwi.Animations.Animation} Returns the current Animation that is now playing.
            * @private
            */
            AnimationManager.prototype._play = function (name, index) {
                if (index === void 0) { index = null; }
                this._setCurrentAnimation(name);
                if (index !== null)
                    this.currentAnimation.playAt(index);
                else
                    this.currentAnimation.play();
                this.onPlay.dispatch(this.currentAnimation);
                this.updateCellIndex();
                return this.currentAnimation;
            };
            /**
            * Stops the current animation from playing.
            *
            * @method stop
            * @public
            */
            AnimationManager.prototype.stop = function () {
                if (this.isPlaying === true) {
                    this.currentAnimation.stop();
                    this.onStop.dispatch(this.currentAnimation);
                }
            };
            /**
            * Pauses the current animation.
            * @method pause
            * @public
            */
            AnimationManager.prototype.pause = function () {
                this.currentAnimation.pause();
            };
            /**
            * Resumes the current animation.
            * The animation should have already been paused.
            *
            * @method resume
            * @public
            */
            AnimationManager.prototype.resume = function () {
                this.currentAnimation.resume();
            };
            /**
            * Either switches to a particular animation OR a particular frame in the current animation depending on if you pass the name of an animation that exists on this Manager (as a string) or a number refering to a frame index on the Animation.
            * When you switch to a particular animation then
            * You can also force the animation to play or to stop by passing a boolean in. But if left as null, the state of the Animation will based off what is currently happening.
            * So if the animation is currently 'playing' then once switched to the animation will play. If not currently playing it will switch to and stop.
            * If the previous animation played is non-looping and has reached its final frame, it is no longer considered playing, and as such, switching to another animation will not play unless the argument to the play parameter is true.
            *
            * @method switchTo
            * @param val {string|number}
            * @param [play=null] {boolean} Force the animation to play or stop. If null the animation base's it off what is currently happening.
            * @public
            */
            AnimationManager.prototype.switchTo = function (val, play) {
                if (play === void 0) { play = null; }
                var switched = false;
                switch (typeof val) {
                    case "string":
                        if (this.currentAnimation.name !== val) {
                            this._setCurrentAnimation(val);
                            switched = true;
                        }
                        break;
                    case "number":
                        this.currentAnimation.frameIndex = val;
                        switched = true;
                        break;
                }
                //Play if the dev forced it to OR if the animation was already playing
                if (play || play === null && this.isPlaying && switched)
                    this.play();
                if (play == false && this.isPlaying)
                    this.stop();
                this.updateCellIndex();
            };
            /**
            * Makes the current animation go to the next frame. If the animation is at the end of the sequence it then goes back to the start.
            * @method nextFrame
            * @public
            */
            AnimationManager.prototype.nextFrame = function () {
                this.currentAnimation.nextFrame();
                this.updateCellIndex();
            };
            /**
            * Makes the current animation go to the prev frame. If the animation is at the start, the animation will go the end of the sequence.
            * @method prevFrame
            * @public
            */
            AnimationManager.prototype.prevFrame = function () {
                this.currentAnimation.prevFrame();
                this.updateCellIndex();
            };
            /**
            * Internal method that sets the current animation to a Animation passed.
            *
            * @method _setCurrentAnimation
            * @param name {string} Name of the Animation that is to be switched to.
            * @param [inheritFromTexture=true] {booelan} If the animation component should look on the texture atlas for a sequence with that name.
            * @private
            */
            AnimationManager.prototype._setCurrentAnimation = function (name, inheritFromTexture) {
                if (inheritFromTexture === void 0) { inheritFromTexture = true; }
                if (this.currentAnimation.name !== name) {
                    if (this.currentAnimation !== null)
                        this.currentAnimation.stop();
                    if (this._animations[name]) {
                        //Switch to the animation if it exists
                        this.currentAnimation = this._animations[name];
                        this.onChange.dispatch(name, this.currentAnimation);
                    }
                    else if (inheritFromTexture) {
                        //Check to see if that animation exists on the atlas.
                        //If so create a new version of it.
                        for (var i = 0; i < this._atlas.sequences.length; i++) {
                            if (this._atlas.sequences[i].name === name) {
                                this.currentAnimation = this.createFromSequence(this._atlas.sequences[i], false);
                                this.onChange.dispatch(name, this.currentAnimation);
                            }
                        }
                    }
                }
            };
            /**
            * The update loop for this component.
            * Only updates the currentAnimation and only if it is playing.
            *
            * @method update
            * @public
            */
            AnimationManager.prototype.update = function () {
                if (this.currentAnimation) {
                    this.currentAnimation.update();
                }
            };
            Object.defineProperty(AnimationManager.prototype, "currentCell", {
                /**
                * Gets the cell that the current Animation is current at. This is READ ONLY.
                * @property currentCell
                * @type number
                * @public
                */
                get: function () {
                    return this.currentAnimation.currentCell;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(AnimationManager.prototype, "frameIndex", {
                /**
                * Gets the current frame index of the cell in the Sequence that is currently playing. This is READ ONLY.
                * @property frameIndex
                * @type number
                * @public
                */
                get: function () {
                    return this.currentAnimation.frameIndex;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(AnimationManager.prototype, "length", {
                /**
                * Returns the length (Number of cells) of the current Animation that is playing. This is READ ONLY.
                * @property length
                * @type number
                * @public
                */
                get: function () {
                    return this.currentAnimation.length;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Returns a Animation that is on this AnimationComponent
            * Does not check to see if that Animation exists or not.
            *
            * @method getAnimation
            * @param name {string} The name of the Animation you would like to get.
            * @return {Kiwi.Animations.Animation} The Animation that is found. Will be 'undefined' if a Animation with that name did not exist.
            * @public
            */
            AnimationManager.prototype.getAnimation = function (name) {
                return this._animations[name];
            };
            /**
            * An internal method that is used to update the cell index of an entity when an animation says it needs to update.
            * @method updateCellIndex
            * @protected
            */
            AnimationManager.prototype.updateCellIndex = function () {
                if (typeof this.currentAnimation !== "undefined") {
                    this.entity.cellIndex = this.currentAnimation.currentCell;
                    this.onUpdate.dispatch(this.currentAnimation);
                }
            };
            /**
            * Destroys the animation component and runs the destroy method on all of the anims that it has.
            * @method destroy
            * @public
            */
            AnimationManager.prototype.destroy = function () {
                _super.prototype.destroy.call(this);
                for (var key in this._animations) {
                    this._animations[key].destroy();
                    delete this._animations[key];
                }
                delete this._animations;
                delete this.currentAnimation;
                delete this._atlas;
            };
            return AnimationManager;
        })(Kiwi.Component);
        Components.AnimationManager = AnimationManager;
    })(Components = Kiwi.Components || (Kiwi.Components = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Components
*
*/
var Kiwi;
(function (Kiwi) {
    var Components;
    (function (Components) {
        /**
        * The Box Component is used to handle the various 'bounds' that each GameObject has.
        * There are two main different types of bounds (Bounds and Hitbox) with each one having three variants (each one is a rectangle) depending on what you are wanting:
        *
        * RawBounds: The bounding box of the GameObject before rotation/scale.
        *
        * RawHitbox: The hitbox of the GameObject before rotation/scale. This can be modified to be different than the normal bounds but if not specified it will be the same as the raw bounds.
        *
        * Bounds: The bounding box of the GameObject after rotation/scale.
        *
        * Hitbox: The hitbox of the GameObject after rotation/scale. If you modified the raw hitbox then this one will be modified as well, otherwise it will be the same as the normal bounds.
        *
        * WorldBounds: The bounding box of the Entity using its world coordinates and after rotation/scale.
        *
        * WorldHitbox: The hitbox of the Entity using its world coordinates and after rotation/scale.
        *
        * @class Box
        * @extends Kiwi.Component
        * @namespace Kiwi.Components
        * @constructor
        * @param parent {Kiwi.Entity} The entity that this box belongs to.
        * @param [x=0] {Number} Its position on the x axis
        * @param [y=0] {Number} Its position on the y axis
        * @param [width=0] {Number} The width of the box.
        * @param [height=0] {Number} The height of the box.
        * @return {Kiwi.Components.Box}
        */
        var Box = (function (_super) {
            __extends(Box, _super);
            function Box(parent, x, y, width, height) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (width === void 0) { width = 0; }
                if (height === void 0) { height = 0; }
                _super.call(this, parent, 'Box');
                /**
                * Controls whether the hitbox should update automatically to match the hitbox of the current cell on the entity this Box component is attached to (default behaviour).
                * Or if the hitbox shouldn't auto update. Which will mean it will stay the same as the last value it had.
                * This property is automatically set to 'false' when you override the hitboxes width/height, but you can set this to true afterwards.
                *
                * @property autoUpdate
                * @type boolean
                * @default true
                * @private
                */
                this.autoUpdate = true;
                this.entity = parent;
                this._rawBounds = new Kiwi.Geom.Rectangle(x, y, width, height);
                this._rawCenter = new Kiwi.Geom.Point(x + width / 2, y + height / 2);
                this._rawHitbox = new Kiwi.Geom.Rectangle();
                this._hitboxOffset = new Kiwi.Geom.Point();
                this.hitbox = new Kiwi.Geom.Rectangle(0, 0, width, height);
                this.autoUpdate = true;
                this._scratchMatrix = new Kiwi.Geom.Matrix();
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {string} "Box"
            * @public
            */
            Box.prototype.objType = function () {
                return "Box";
            };
            Object.defineProperty(Box.prototype, "hitboxOffset", {
                /**
                * Returns the offset value of the hitbox as a point for the X/Y axis for the developer to use.
                * This is without rotation or scaling.
                * This is a READ ONLY property.
                * @property hitboxOffset
                * @type Kiwi.Geom.Point
                * @public
                */
                get: function () {
                    if (this.autoUpdate == true && this.entity.atlas !== null && this.entity.atlas.cells && this.entity.atlas.cells[0].hitboxes) {
                        this._hitboxOffset.x =
                            this.entity.atlas.cells[this.entity.cellIndex].hitboxes[0].x || 0;
                        this._hitboxOffset.y =
                            this.entity.atlas.cells[this.entity.cellIndex].hitboxes[0].y || 0;
                    }
                    return this._hitboxOffset;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Box.prototype, "rawHitbox", {
                /**
                * Returns the raw hitbox rectangle for the developer to use.
                * 'Raw' means where it would be without rotation or scaling.
                * This is READ ONLY.
                * @property rawHitbox
                * @type Kiwi.Geom.Rectangle
                * @public
                */
                get: function () {
                    this._rawHitbox.x = this.rawBounds.x + this.hitboxOffset.x;
                    this._rawHitbox.y = this.rawBounds.y + this.hitboxOffset.y;
                    //If the hitbox has not already been set, then update the width/height based upon the current cell that the entity has.
                    if (this.autoUpdate == true) {
                        var atlas = this.entity.atlas;
                        if (atlas !== null && atlas.cells && atlas.cells[0].hitboxes) {
                            this._rawHitbox.width = atlas.cells[this.entity.cellIndex].hitboxes[0].w;
                            this._rawHitbox.height = atlas.cells[this.entity.cellIndex].hitboxes[0].h;
                        }
                        else {
                            this._rawHitbox.width = this.entity.width;
                            this._rawHitbox.height = this.entity.height;
                        }
                    }
                    return this._rawHitbox;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Box.prototype, "hitbox", {
                /**
                * The 'normal' or transformed hitbox for the entity. This is its box after rotation/Kiwi.Geom.Rectangle.
                * @property hitbox
                * @type Kiwi.Geom.Rectangle
                * @public
                */
                get: function () {
                    this._transformedHitbox = this._rotateHitbox(this.rawHitbox.clone());
                    return this._transformedHitbox;
                },
                set: function (value) {
                    //Use custom hitbox defined by user.
                    this._hitboxOffset.x = value.x;
                    this._hitboxOffset.y = value.y;
                    this._rawHitbox = value;
                    this._rawHitbox.x += this._rawBounds.x;
                    this._rawHitbox.y += this._rawBounds.y;
                    this.autoUpdate = false;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Box.prototype, "worldHitbox", {
                /**
                * Returns the transformed hitbox for the entity using its 'world' coordinates.
                * This is READ ONLY.
                * @property worldHitbox
                * @type Kiwi.Geom.Rectangle
                * @public
                */
                get: function () {
                    this._worldHitbox = this._rotateHitbox(this.rawHitbox.clone(), true);
                    return this._worldHitbox;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Box.prototype, "rawBounds", {
                /**
                * Returns the 'raw' bounds for this entity.
                * This is READ ONLY.
                * @property rawBounds
                * @type Kiwi.Geom.Rectangle
                * @public
                */
                get: function () {
                    this._rawBounds.x = this.entity.x;
                    this._rawBounds.y = this.entity.y;
                    this._rawBounds.width = this.entity.width;
                    this._rawBounds.height = this.entity.height;
                    return this._rawBounds;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Box.prototype, "rawCenter", {
                /**
                * Returns the raw center point of the box.
                * This is READ ONLY.
                * @property rawCenter
                * @type Kiwi.Geom.Point
                * @public
                */
                get: function () {
                    this._rawCenter.x = this.rawBounds.x + this.rawBounds.width / 2;
                    this._rawCenter.y = this.rawBounds.y + this.rawBounds.height / 2;
                    return this._rawCenter;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Box.prototype, "center", {
                /**
                * Returns the center point for the box after it has been transformed.
                * World coordinates.
                * This is READ ONLY.
                * @property center
                * @type Kiwi.Geom.Point
                * @public
                */
                get: function () {
                    var m = this.entity.transform.getConcatenatedMatrix();
                    this._transformedCenter = m.transformPoint(new Kiwi.Geom.Point(this.entity.width / 2 - this.entity.anchorPointX, this.entity.height / 2 - this.entity.anchorPointY));
                    return this._transformedCenter;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Box.prototype, "bounds", {
                /**
                * Returns the 'transformed' or 'normal' bounds for this box.
                * This is READ ONLY.
                * @property bounds
                * @type Kiwi.Geom.Rectangle
                * @public
                */
                get: function () {
                    this._transformedBounds = this._rotateRect(this.rawBounds.clone());
                    return this._transformedBounds;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Box.prototype, "worldBounds", {
                /**
                * Returns the 'transformed' bounds for this entity using the world coodinates.
                * This is READ ONLY.
                * @property worldBounds
                * @type Kiwi.Geom.Rectangle
                * @public
                */
                get: function () {
                    this._worldBounds = this._rotateRect(this.rawBounds.clone(), true);
                    return this._worldBounds;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Private internal method only. Used to calculate the transformed bounds after rotation/scale.
            * @method _rotateRect
            * @param rect {Kiwi.Geom.Rectangle}
            * @param [useWorldCoords=false] {Boolean}
            * @return {Kiwi.Geom.Rectangle}
            * @private
            */
            Box.prototype._rotateRect = function (rect, useWorldCoords) {
                if (useWorldCoords === void 0) { useWorldCoords = false; }
                var out = new Kiwi.Geom.Rectangle();
                var t = this.entity.transform;
                var m = this._scratchMatrix.copyFrom(t.getConcatenatedMatrix());
                // Use world coordinates?
                if (!useWorldCoords) {
                    m.setTo(m.a, m.b, m.c, m.d, t.x + t.rotPointX, t.y + t.rotPointY);
                }
                out = this.extents(m.transformPoint({ x: -t.rotPointX, y: -t.rotPointY }), m.transformPoint({ x: -t.rotPointX + rect.width, y: -t.rotPointY }), m.transformPoint({ x: -t.rotPointX + rect.width, y: -t.rotPointY + rect.height }), m.transformPoint({ x: -t.rotPointX, y: -t.rotPointY + rect.height }));
                return out;
            };
            /**
            * A private method that is used to calculate the transformed hitbox's coordinates after rotation.
            * @method _rotateHitbox
            * @param rect {Kiwi.Geom.Rectangle}
            * @param [useWorldCoords=false] {Boolean}
            * @return {Kiwi.Geom.Rectangle}
            * @private
            */
            Box.prototype._rotateHitbox = function (rect, useWorldCoords) {
                if (useWorldCoords === void 0) { useWorldCoords = false; }
                var out = new Kiwi.Geom.Rectangle();
                var t = this.entity.transform;
                var m = this._scratchMatrix.copyFrom(t.getConcatenatedMatrix());
                //Use world coordinates?
                if (!useWorldCoords) {
                    m.setTo(m.a, m.b, m.c, m.d, t.x + t.rotPointX, t.y + t.rotPointY);
                }
                out = this.extents(m.transformPoint({ x: -t.rotPointX + this._hitboxOffset.x, y: -t.rotPointY + this._hitboxOffset.y }), m.transformPoint({ x: -t.rotPointX + rect.width + this._hitboxOffset.x, y: -t.rotPointY + this._hitboxOffset.y }), m.transformPoint({ x: -t.rotPointX + rect.width + this._hitboxOffset.x, y: -t.rotPointY + rect.height + this._hitboxOffset.y }), m.transformPoint({ x: -t.rotPointX + this._hitboxOffset.x, y: -t.rotPointY + rect.height + this._hitboxOffset.y }));
                return out;
            };
            /**
            * Draws the various bounds on a context that is passed. Useful for debugging and using in combination with the debug canvas.
            * @method draw
            * @param ctx {CanvasRenderingContext2D} Context of the canvas that this box component is to be rendered on top of.
            * @param [camera] {Kiwi.Camera} A camera that should be taken into account before rendered. This is the default camera by default.
            * @public
            */
            Box.prototype.draw = function (ctx, camera) {
                if (camera === void 0) { camera = this.game.cameras.defaultCamera; }
                var t = this.entity.transform;
                var ct = camera.transform;
                // Draw raw bounds and raw center
                ctx.strokeStyle = "red";
                ctx.fillRect(this.rawCenter.x + ct.x - 1, this.rawCenter.y + ct.y - 1, 3, 3);
                ctx.strokeRect(t.x + ct.x + t.rotPointX - 3, t.y + ct.y + t.rotPointY - 3, 7, 7);
                // Draw bounds
                ctx.strokeStyle = "blue";
                ctx.strokeRect(this.bounds.x + ct.x, this.bounds.y + ct.y, this.bounds.width, this.bounds.height);
                // Draw hitbox
                ctx.strokeStyle = "green";
                ctx.strokeRect(this.hitbox.x + ct.x, this.hitbox.y + ct.y, this.hitbox.width, this.hitbox.height);
                // Draw raw hitbox
                ctx.strokeStyle = "white";
                ctx.strokeRect(this.rawHitbox.x + ct.x, this.rawHitbox.y + ct.y, this.rawHitbox.width, this.rawHitbox.height);
                // Draw world bounds
                ctx.strokeStyle = "purple";
                ctx.strokeRect(this.worldBounds.x, this.worldBounds.y, this.worldBounds.width, this.worldBounds.height);
                // Draw world hitbox
                ctx.strokeStyle = "cyan";
                ctx.strokeRect(this.worldHitbox.x, this.worldHitbox.y, this.worldHitbox.width, this.worldHitbox.height);
            };
            /**
            * Method which takes four Points and then converts it into a Rectangle, which represents the area those points covered.
            * The points passed can be maybe in any order, as the are checked for validity first.
            *
            * @method extents
            * @param topLeftPoint {Kiwi.Geom.Point} The top left Point that the Rectangle should have.
            * @param topRightPoint {Kiwi.Geom.Point} The top right Point that the Rectangle should have.
            * @param bottomRightPoint {Kiwi.Geom.Point} The bottom right Point that the Rectangle should have.
            * @param bottomLeftPoint {Kiwi.Geom.Point} The bottom left Point that the Rectangle should have.
            * @return {Kiwi.Geom.Rectangle} The new Rectangle that represents the area the points covered.
            * @return Rectangle
            */
            Box.prototype.extents = function (topLeftPoint, topRightPoint, bottomRightPoint, bottomLeftPoint) {
                var left = Math.min(topLeftPoint.x, topRightPoint.x, bottomRightPoint.x, bottomLeftPoint.x);
                var right = Math.max(topLeftPoint.x, topRightPoint.x, bottomRightPoint.x, bottomLeftPoint.x);
                var top = Math.min(topLeftPoint.y, topRightPoint.y, bottomRightPoint.y, bottomLeftPoint.y);
                var bottom = Math.max(topLeftPoint.y, topRightPoint.y, bottomRightPoint.y, bottomLeftPoint.y);
                return new Kiwi.Geom.Rectangle(left, top, right - left, bottom - top);
            };
            /**
            * Destroys this component and all of the links it may have to other objects.
            * @method destroy
            * @public
            */
            Box.prototype.destroy = function () {
                _super.prototype.destroy.call(this);
                delete this.entity;
            };
            return Box;
        })(Kiwi.Component);
        Components.Box = Box;
    })(Components = Kiwi.Components || (Kiwi.Components = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Components
*
*/
var Kiwi;
(function (Kiwi) {
    var Components;
    (function (Components) {
        /**
        * The Input Component is used on GameObjects in which the user may interactive with via a Mouse or Touch
        * and as such this class contains useful methods and callbacks you can subscribe to.
        * By default the Input component is disabled (this is because when enabled the input component can be process intensive)
        * but you can enabled it yourself (which is recommened) BUT in case you forget the input component will automagically
        * be enabled once you access a Signal on this class.
        *
        * @class Input
        * @extends Kiwi.Component
        * @namespace Kiwi.Components
        * @constructor
        * @param owner {Object} The Object that this Component is on. Generally this will be a Entity.
        * @param box {Kiwi.Components.Box} The box which contains the worldHitbox that is to be used for the event firing.
        * @param [enabled=false] {boolean} If this input component should be enabled or not.
        * @return {Kiwi.Components.Input}
        */
        var Input = (function (_super) {
            __extends(Input, _super);
            function Input(owner, box, enabled) {
                if (enabled === void 0) { enabled = false; }
                _super.call(this, owner, 'Input');
                /**
                * A reference to the pointer that is currently 'dragging' this Object.
                * If not dragging then this is null.
                * @property _isDragging
                * @type Kiwi.Input.Pointer
                * @default null
                * @private
                */
                this._isDragging = null;
                /**
                * Indicates if dragging is currently enabled.
                * @property _dragEnabled
                * @type boolean
                * @default false
                * @private
                */
                this._dragEnabled = false;
                /**
                * If when dragging, the IChild should snap to the center of the pointer it is being dragged by.
                * @property _dragSnapToCenter
                * @type boolean
                * @default false
                * @private
                */
                this._dragSnapToCenter = false;
                /**
                * Temporary property that gets updated everyframe with the pointer that is currently 'down' on this entity.
                * @property _nowDown
                * @type Kiwi.Input.Pointer
                * @default null
                * @private
                */
                this._nowDown = null;
                /**
                * Temporary property that gets updated everyframe with the pointer that was just 'released' from being down on this entity
                * @property _nowUp
                * @type Kiwi.Input.Pointer
                * @default null
                * @private
                */
                this._nowUp = null;
                /**
                * Temporary property of the pointer that is now within the bounds of the entity
                * @property _nowEntered
                * @type Kiwi.Input.Pointer
                * @default null
                * @private
                */
                this._nowEntered = null;
                /**
                * Temporary property of the pointer that just left the bounds of the entity.
                * @property _nowLeft
                * @type Kiwi.Input.Pointer
                * @default null
                * @private
                */
                this._nowLeft = null;
                /**
                * Temporary property of the pointer that just started draggging the entity.
                * @property _nowDragging
                * @type Kiwi.Input.Pointer
                * @default null
                * @private
                */
                this._nowDragging = null;
                //  Signals
                this._onEntered = new Kiwi.Signal();
                this._onLeft = new Kiwi.Signal();
                this._onDown = new Kiwi.Signal();
                this._onUp = new Kiwi.Signal();
                this._onDragStarted = new Kiwi.Signal();
                this._onDragStopped = new Kiwi.Signal();
                //  Properties
                this._box = box;
                this._distance = new Kiwi.Geom.Point();
                this._withinBounds = null;
                this._outsideBounds = true;
                this._isUp = true;
                this._isDown = null;
                this._isDragging = null;
                this._justEntered = false;
                this._tempDragDisabled = false;
                this._tempPoint = new Kiwi.Geom.Point();
                this._tempCircle = new Kiwi.Geom.Circle(0, 0, 0);
                this.enabled = enabled;
            }
            /**
            * The type of object this input is.
            * @method objType
            * @return {string} "Input"
            * @public
            */
            Input.prototype.objType = function () {
                return "Input";
            };
            Object.defineProperty(Input.prototype, "onEntered", {
                /**
                * Returns the onEntered Signal, that fires events when a pointer enters the hitbox of a entity.
                * Note: Accessing this signal enables the input.
                * This is READ ONLY.
                * @property onEntered
                * @type Kiwi.Signal
                * @public
                */
                get: function () {
                    if (this.enabled == false)
                        this.enabled = true;
                    return this._onEntered;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Input.prototype, "onLeft", {
                /**
                * Returns the onLeft Signal, that fires events when a pointer leaves the hitbox of a entity.
                * Note: Accessing this signal enables the input.
                * This is READ ONLY.
                * @property onLeft
                * @type Kiwi.Signal
                * @public
                */
                get: function () {
                    if (this.enabled == false)
                        this.enabled = true;
                    return this._onLeft;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Input.prototype, "onDown", {
                /**
                * Returns the onDown Signal, that fires events when a pointer is pressed within the bounds of the signal.
                * Note: Accessing this signal enables the input.
                * This is READ ONLY.
                * @property onDown
                * @type Kiwi.Signal
                * @public
                */
                get: function () {
                    if (this.enabled == false)
                        this.enabled = true;
                    return this._onDown;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Input.prototype, "onUp", {
                /**
                * Returns the onUp Signal, that fires events when a pointer is released either within the bounds or was pressed initially within the bounds..
                * Note: Accessing this signal enables the input.
                * This is READ ONLY.
                * @property onUp
                * @type Kiwi.Signal
                * @public
                */
                get: function () {
                    if (this.enabled == false)
                        this.enabled = true;
                    return this._onUp;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Input.prototype, "onDragStarted", {
                /**
                * Returns the onDragStarted Signal.
                * This is READ ONLY.
                * @property onDragStarted
                * @type Kiwi.Signal
                * @public
                */
                get: function () { return this._onDragStarted; },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Input.prototype, "onDragStopped", {
                /**
                * Returns the onDragStopped Signal.
                * This is READ ONLY.
                * @property onDragStopped
                * @type Kiwi.Signal
                * @public
                */
                get: function () { return this._onDragStopped; },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Input.prototype, "onRelease", {
                /**
                * A alias for the on release signal.
                * This is READ ONLY.
                * @property onRelease
                * @type Kiwi.Signal
                * @public
                */
                get: function () {
                    return this.onUp;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Input.prototype, "onPress", {
                /**
                * A alias for the on press signal.
                * This is READ ONLY.
                * @property onPress
                * @type Kiwi.Signal
                * @public
                */
                get: function () {
                    return this.onDown;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Input.prototype, "enabled", {
                /**
                * Get if the input is enabled or not. Note: Inputs should only be enabled when needed, otherwise unnecessary processing does occur which can result in a slower game.
                * @property enabled
                * @type boolean
                * @public
                */
                get: function () {
                    return this._enabled;
                },
                set: function (val) {
                    this._enabled = val;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Input.prototype, "isDown", {
                /**
                * Used to see if a pointer is currently on this input. Returns a boolean indicating either true or false.
                * This is READ ONLY.
                * @property isDown
                * @type boolean
                * @public
                */
                get: function () {
                    return (this._isDown !== null);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Input.prototype, "isUp", {
                /**
                * Used to see if no pointer is on this input (so it is up).
                * This is READ ONLY.
                * @property isUp
                * @type boolean
                * @public
                */
                get: function () {
                    return this._isUp;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Input.prototype, "withinBounds", {
                /**
                * Check to see if any pointer is within the bounds of this input.
                * This is READ ONLY.
                * @property withinBounds
                * @type boolean
                * @public
                */
                get: function () {
                    return (this._withinBounds !== null);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Input.prototype, "outsideBounds", {
                /**
                * See if no pointers are within the bounds of this entity.
                * This is READ ONLY.
                * @property outsideBounds
                * @type boolean
                * @public
                */
                get: function () {
                    return this._outsideBounds;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Input.prototype, "isDragging", {
                /**
                * Returns a boolean indicating if this is currently dragging something.
                * This is READ ONLY.
                * @property isDragging
                * @type boolean
                * @public
                */
                get: function () { return (this._isDragging !== null); },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Input.prototype, "dragDistance", {
                /**
                * The drag distance that is used when dragging this object. See _dragDistance for more information.
                * @property dragDistance
                * @type number
                * @public
                */
                get: function () {
                    return this._dragDistance;
                },
                set: function (val) {
                    this._dragDistance = val;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Enables the dragging of this entity.
            * @method enableDrag
            * @param [snapToCenter=false] {boolean} If when dragging the Entity should snap to the center of the pointer.
            * @param [distance=1] {number} If when dragging the Entity should snap to numbers divisible by this amount.
            * @public
            */
            Input.prototype.enableDrag = function (snapToCenter, distance) {
                if (snapToCenter === void 0) { snapToCenter = false; }
                if (distance === void 0) { distance = 1; }
                if (this.enabled == false)
                    this.enabled = true;
                this._dragEnabled = true;
                this._dragSnapToCenter = snapToCenter;
                this._dragDistance = distance;
                this._isDragging = null;
            };
            /**
            * Disables the dragging of this entity.
            * @method disableDrag
            * @public
            */
            Input.prototype.disableDrag = function () {
                this._dragEnabled = false;
                this._isDragging = null;
            };
            /**
            * The update loop for the input.
            * @method update
            * @protected
            */
            Input.prototype.update = function () {
                if (this.enabled === false || !this.game || this.owner.active === false) {
                    return;
                }
                // Reset the temporary properties
                this._nowDown = null;
                this._nowUp = null;
                this._nowEntered = null;
                this._nowLeft = null;
                this._nowDragging = null;
                //Use the appropriate method of checking.
                if (Kiwi.DEVICE.touch) {
                    this._updateTouch();
                }
                else {
                    this._updateMouse();
                }
                //If the entity is dragging.
                if (this.isDragging) {
                    this._tempPoint = this.game.cameras.defaultCamera.transformPoint(this._isDragging.point);
                    if (this._dragSnapToCenter === false) {
                        this.owner.transform.x = Kiwi.Utils.GameMath.snapTo((this._tempPoint.x - this._box.hitboxOffset.x - this._distance.x), this._dragDistance);
                        this.owner.transform.y = Kiwi.Utils.GameMath.snapTo((this._tempPoint.y - this._box.hitboxOffset.y - this._distance.y), this._dragDistance);
                    }
                    else {
                        this.owner.transform.x = Kiwi.Utils.GameMath.snapTo((this._tempPoint.x - this._box.hitboxOffset.x - this._box.worldHitbox.width / 2), this._dragDistance);
                        this.owner.transform.y = Kiwi.Utils.GameMath.snapTo((this._tempPoint.y - this._box.hitboxOffset.y - this._box.worldHitbox.height / 2), this._dragDistance);
                    }
                }
            };
            /**
            * The update loop that gets executed when the game is using the touch manager.
            * @method _updateTouch
            * @private
            */
            Input.prototype._updateTouch = function () {
                for (var i = 0; i < this.game.input.touch.maximumPointers; i++) {
                    //if that pointer is active then see where it is
                    if (this.game.input.touch.fingers[i].active === true) {
                        this._evaluateTouchPointer(this.game.input.touch.fingers[i]);
                    }
                    else if (this.isDown === true && this._isDown.id === this.game.input.touch.fingers[i].id) {
                        this._nowUp = this.game.input.touch.fingers[i];
                    }
                    else if (this.isDown === false && this._nowUp === null && this.withinBounds === true && this._withinBounds.id === this.game.input.touch.fingers[i].id) {
                        this._nowUp = this.game.input.touch.fingers[i];
                    }
                }
                //Fire the events. LOTS OF CONDITIONS
                if (this._nowEntered !== null && this.withinBounds === false) {
                    this._withinBounds = this._nowEntered;
                    this._outsideBounds = false;
                    this._onEntered.dispatch(this.owner, this._nowEntered);
                }
                if (this._nowLeft !== null && this.withinBounds === true) {
                    this._withinBounds = null;
                    this._outsideBounds = true;
                    this._onLeft.dispatch(this.owner, this._nowLeft);
                }
                if (this._nowDown !== null && this.isDown === false) {
                    this._onDown.dispatch(this.owner, this._nowDown);
                    this._isDown = this._nowDown;
                    this._isUp = false;
                    this._withinBounds = this._nowDown;
                    this._outsideBounds = false;
                }
                if (this._dragEnabled == true && this.isDragging === false && this._nowDragging !== null) {
                    this._onDragStarted.dispatch(this.owner, this._nowDragging);
                    this._isDragging = this._nowDragging;
                }
                if (this._nowUp !== null) {
                    this._onUp.dispatch(this.owner, this._nowUp);
                    this._isDown = null;
                    this._isUp = true;
                    this._withinBounds = null;
                    this._outsideBounds = true;
                    //dispatch drag event
                    if (this.isDragging === true && this._isDragging.id == this._nowUp.id) {
                        this._isDragging = null;
                        this._onDragStopped.dispatch(this.owner, this._nowUp);
                    }
                }
            };
            /**
            * A private method for checking to see if a touch pointer should activate any events.
            * @method _evaluateTouchPointer
            * @param pointer {Kiwi.Input.Finger} The pointer you are checking against.
            * @private
            */
            Input.prototype._evaluateTouchPointer = function (pointer) {
                //if nothing isdown or what is down is the current pointer
                if (this.isDown === false || this._isDown.id === pointer.id) {
                    this._tempPoint = this.game.cameras.defaultCamera.transformPoint(pointer.point);
                    this._tempCircle.setTo(this._tempPoint.x, this._tempPoint.y, pointer.circle.diameter);
                    if (Kiwi.Geom.Intersect.circleToRectangle(this._tempCircle, this._box.worldHitbox).result) {
                        if (this.isDown === true && this._isDown.id === pointer.id || this.isDown === false && pointer.duration > 1) {
                            this._nowEntered = pointer;
                        }
                        if (this.isDown === false && pointer.frameDuration < 2) {
                            this._nowDown = pointer;
                        }
                        if (this._dragEnabled && this.isDragging == false && this.isDown == true) {
                            this._distance.x = this._tempPoint.x - this._box.worldHitbox.left;
                            this._distance.y = this._tempPoint.y - this._box.worldHitbox.top;
                            this._nowDragging = pointer;
                        }
                    }
                    else {
                        if (this.isDown === true) {
                            this._nowLeft = pointer;
                        }
                        else if (this.withinBounds === true && this._withinBounds.id == pointer.id) {
                            this._nowLeft = pointer;
                        }
                    }
                }
            };
            /**
            * The update loop that runs when the mouse manager is the method for interacting with the screen.
            * @method _updateMouse
            * @private
            */
            Input.prototype._updateMouse = function () {
                this._evaluateMousePointer(this.game.input.mouse.cursor);
                //dispatch the events
                if (this._nowLeft !== null) {
                    this._onLeft.dispatch(this.owner, this._nowLeft);
                }
                if (this._nowEntered !== null) {
                    this._onEntered.dispatch(this.owner, this._nowEntered);
                }
                if (this._nowDown !== null && this.isDown === false) {
                    this._onDown.dispatch(this.owner, this._nowDown);
                    this._isDown = this._nowDown;
                    this._isUp = false;
                }
                if (this._dragEnabled == true && this.isDragging === false && this._nowDragging !== null) {
                    this._onDragStarted.dispatch(this.owner, this._nowDragging);
                    this._isDragging = this._nowDragging;
                }
                if (this.isDown === true && this._nowUp !== null && this._isDown.id === this._nowUp.id) {
                    this._onUp.dispatch(this.owner, this._nowUp);
                    // Dispatch drag event
                    if (this.isDragging === true && this._isDragging.id == this._nowUp.id) {
                        this._isDragging = null;
                        this._onDragStopped.dispatch(this.owner, this._nowUp);
                    }
                    this._isDown = null;
                    this._isUp = true;
                }
            };
            /**
            * Evaluates where and what the mouse cursor is doing in relation to this box. Needs a little bit more love.
            * @method _evaluateMousePointer
            * @param pointer {Kiwi.Input.MouseCursor}
            * @private
            */
            Input.prototype._evaluateMousePointer = function (pointer) {
                this._tempPoint = this.game.cameras.defaultCamera.transformPoint(pointer.point);
                if (Kiwi.Geom.Intersect.pointToRectangle(this._tempPoint, this._box.worldHitbox).result) {
                    if (this._dragEnabled && this.isDragging === false) {
                        this._distance.x = this._tempPoint.x - this._box.worldHitbox.left;
                        this._distance.y = this._tempPoint.y - this._box.worldHitbox.top;
                    }
                    //  Has it just moved inside?
                    if (this.withinBounds === false) {
                        this._nowEntered = pointer;
                        this._withinBounds = pointer;
                        this._outsideBounds = false;
                        this._justEntered = true;
                    }
                }
                else {
                    //  It's outside the bounds now, was it previously in?
                    if (this.withinBounds === true && this.isDragging === false) {
                        this._nowLeft = pointer;
                        this._withinBounds = null;
                        this._outsideBounds = true;
                    }
                }
                //  Input is down (click/touch)
                if (pointer.isDown === true) {
                    //if is was a mouse, did it just enter?
                    if (this._justEntered) {
                        this._isDown = pointer;
                        this._isUp = false;
                        this._tempDragDisabled = true;
                    }
                    //  Within bounds? 
                    if (this.withinBounds === true && this.isDown === false && this._nowDown === null) {
                        this._nowDown = pointer;
                    }
                    if (this._dragEnabled === true && this.isDragging == false && this._tempDragDisabled === false) {
                        if (this.isDown == true) {
                            this._nowDragging = pointer;
                        }
                    }
                }
                else {
                    if (this._tempDragDisabled === true)
                        this._tempDragDisabled = false;
                    if (this.isDown === true) {
                        this._nowUp = pointer;
                    }
                }
                if (this._justEntered)
                    this._justEntered = false;
            };
            /**
            * Destroys the input.
            * @method destory
            * @public
            */
            Input.prototype.destroy = function () {
                _super.prototype.destroy.call(this);
                this.enabled = false;
                delete this._box;
                delete this._isDown;
                delete this._isUp;
                delete this._isDragging;
                delete this._dragEnabled;
                if (this._onDown)
                    this._onDown.dispose();
                delete this._onDown;
                if (this._onDragStarted)
                    this._onDragStarted.dispose();
                delete this._onDragStarted;
                if (this._onUp)
                    this._onUp.dispose();
                delete this._onUp;
                if (this._onLeft)
                    this._onLeft.dispose();
                delete this._onLeft;
                if (this._onEntered)
                    this._onEntered.dispose();
                delete this._onEntered;
                if (this._onDragStopped)
                    this._onDragStopped.dispose();
                delete this._onDragStopped;
                delete this._dragDistance;
            };
            return Input;
        })(Kiwi.Component);
        Components.Input = Input;
    })(Components = Kiwi.Components || (Kiwi.Components = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Components
*
*/
var Kiwi;
(function (Kiwi) {
    var Components;
    (function (Components) {
        /**
        * The Sound Component is a class to assist with the creation and management of multiple pieces of audio that may exist on a single Entity.
        * This class is NOT needed when dealing with audio but is instead can be used to assist in dealing with audio.
        *
        * @class Sound
        * @extends Kiwi.Component
        * @namespace Kiwi.Components
        * @constructor
        * @param parent {Any} Who the owner of the sound component is.
        * @return {Kiwi.Components.Sound}
        */
        var Sound = (function (_super) {
            __extends(Sound, _super);
            function Sound(parent) {
                _super.call(this, parent, 'Sound');
                this._audio = [];
            }
            /**
            * Returns the type of object that this is.
            * @method objType
            * @return {String} "Sound"
            * @public
            */
            Sound.prototype.objType = function () {
                return 'Sound';
            };
            /**
            * Creates a new audio segment on this component.
            *
            * @method addSound
            * @param name {string} The name for this audio file. This is how you will access the audio from this component and so it should be unique.
            * @param key {string} The piece of audio that you want to use.
            * @param [volume=1] {number} The volume that the audio should be set to.
            * @param [loop=false] {boolean} If the audio should keep play again when it finishes playing.
            * @return {Kiwi.Sound.Audio}
            * @public
            */
            Sound.prototype.addSound = function (name, key, volume, loop) {
                if (volume === void 0) { volume = 1; }
                if (loop === void 0) { loop = false; }
                if (this._validate(name) == true)
                    return;
                var audio = this.game.audio.add(key, volume, loop);
                this._audio[name] = audio;
                return audio;
            };
            /**
            * Removes the audio sementment with the name you have given.
            *
            * @method removeSound
            * @param name {string} The piece of audio you would like to remove.
            * @public
            */
            Sound.prototype.removeSound = function (name) {
                if (this._validate(name) == false)
                    return;
                this._audio[name].stop();
                this._audio[name].destroy();
                delete this._audio[name];
            };
            /**
            * Returns the Audio object for the sound that you pass.
            *
            * @method getSound
            * @param name {string} The piece of audio you would like to grab.
            * @return {Kiwi.Sound.Audio}
            * @public
            */
            Sound.prototype.getSound = function (name) {
                if (this._validate(name) == false)
                    return;
                return this._audio[name];
            };
            /**
            * This method is used to check to see if an audio segment with the name that is specified is on this component.
            *
            * @method _validate
            * @param name {string} The name of the audio segment you want to check exists.
            * @return {boolean}
            * @private
            */
            Sound.prototype._validate = function (name) {
                if (this._audio[name] === undefined) {
                    return false;
                }
                else {
                    return true;
                }
            };
            /**
            * Plays the audio that you specify.
            *
            * @method play
            * @param name {string} The name of the audio file you would like to play.
            * @public
            */
            Sound.prototype.play = function (name) {
                if (this._validate(name) == false)
                    return;
                this._audio[name].play();
            };
            /**
            * Stops the audio that you specify from playing.
            *
            * @method play
            * @param name {string} Name of the audio file you would like to stop.
            * @public
            */
            Sound.prototype.stop = function (name) {
                if (this._validate(name) == false)
                    return;
                this._audio[name].stop();
            };
            /**
            * Pauses the audio that you specify.
            *
            * @method play
            * @param name {string} The name of the audio you would like to pause.
            * @public
            */
            Sound.prototype.pause = function (name) {
                if (this._validate(name) == false)
                    return;
                this._audio[name].pause();
            };
            /**
            * Resumes the audio that you specify. Note: Audio can only resume if it was paused initially.
            *
            * @method play
            * @param name {string} The name of the audio you would like to resume.
            * @public
            */
            Sound.prototype.resume = function (name) {
                if (this._validate(name) == false)
                    return;
                this._audio[name].resume();
            };
            /**
            * Destroys this AudioComponent and all of the Audio objects it has.
            * @method destroy
            * @public
            */
            Sound.prototype.destroy = function () {
                _super.prototype.destroy.call(this);
                for (var key in this._audio) {
                    this._audio[key].stop();
                    this._audio[key].destroy();
                    delete this._audio[key];
                }
                delete this._audio;
            };
            return Sound;
        })(Kiwi.Component);
        Components.Sound = Sound;
    })(Components = Kiwi.Components || (Kiwi.Components = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Components
*
*/
var Kiwi;
(function (Kiwi) {
    var Components;
    (function (Components) {
        /**
        * Arcade Physics is an Optional Component that can be used when you are wanting to do basic physics collisions.
        * These have been ported from Flixel, so most function operate identically to the original flixel functions, though some
        * have been split into multiple functions. Generally where functions originally accepted
        * either groups or gameobjects within the same argument, the ported functions one or the other.
        * http://www.flixel.org/
        * http://www.adamatomic.com/
        *
        * @class ArcadePhysics
        * @constructor
        * @namespace Kiwi.Components
        * @param entity {Kiwi.Entity} The Entity that this ArcadePhysics should be used on.
        * @param box {Kiwi.Components.Box} The box component that holds the hitbox that should be used when resolving and calculating collisions.
        * @return {Kiwi.Components.ArcadePhysics}
        * @extends Kiwi.Component
        *
        * @author Adam 'Atomic' Saltsman, Flixel
        *
        */
        var ArcadePhysics = (function (_super) {
            __extends(ArcadePhysics, _super);
            function ArcadePhysics(entity, box) {
                _super.call(this, entity, 'ArcadePhysics');
                /**
                * A function that is to execute when this object overlaps with another.
                * @property _callbackFunction
                * @type Function
                * @default null
                * @private
                */
                this._callbackFunction = null;
                /**
                * The context that the callback method should have when it executes.
                * @property _callbackContext
                * @type Any
                * @private
                */
                this._callbackContext = null;
                this.parent = entity;
                this.box = box;
                this.transform = this.parent.transform;
                this.last = new Kiwi.Geom.Point(this.transform.worldX, this.transform.worldY);
                this.mass = 1.0;
                this.elasticity = 0.0;
                this.immovable = false;
                this.moves = true;
                this.touching = ArcadePhysics.NONE;
                this.wasTouching = ArcadePhysics.NONE;
                this.allowCollisions = ArcadePhysics.ANY;
                this.velocity = new Kiwi.Geom.Point();
                this.acceleration = new Kiwi.Geom.Point();
                this.drag = new Kiwi.Geom.Point();
                this.maxVelocity = new Kiwi.Geom.Point(10000, 10000);
                this.angularVelocity = 0;
                this.angularAcceleration = 0;
                this.angularDrag = 0;
                this.maxAngular = 10000;
            }
            /**
            * Returns a boolean indicating whether the or not the object is currently colliding on a particular side that is passed.
            * Use the collision constants (like LEFT, FLOOR, e.t.c) when passing sides.
            * @method isTouching
            * @param value [number] The collision constant of the side you want to check against.
            * @return {boolean} If the Object is currently colliding on that side or not.
            * @public
            */
            ArcadePhysics.prototype.isTouching = function (value) {
                return (this.touching & value) == value;
            };
            /**
            * Whether the object should collide with other objects or not.
            * For more control over what directions the object will collide from, use collision constants (like LEFT, FLOOR, etc)
            * and set the value of allowCollisions directly.
            * @method solid
            * @param [value] {boolean} If left empty, this will then just toggle between ANY and NONE.
            * @return {boolean} If Object is currently solid or not.
            * @public
            */
            ArcadePhysics.prototype.solid = function (value) {
                if (value !== undefined) {
                    if (value)
                        this.allowCollisions = ArcadePhysics.ANY;
                    else
                        this.allowCollisions = ArcadePhysics.NONE;
                }
                return (this.allowCollisions & ArcadePhysics.ANY) > ArcadePhysics.NONE;
            };
            /**
            * Sets up a callback function that will run when this object overlaps with another.
            * When the method is dispatched it will have TWO arguments.
            * One - The parent / entity of this ArcadePhysics.
            * Two - The GameObject that the collision occured with.
            *
            * @method setCallback
            * @param callbackFunction {Function} The method that is to be executed whe a overlap occurs.
            * @param callbackContext {Any} The context that the method is to be called in.
            * @public
            */
            ArcadePhysics.prototype.setCallback = function (callbackFunction, callbackContext) {
                this._callbackFunction = callbackFunction;
                this._callbackContext = callbackContext;
            };
            /**
            * Sets the parent's rotation to be equal to the trajectory of the
            * velocity of the physics component. Note that rotation 0 corresponds
            * to pointing directly to the right.
            * @method rotateToVelocity
            * @return {number} New rotation value
            * @public
            * @since 1.3.0
            */
            ArcadePhysics.prototype.rotateToVelocity = function () {
                var result = Math.atan2(this.velocity.y, this.velocity.x);
                this.transform.rotation = result;
                return result;
            };
            /*
            *---------------
            * Seperation Code
            *---------------
            */
            /**
            * A static method for seperating two normal GameObjects on both the X and Y Axis's.
            * Both objects need to have both an ArcadePhysics Component and a Box component in order for the separate process to succeed.
            * This method is not recommended to be directly used but instead use a 'collide/overlaps' method instead.
            *
            * @method seperate
            * @static
            * @param object1 {Kiwi.Entity} The first GameObject you would like to seperate.
            * @param object2 {Kiwi.Entity} The second GameObject you would like to seperate from the first.
            * @return {boolean}
            * @public
            */
            ArcadePhysics.separate = function (object1, object2) {
                var separatedX = this.separateX(object1, object2);
                var separatedY = this.separateY(object1, object2);
                return separatedX || separatedY;
            };
            /**
            * Separates two passed GameObjects on the x-axis.
            * Both objects need to have both an ArcadePhysics Component and a Box component in order for the separate process to succeed.
            * This method is not recommended to be directly used but instead use a 'collide/overlaps' method instead.
            *
            * @method seperateX
            * @param object1 {Kiwi.Entity} The first GameObject.
            * @param object2 {Kiwi.Entity} The second GameObject.
            * @return {boolean} Whether the objects in fact touched and were separated along the X axis.
            * @static
            * @public
            */
            ArcadePhysics.separateX = function (object1, object2) {
                //Get the Physics Components.
                var phys1 = object1.components.getComponent("ArcadePhysics");
                var phys2 = object2.components.getComponent("ArcadePhysics");
                //Can they even be sseparatated? two immovable objects
                if (phys1.immovable && phys2.immovable)
                    return false;
                //First, get the two object deltas
                var overlap = 0;
                var obj1delta = phys1.transform.worldX - phys1.last.x;
                var obj2delta = phys2.transform.worldX - phys2.last.x;
                //Are they the same?
                if (obj1delta == obj2delta)
                    return false;
                //Check if the X hulls actually overlap
                var obj1deltaAbs = (obj1delta > 0) ? obj1delta : -obj1delta;
                var obj2deltaAbs = (obj2delta > 0) ? obj2delta : -obj2delta;
                //Get the world hitboxes.
                var box1 = phys1.box.worldHitbox;
                var box2 = phys2.box.worldHitbox;
                //Where they are now using previous y axis's.
                var obj1rect = new Kiwi.Geom.Rectangle(box1.x - ((obj1delta > 0) ? obj1delta : 0), phys1.last.y + phys1.box.hitboxOffset.y, box1.width + ((obj1delta > 0) ? obj1delta : -obj1delta), box1.height);
                var obj2rect = new Kiwi.Geom.Rectangle(box2.x - ((obj2delta > 0) ? obj2delta : 0), phys2.last.y + phys2.box.hitboxOffset.y, box2.width + ((obj2delta > 0) ? obj2delta : -obj2delta), box2.height);
                //Could also use Kiwi.Geom.Intersect.rectangleToRectangle here...
                if ((obj1rect.x + obj1rect.width > obj2rect.x) && (obj1rect.x < obj2rect.x + obj2rect.width) && (obj1rect.y + obj1rect.height > obj2rect.y) && (obj1rect.y < obj2rect.y + obj2rect.height)) {
                    var maxOverlap = obj1deltaAbs + obj2deltaAbs + ArcadePhysics.OVERLAP_BIAS;
                    if (obj1delta > obj2delta) {
                        overlap = box1.x + box1.width - box2.x;
                        if ((overlap > maxOverlap) || !(phys1.allowCollisions & ArcadePhysics.RIGHT) || !(phys2.allowCollisions & ArcadePhysics.LEFT)) {
                            overlap = 0;
                        }
                        else {
                            phys1.touching |= ArcadePhysics.RIGHT;
                            phys2.touching |= ArcadePhysics.LEFT;
                        }
                    }
                    else {
                        overlap = box1.x - box2.width - box2.x;
                        if ((-overlap > maxOverlap) || !(phys1.allowCollisions & ArcadePhysics.LEFT) || !(phys2.allowCollisions & ArcadePhysics.RIGHT)) {
                            overlap = 0;
                        }
                        else {
                            phys1.touching |= ArcadePhysics.LEFT;
                            phys2.touching |= ArcadePhysics.RIGHT;
                        }
                    }
                }
                if (overlap != 0) {
                    //Get the average velocity
                    var obj1v = phys1.velocity.x;
                    var obj2v = phys2.velocity.x;
                    if (!phys1.immovable && !phys2.immovable) {
                        overlap *= 0.5;
                        phys1.transform.x = phys1.transform.x - overlap;
                        phys2.transform.x = phys2.transform.x + overlap;
                        var obj1velocity = Math.sqrt((obj2v * obj2v * phys2.mass) / phys1.mass) * ((obj2v > 0) ? 1 : -1);
                        var obj2velocity = Math.sqrt((obj1v * obj1v * phys1.mass) / phys2.mass) * ((obj1v > 0) ? 1 : -1);
                        var average = (obj1velocity + obj2velocity) * 0.5;
                        obj1velocity -= average;
                        obj2velocity -= average;
                        phys1.velocity.x = average + obj1velocity * phys1.elasticity;
                        phys2.velocity.x = average + obj2velocity * phys2.elasticity;
                    }
                    else if (!phys1.immovable) {
                        phys1.transform.x = phys1.transform.x - overlap;
                        phys1.velocity.x = obj2v - obj1v * phys1.elasticity;
                    }
                    else if (!phys2.immovable) {
                        phys2.transform.x = phys2.transform.x + overlap;
                        phys2.velocity.x = obj1v - obj2v * phys2.elasticity;
                    }
                    return true;
                }
                return false;
            };
            /**
            * Separates two GameObject on the y-axis. This method is executed from the 'separate' method.
            * Both objects need to have both an ArcadePhysics Component and a Box component in order for the separate process to succeed.
            * This method is not recommended to be directly used but instead use a 'collide/overlaps' method instead.
            *
            * @method seperateY
            * @param object1 {Kiwi.Entity} The first GameObject.
            * @param object2 {Kiwi.Entity} The second GameObject.
            * @return {boolean} Whether the objects in fact touched and were separated along the Y axis.
            * @static
            * @public
            */
            ArcadePhysics.separateY = function (object1, object2) {
                //Get the Arcade Physics Components
                var phys1 = object1.components.getComponent("ArcadePhysics");
                var phys2 = object2.components.getComponent("ArcadePhysics");
                //Can't separate two immovable objects
                if (phys1.immovable && phys2.immovable)
                    return false;
                var overlap = 0;
                var obj1delta = phys1.transform.worldY - phys1.last.y;
                var obj2delta = phys2.transform.worldY - phys2.last.y;
                //Do the deltas match?
                if (obj1delta == obj2delta)
                    return false;
                //Absolute Deltas
                var obj1deltaAbs = (obj1delta > 0) ? obj1delta : -obj1delta;
                var obj2deltaAbs = (obj2delta > 0) ? obj2delta : -obj2delta;
                //Hitboxes
                var box1 = phys1.box.worldHitbox;
                var box2 = phys2.box.worldHitbox;
                //Rectangles
                var obj1rect = new Kiwi.Geom.Rectangle(box1.x, box1.y - ((obj1delta > 0) ? obj1delta : 0), box1.width, box1.height + obj1deltaAbs);
                var obj2rect = new Kiwi.Geom.Rectangle(box2.x, box2.y - ((obj2delta > 0) ? obj2delta : 0), box2.width, box2.height + obj2deltaAbs);
                //Check for overlap
                if ((obj1rect.x + obj1rect.width > obj2rect.x) && (obj1rect.x < obj2rect.x + obj2rect.width) && (obj1rect.y + obj1rect.height > obj2rect.y) && (obj1rect.y < obj2rect.y + obj2rect.height)) {
                    var maxOverlap = obj1deltaAbs + obj2deltaAbs + ArcadePhysics.OVERLAP_BIAS;
                    if (obj1delta > obj2delta) {
                        overlap = box1.y + box1.height - box2.y;
                        if ((overlap > maxOverlap) || !(phys1.allowCollisions & ArcadePhysics.DOWN) || !(phys2.allowCollisions & ArcadePhysics.UP)) {
                            overlap = 0;
                        }
                        else {
                            phys1.touching |= ArcadePhysics.DOWN;
                            phys2.touching |= ArcadePhysics.UP;
                        }
                    }
                    else {
                        overlap = box1.y - box2.height - box2.y;
                        if ((-overlap > maxOverlap) || !(phys1.allowCollisions & ArcadePhysics.UP) || !(phys2.allowCollisions & ArcadePhysics.DOWN)) {
                            overlap = 0;
                        }
                        else {
                            phys1.touching |= ArcadePhysics.UP;
                            phys2.touching |= ArcadePhysics.DOWN;
                        }
                    }
                    //Then adjust their positions and velocities accordingly (if there was any overlap)
                    if (overlap != 0) {
                        var obj1v = phys1.velocity.y;
                        var obj2v = phys2.velocity.y;
                        if (!phys1.immovable && !phys2.immovable) {
                            overlap *= 0.5;
                            phys1.transform.y = phys1.transform.y - overlap;
                            phys2.transform.y = phys2.transform.y + overlap;
                            var obj1velocity = Math.sqrt((obj2v * obj2v * phys2.mass) / phys1.mass) * ((obj2v > 0) ? 1 : -1);
                            var obj2velocity = Math.sqrt((obj1v * obj1v * phys1.mass) / phys2.mass) * ((obj1v > 0) ? 1 : -1);
                            var average = (obj1velocity + obj2velocity) * 0.5;
                            obj1velocity -= average;
                            obj2velocity -= average;
                            phys1.velocity.y = average + obj1velocity * phys1.elasticity;
                            phys2.velocity.y = average + obj2velocity * phys2.elasticity;
                        }
                        else if (!phys1.immovable) {
                            phys1.transform.y = phys1.transform.y - overlap;
                            phys1.velocity.y = obj2v - obj1v * phys1.elasticity;
                            //This is special case code that handles cases like horizontal moving platforms you can ride
                            if (object2.active && phys2.moves && (obj1delta > obj2delta))
                                phys1.transform.x = phys1.transform.worldX + object2.transform.worldX - phys2.last.x;
                        }
                        else if (!phys2.immovable) {
                            phys2.transform.y = phys2.transform.y + overlap;
                            phys2.velocity.y = obj1v - obj2v * phys2.elasticity;
                            //This is special case code that handles cases like horizontal moving platforms you can ride
                            if (object1.active && phys1.moves && (obj1delta < obj2delta))
                                phys2.transform.x = phys2.transform.worldX + object1.transform.worldX - phys1.last.x;
                        }
                        return true;
                    }
                }
                return false;
            };
            /*
            *---------------
            * Seperation of Tiles Methods
            *---------------
            */
            /**
            * Separates a GameObject from a series of passed Tiles that lie on a TileMapLayer.
            * The gameobject needs to have a Box Component and an ArcadePhysics Component.
            * This method is not recommended to be directly used but instead use the 'overlapsTiles' method instead.
            *
            * @method separateTiles
            * @param object {Kiwi.Entity} The GameObject you are wanting to separate from a tile.
            * @param layer {Kiwi.GameObjects.Tilemap.TileMapLayer} The TileMapLayer that the tiles belong on.
            * @param tiles {Array}
            * @return {Boolean} If any separation occured.
            * @public
            * @static
            */
            ArcadePhysics.separateTiles = function (object, layer, tiles) {
                //Physics Component Found?
                if (object.components.hasComponent("ArcadePhysics") == false)
                    return false;
                //Immovable?
                if (object.components.getComponent("ArcadePhysics").immovable)
                    return false;
                var sepX = false;
                var sepY = false;
                for (var i = 0; i < tiles.length; i++) {
                    var tile = tiles[i];
                    if (!sepX)
                        sepX = this.separateTilesX(object, layer, tile);
                    if (!sepY)
                        sepY = this.separateTilesY(object, layer, tile);
                }
                return sepX || sepY;
            };
            /**
            * Separates a GameObjects from an Array of Tiles on the x-axis.
            * @method separateTilesX
            * @param object {Kiwi.Entity} The GameObject you are wanting to separate from a tile.
            * @param layer {Kiwi.GameObjects.Tilemap.TileMapLayer} The TileMapLayer that the tiles belong on.
            * @param tile {Object} An Object containing the information (x/y/tiletypr) about the tile that is being overlapped.
            * @return {Boolean} If any separation occured.
            * @public
            * @static
            */
            ArcadePhysics.separateTilesX = function (object, layer, tile) {
                //Get Physics
                var phys1 = object.components.getComponent("ArcadePhysics");
                var phys2 = layer.components.getComponent("ArcadePhysics");
                //First, get the two object deltas
                var obj1delta = phys1.transform.worldX - phys1.last.x;
                var obj2delta = phys2.transform.worldX - phys2.last.x;
                //If they moved the same amount.
                if (obj1delta == obj2delta)
                    return false;
                //Absolute Delta and Overlap
                var obj1deltaAbs = (obj1delta > 0) ? obj1delta : -obj1delta;
                var obj2deltaAbs = (obj2delta > 0) ? obj2delta : -obj2delta;
                var overlap = 0;
                var maxOverlap = obj1deltaAbs + obj2deltaAbs + ArcadePhysics.OVERLAP_BIAS;
                //Quick References
                var box1 = phys1.box.worldHitbox;
                var tileTypes = layer.tilemap.tileTypes;
                var tData = layer.tileData;
                //Box of the GameObject
                var x = phys2.transform.worldX + tile.x;
                var obj1rect = new Kiwi.Geom.Rectangle(box1.x - ((obj1delta > 0) ? obj1delta : 0), phys1.last.y + phys1.box.hitboxOffset.y, box1.width + ((obj1delta > 0) ? obj1delta : -obj1delta), box1.height);
                var obj2rect = new Kiwi.Geom.Rectangle(x - ((obj2delta > 0) ? obj2delta : 0), phys2.last.y + tile.y, layer.tileWidth + ((obj2delta > 0) ? obj2delta : -obj2delta), layer.tileHeight);
                //Check to see if they overlap
                if ((obj1rect.x + obj1rect.width > obj2rect.x) && (obj1rect.x < obj2rect.x + obj2rect.width) && (obj1rect.y - 1 + obj1rect.height > obj2rect.y) && (obj1rect.y - 1 < obj2rect.y + obj2rect.height)) {
                    //Which way the delta is going
                    if (obj1delta > obj2delta) {
                        overlap = box1.x + box1.width - x;
                        if ((overlap > maxOverlap) || !(phys1.allowCollisions & ArcadePhysics.RIGHT) || !(tileTypes[tData[tile.index]].allowCollisions & ArcadePhysics.LEFT)) {
                            overlap = 0;
                        }
                        else {
                            phys1.touching |= ArcadePhysics.RIGHT;
                        }
                    }
                    else {
                        overlap = box1.x - layer.tileWidth - x;
                        if ((-overlap > maxOverlap) || !(phys1.allowCollisions & ArcadePhysics.LEFT) || !(tileTypes[tData[tile.index]].allowCollisions & ArcadePhysics.RIGHT)) {
                            overlap = 0;
                        }
                        else {
                            phys1.touching |= ArcadePhysics.LEFT;
                        }
                    }
                    //Resolve the Collision
                    if (overlap != 0) {
                        var obj1v = phys1.velocity.x;
                        var obj2v = phys2.velocity.x;
                        phys1.transform.x = phys1.transform.x - overlap;
                        phys1.velocity.x = obj2v - obj1v * phys1.elasticity;
                        return true;
                    }
                }
                return false;
            };
            /**
            * Separates a GameObject from a tiles on the y-axis.
            * @method separateTilesY
            * @param object {Kiwi.Entity} The GameObject you are wanting to separate from a tile.
            * @param layer {Kiwi.GameObjects.Tilemap.TileMapLayer} The TileMapLayer that the tiles belong on.
            * @param tiles {Object} An Object representing the Tile which we are checking to see any overlaps occurs.
            * @return {Boolean} If any separation occured.
            * @public
            * @static
            */
            ArcadePhysics.separateTilesY = function (object, layer, tile) {
                //Get the physics.
                var phys1 = object.components.getComponent("ArcadePhysics");
                var phys2 = layer.components.getComponent("ArcadePhysics");
                //First, get the two object deltas
                var obj1delta = phys1.transform.worldY - phys1.last.y;
                var obj2delta = phys2.transform.worldY - phys2.last.y;
                //Have they moved the same amount?
                if (obj1delta == obj2delta)
                    return false;
                //Absolute Delta and Max Overlap
                var obj1deltaAbs = (obj1delta > 0) ? obj1delta : -obj1delta;
                var obj2deltaAbs = (obj2delta > 0) ? obj2delta : -obj2delta;
                var overlap = 0;
                var maxOverlap = obj1deltaAbs + obj2deltaAbs + ArcadePhysics.OVERLAP_BIAS;
                var box1 = phys1.box.worldHitbox;
                var tileTypes = layer.tilemap.tileTypes;
                var tData = layer.tileData;
                var y = layer.transform.worldY + tile.y;
                //Rectangles 
                var obj1rect = new Kiwi.Geom.Rectangle(box1.x, box1.y - ((obj1delta > 0) ? obj1delta : 0), box1.width, box1.height + obj1deltaAbs);
                var obj2rect = new Kiwi.Geom.Rectangle(phys2.transform.worldX + tile.x, y - ((obj2delta > 0) ? obj2delta : 0), layer.tileWidth, layer.tileHeight + obj2deltaAbs);
                //Check if they overlap
                if ((obj1rect.x + obj1rect.width > obj2rect.x) && (obj1rect.x < obj2rect.x + obj2rect.width) && (obj1rect.y + obj1rect.height > obj2rect.y) && (obj1rect.y < obj2rect.y + obj2rect.height)) {
                    if (obj1delta > obj2delta) {
                        overlap = box1.y + box1.height - y;
                        if ((overlap > maxOverlap) || !(phys1.allowCollisions & ArcadePhysics.DOWN) || !(tileTypes[tData[tile.index]].allowCollisions & ArcadePhysics.UP)) {
                            overlap = 0;
                        }
                        else {
                            phys1.touching |= ArcadePhysics.DOWN;
                        }
                    }
                    else {
                        overlap = box1.y - layer.tileHeight - y;
                        if ((-overlap > maxOverlap) || !(phys1.allowCollisions & ArcadePhysics.UP) || !(tileTypes[tData[tile.index]].allowCollisions & ArcadePhysics.DOWN)) {
                            overlap = 0;
                        }
                        else {
                            phys1.touching |= ArcadePhysics.UP;
                        }
                    }
                    //Resolve the Collision
                    if (overlap != 0) {
                        var obj1v = phys1.velocity.y;
                        var obj2v = phys2.velocity.y;
                        phys1.transform.y = phys1.transform.y - overlap;
                        phys1.velocity.y = obj2v - obj1v * phys1.elasticity;
                        return true;
                    }
                }
                return false;
            };
            /*
            *---------------
            * Instance Functions
            *---------------
            */
            /**
            * A method to check to see if any Tiles with in this parent TileMapLayer overlaps with a GameObject passed.
            * If seperateObjects is true it will seperate the two entities based on their bounding box.
            * ONLY works if the parent of the ArcadePhysics component which is calling this method is a TileMapLayer.
            * Note: The GameObject passed must contain a box component and only if you want to separate the two objects must is ALSO contain an ArcadePhysics component.
            *
            * @method overlapsTiles
            * @param gameObject {Kiwi.Entity} The GameObject you would like to separate with this one.
            * @param [separateObjects=false] {Boolean} If you want the GameObject to be separated from any tile it collides with.
            * @param [collisionType=ANY] {Number} If you want the GameObject to only check for collisions from a particular side of tiles. ANY by default.
            * @return {Boolean} If any gameobject overlapped.
            * @public
            */
            ArcadePhysics.prototype.overlapsTiles = function (gameObject, separateObjects, collisionType) {
                if (separateObjects === void 0) { separateObjects = false; }
                if (collisionType === void 0) { collisionType = Kiwi.Components.ArcadePhysics.ANY; }
                //Are we a tilemaplayer?
                if (this.parent.childType() !== Kiwi.TILE_LAYER)
                    return false;
                var tiles = this.parent.getOverlappingTiles(gameObject, collisionType);
                if (tiles.length > 0) {
                    if (separateObjects)
                        ArcadePhysics.separateTiles(gameObject, this.parent, tiles);
                    return true;
                }
                else {
                    return false;
                }
            };
            /**
            * A method to check to see if the parent of this physics component overlaps with another Kiwi.Entity.
            * If seperateObjects is true it will seperate the two entities based on their bounding box.
            * Note: The GameObject passed must contain a box component and only if you want to separate the two objects must is ALSO contain an ArcadePhysics component.
            * Also: Not to be used for separation from tiles.
            *
            * @method overlaps
            * @param gameObject {Kiwi.Entity}
            * @param [seperateObjects=false] {boolean}
            * @return {boolean}
            * @public
            */
            ArcadePhysics.prototype.overlaps = function (gameObject, separateObjects) {
                if (separateObjects === void 0) { separateObjects = false; }
                if (gameObject.components.hasComponent('Box') == false)
                    return;
                var box = gameObject.components.getComponent('Box');
                var result = (box.worldHitbox.x + box.worldHitbox.width > this.box.worldHitbox.x) && (box.worldHitbox.x < this.box.worldHitbox.x + this.box.worldHitbox.width) &&
                    (box.worldHitbox.y + box.worldHitbox.height > this.box.worldHitbox.y) && (box.worldHitbox.y < this.box.worldHitbox.y + this.box.worldHitbox.height);
                if (result) {
                    if (separateObjects)
                        ArcadePhysics.separate(this.owner, gameObject);
                    if (this._callbackFunction !== null && this._callbackContext !== null) {
                        this._callbackFunction.call(this._callbackContext, this.owner, gameObject);
                    }
                }
                return result;
            };
            /**
            * A method to check to see if the parent of this physics component overlaps with another individual in a Kiwi Group.
            *
            * @method overlapsGroup
            * @param group {Kiwi.Group}
            * @param [seperateObjects=false] {boolean}
            * @return { boolean } If any object in the group overlapped with the GameObject or not.
            * @public
            */
            ArcadePhysics.prototype.overlapsGroup = function (group, separateObjects) {
                if (separateObjects === void 0) { separateObjects = false; }
                var results = false;
                for (var i = 0; i < group.members.length; i++) {
                    if (group.members[i].childType() === Kiwi.GROUP) {
                        //recursively check overlap
                        this.overlapsGroup(group.members[i], separateObjects);
                    }
                    else {
                        //otherwise its an entity
                        if (this.overlaps(group.members[i], separateObjects)) {
                            if (this._callbackContext !== null && this._callbackFunction !== null)
                                this._callbackFunction.call(this._callbackContext, this.owner, group.members[i]);
                            results = true;
                        }
                    }
                }
                return results;
            };
            /**
            * A method to check to see if the parent of this physics component overlaps with any Entities that are held in an Array which is passed.
            *
            * @method overlapsArray
            * @param array {Array} The array of GameObjects you want to check.
            * @param [separateObjects=false] {boolean} If when the objects collide you want them to seperate outwards.
            * @return {boolean} If any overlapping occured or not.
            * @public
            */
            ArcadePhysics.prototype.overlapsArray = function (array, separateObjects) {
                if (separateObjects === void 0) { separateObjects = false; }
                var results = false;
                for (var i = 0; i < array.length; i++) {
                    if (typeof array[i].childType !== "undefined") {
                        if (array[i].childType() == Kiwi.GROUP) {
                            this.overlapsGroup(array[i], separateObjects);
                        }
                        else {
                            if (this.overlaps(array[i], separateObjects)) {
                                if (this._callbackFunction !== null && this._callbackContext !== null) {
                                    this._callbackFunction.call(this._callbackContext, this.owner, array[i]);
                                }
                                results = true;
                            }
                        }
                    }
                }
                return results;
            };
            /*
            *-------------
            * Motion Methods
            *-------------
            */
            /**
            * Computes the velocity based on the parameters passed.
            * @method computeVelocity
            * @static
            * @param velocity {number} The currently velocity.
            * @param [acceleration=0] {number} The acceleration of the item.
            * @param [drag=0] {number} The amount of drag effecting the item.
            * @param [max=10000] {number} The maximum velocity.
            * @return {Number} The new velocity
            * @public
            */
            ArcadePhysics.computeVelocity = function (velocity, acceleration, drag, max) {
                if (acceleration === void 0) { acceleration = 0; }
                if (drag === void 0) { drag = 0; }
                if (max === void 0) { max = 10000; }
                if (acceleration != 0)
                    velocity += acceleration * ArcadePhysics.updateInterval;
                else if (drag != 0) {
                    drag = drag * ArcadePhysics.updateInterval;
                    if (velocity - drag > 0)
                        velocity = velocity - drag;
                    else if (velocity + drag < 0)
                        velocity += drag;
                    else
                        velocity = 0;
                }
                if ((velocity != 0) && (max != 10000)) {
                    if (velocity > max)
                        velocity = max;
                    else if (velocity < -max)
                        velocity = -max;
                }
                return velocity;
            };
            /**
            * Updates the position of this object. Automatically called if the 'moves' parameter is true.
            * This called each frame during the update method.
            *
            * @method updateMotion
            * @private
            */
            ArcadePhysics.prototype.updateMotion = function () {
                var delta;
                var velocityDelta;
                //Update the motion calculated from rotation.
                velocityDelta = (ArcadePhysics.computeVelocity(this.angularVelocity, this.angularAcceleration, this.angularDrag, this.maxAngular) - this.angularVelocity) / 2;
                this.angularVelocity += velocityDelta;
                this.transform.rotation += this.angularVelocity * ArcadePhysics.updateInterval;
                this.angularVelocity += velocityDelta;
                //Update the motion on the x-axis.
                velocityDelta = (ArcadePhysics.computeVelocity(this.velocity.x, this.acceleration.x, this.drag.x, this.maxVelocity.x) - this.velocity.x) / 2;
                this.velocity.x += velocityDelta;
                delta = this.velocity.x * ArcadePhysics.updateInterval;
                this.velocity.x += velocityDelta;
                this.transform.x = this.transform.x + delta;
                //Update the motion on the y-axis.
                velocityDelta = (ArcadePhysics.computeVelocity(this.velocity.y, this.acceleration.y, this.drag.y, this.maxVelocity.y) - this.velocity.y) / 2;
                this.velocity.y += velocityDelta;
                delta = this.velocity.y * ArcadePhysics.updateInterval;
                this.velocity.y += velocityDelta;
                this.transform.y = this.transform.y + delta;
            };
            /**
            * The Update loop of the physics component
            * @method update
            * @public
            */
            ArcadePhysics.prototype.update = function () {
                //Flixel preupdate
                this.last.x = this.transform.worldX;
                this.last.y = this.transform.worldY;
                //Flixel postupdate
                if (this.moves)
                    this.updateMotion();
                this.wasTouching = this.touching;
                this.touching = ArcadePhysics.NONE;
            };
            /**
            * Removes all properties that refer to other objects or outside of this class in order to flag this object for garbage collection.
            * @method destroy
            * @public
            */
            ArcadePhysics.prototype.destroy = function () {
                _super.prototype.destroy.call(this);
                delete this.transform;
                delete this.owner;
                delete this._callbackContext;
                delete this._callbackFunction;
            };
            /**
            * The type of object that this is.
            * @method objType
            * @return {string} "ArcadePhysics"
            * @public
            */
            ArcadePhysics.prototype.objType = function () {
                return "ArcadePhysics";
            };
            /*
            *----------------
            * Static Functions
            *----------------
            */
            /*
            *----------------
            * Collide Functions - Maps to Overlaps
            *----------------
            */
            /**
            * A Static method to check to see if two objects collide or not. Returns a boolean indicating whether they overlaped or not.
            *
            * @method collide
            * @static
            * @public
            * @param gameObject1 {Kiwi.Entity} The first game object.
            * @param gameObject2 {Kiwi.Entity} The second game object.
            * @param [seperate=true] {boolean} If the two gameobjects should seperated when they collide.
            * @return {boolean}
            */
            ArcadePhysics.collide = function (gameObject1, gameObject2, seperate) {
                if (seperate === void 0) { seperate = true; }
                return ArcadePhysics.overlaps(gameObject1, gameObject2, seperate);
            };
            /**
            * A Static method to check to see if a single entity collides with a group of entities. Returns a boolean indicating whether they overlaped or not.
            *
            * @method collideGroup
            * @static
            * @public
            * @param gameObject {Kiwi.Entity} The entity you would like to check against.
            * @param group {Kiwi.Group} The Kiwi Group that you want to check the entity against.
            * @param [seperate=true] {boolean}
            * @return {boolean}
            * @public
            */
            ArcadePhysics.collideGroup = function (gameObject, group, seperate) {
                if (seperate === void 0) { seperate = true; }
                return ArcadePhysics.overlapsObjectGroup(gameObject, group, seperate);
            };
            /**
            * A Static method to check to see if a group of entities overlap with another group of entities. Returns a boolean indicating whether they overlaped or not.
            *
            * @method collideGroupGroup
            * @static
            * @public
            * @param group1 {Kiwi.Group} The first Kiwi Group that you want to check the entity against.
            * @param group2 {Kiwi.Group} The second Kiwi Group that you want to check the entity against.
            * @param [seperate=true] {boolean}
            * @return {boolean}
            */
            ArcadePhysics.collideGroupGroup = function (group1, group2, seperate) {
                if (seperate === void 0) { seperate = true; }
                return ArcadePhysics.overlapsGroupGroup(group1, group2, seperate);
            };
            /*
            *-------------
            * Overlap Static Method - Use's the Arcade Physics of one of the gameobjects passed.
            *-------------
            */
            /**
            * A Static method to that checks to see if two objects overlap. Returns a boolean indicating whether they did or not.
            *
            * @method overlaps
            * @static
            * @public
            * @param gameObject1 {Kiwi.Entity} The first game object.
            * @param gameObject2 {Kiwi.Entity} The second gameobject you are testing the first against.
            * @param [separateObjects=true] {boolean}
            * @return {boolean}
            */
            ArcadePhysics.overlaps = function (gameObject1, gameObject2, separateObjects) {
                if (separateObjects === void 0) { separateObjects = true; }
                var obj1Physics = gameObject1.components.getComponent("ArcadePhysics");
                return obj1Physics.overlaps(gameObject2, separateObjects);
            };
            /**
            * A Static method to that checks to see if a single object overlaps with a group of entities. Returns a boolean indicating whether they did or not.
            *
            * @method overlapsObjectGroup
            * @static
            * @param gameObject {Kiwi.Entity}
            * @param group {Kiwi.Group}
            * @param [seperateObjects=true] {boolean} If they overlap should the seperate or not
            * @return {boolean}
            * @public
            */
            ArcadePhysics.overlapsObjectGroup = function (gameObject, group, separateObjects) {
                if (separateObjects === void 0) { separateObjects = true; }
                var objPhysics = gameObject.components.getComponent("ArcadePhysics");
                return objPhysics.overlapsGroup(group, separateObjects);
            };
            /**
            * A Static method that checks to see if any objects in one group overlap with objects in another group.
            *
            * @method overlaps
            * @static
            * @param group1 {Kiwi.Group} The first group you would like to check against.
            * @param group2 {Kiwi.Group} The second group you would like to check against.
            * @param [seperate=true] {boolean} If they overlap should the seperate or not
            * @return {boolean}
            * @public
            */
            ArcadePhysics.overlapsGroupGroup = function (group1, group2, separateObjects) {
                if (separateObjects === void 0) { separateObjects = true; }
                var result = false;
                var members = group1.members;
                var i = 0;
                while (i < group1.members.length) {
                    if (members[i].childType() == Kiwi.GROUP) {
                        if (ArcadePhysics.overlapsGroupGroup(members[i++], group2, separateObjects))
                            result = true;
                    }
                    else {
                        if (ArcadePhysics.overlapsObjectGroup(members[i++], group2, separateObjects))
                            result = true;
                    }
                }
                return result;
            };
            /**
            * A Static method that checks to see if any objects from an Array collide with a Kiwi Group members.
            *
            * @method overlapsArrayGroup
            * @param array {Array} An array you want to check collide.
            * @param group {Kiwi.Group} A group of objects you want to check overlaps.
            * @param [seperateObjects=true] {Boolean} If when a collision is found the objects should seperate out.
            * @return {Boolean}
            * @static
            */
            ArcadePhysics.overlapsArrayGroup = function (array, group, separateObjects) {
                if (separateObjects === void 0) { separateObjects = true; }
                var result = false;
                //loop through the array 
                for (var i = 0; i < array.length; i++) {
                    if (typeof array[i].childType !== "undefined") {
                        if (array[i].childType() === Kiwi.GROUP) {
                            if (ArcadePhysics.overlapsGroupGroup(array[i], group, separateObjects))
                                result = true;
                        }
                        else {
                            if (ArcadePhysics.overlapsObjectGroup(array[i], group, separateObjects))
                                result = true;
                        }
                    }
                }
                return result;
            };
            /*
            *---------------
            * Static Constants
            *---------------
            */
            /**
            * How often the motion should be updated.
            * @property updateInterval
            * @static
            * @default 1 / 10
            * @type number
            * @public
            */
            ArcadePhysics.updateInterval = 1 / 10;
            /**
            * Generic value for "left" Used by <code>facing</code>, <code>allowCollisions</code>, and <code>touching</code>.
            * @property LEFT
            * @type number
            * @default 0x0001
            * @public
            * @static
            */
            ArcadePhysics.LEFT = 0x0001;
            /**
            * Generic value for "right" Used by <code>facing</code>, <code>allowCollisions</code>, and <code>touching</code>.
            * @property RIGHT
            * @type number
            * @default 0x0010
            * @public
            * @static
            */
            ArcadePhysics.RIGHT = 0x0010;
            /**
            * Generic value for "up" Used by <code>facing</code>, <code>allowCollisions</code>, and <code>touching</code>.
            * @property UP
            * @type number
            * @default 0x0100
            * @public
            * @static
            */
            ArcadePhysics.UP = 0x0100;
            /**
            * Generic value for "down" Used by <code>facing</code>, <code>allowCollisions</code>, and <code>touching</code>.
            * @property DOWN
            * @type number
            * @default 0x1000
            * @public
            * @static
            */
            ArcadePhysics.DOWN = 0x1000;
            /**
            * Special-case constant meaning no collisions, used mainly by <code>allowCollisions</code> and <code>touching</code>.
            * @property NONE
            * @type number
            * @default 0
            * @public
            * @static
            */
            ArcadePhysics.NONE = 0;
            /**
            * Special-case constant meaning up, used mainly by <code>allowCollisions</code> and <code>touching</code>.
            * @property CEILING
            * @type number
            * @default 0x0100
            * @public
            * @static
            */
            ArcadePhysics.CEILING = ArcadePhysics.UP;
            /**
            * Special-case constant meaning down, used mainly by <code>allowCollisions</code> and <code>touching</code>.
            * @property FLOOR
            * @type number
            * @default 0x1000
            * @public
            * @static
            */
            ArcadePhysics.FLOOR = ArcadePhysics.DOWN;
            /**
            * Special-case constant meaning only the left and right sides, used mainly by <code>allowCollisions</code> and <code>touching</code>.
            * @property WALL
            * @type number
            * @default 0x0011
            * @public
            * @static
            */
            ArcadePhysics.WALL = ArcadePhysics.LEFT | ArcadePhysics.RIGHT;
            /**
            * Special-case constant meaning any direction, used mainly by <code>allowCollisions</code> and <code>touching</code>.
            * @property ANY
            * @type number
            * @default 0x1111
            * @public
            * @static
            */
            ArcadePhysics.ANY = ArcadePhysics.LEFT | ArcadePhysics.RIGHT | ArcadePhysics.UP | ArcadePhysics.DOWN;
            /**
            * Handy constant used during collision resolution (see <code>separateX()</code> and <code>separateY()</code>).
            * @property OVERLAP_BIAS
            * @type number
            * @default 4
            * @public
            * @static
            */
            ArcadePhysics.OVERLAP_BIAS = 4;
            return ArcadePhysics;
        })(Kiwi.Component);
        Components.ArcadePhysics = ArcadePhysics;
    })(Components = Kiwi.Components || (Kiwi.Components = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Files
*
*/
var Kiwi;
(function (Kiwi) {
    var Files;
    (function (Files) {
        /**
        * Used for the loading of files and game assets. This usually happens when a State is at the 'loading' stage (executing the 'preload' method).
        *
        * @class Loader
        * @namespace Kiwi.Files
        * @constructor
        * @param game {Kiwi.Game} The game that this loader belongs to.
        * @return {Kiwi.Files.Loader} This Object
        *
        */
        var Loader = (function () {
            function Loader(game) {
                /**
                * A flag indicating if the files inside the file queue are loading or not.
                *
                * @property _fileQueueLoading
                * @type Boolean
                * @default false
                * @since 1.2.0
                * @private
                */
                this._queueLoading = false;
                /**
                * When 'calculateBytes' is true the percentLoaded will be the `bytesLoaded / bytesTotal`.
                * Otherwise it is based on the `filesLoaded / numberOfFilesToLoad`.
                *
                * @property percentLoaded
                * @type Number
                * @since 1.2.0
                * @readOnly
                * @public
                */
                this.percentLoaded = 0;
                /**
                * When enabled, files which can be loaded in parallel (those which are loaded via tags)
                * will be loaded at the same time.
                *
                * The default behaviour is to have the files loading in a queued fashion instead of one after another.
                *
                * @property enableParallelLoading
                * @type Boolean
                * @default false
                * @since 1.2.0
                * @public
                */
                this.enableParallelLoading = false;
                /**
                * The number of files in the file queue that have been updated.
                *
                * @property _completeFiles
                * @type number
                * @default 0
                * @private
                */
                this._completedFiles = 0;
                /**
                * -----------------------------
                * Bytes Loaded Methods
                * -----------------------------
                **/
                /**
                * If the number of bytes for each file should be calculated before the queue starts loading.
                * If true each file in the queue makes a XHR HEAD request first to get the total values.
                *
                * @property _calculateBytes
                * @type Boolean
                * @private
                */
                this._calculateBytes = false;
                /**
                * The index of the current file in the filelist thats size is being retrieved.
                * @property _currentFileIndex
                * @type number
                * @private
                */
                this._currentFileIndex = 0;
                /**
                * Total file size (in bytes) of all files in the queue to be loaded.
                *
                * @property _bytesTotal
                * @type Number
                * @private
                */
                this._bytesTotal = 0;
                /**
                * The number of bytes loaded of files in the file queue.
                *
                * @property _bytesLoaded
                * @type Number
                * @private
                */
                this._bytesLoaded = 0;
                this.game = game;
            }
            /**
            * The type of object this is.
            * @method objType
            * @return {String} "Loader"
            * @public
            */
            Loader.prototype.objType = function () {
                return "Loader";
            };
            Object.defineProperty(Loader.prototype, "queueLoading", {
                /**
                * READ ONLY: A flag indicating if the files inside the file queue are loading or not.
                *
                * @property fileQueueLoading
                * @type Boolean
                * @default false
                * @readOnly
                * @since 1.2.0
                * @public
                */
                get: function () {
                    return this._queueLoading;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * The boot method is executed when the DOM has successfully loaded and we can now start the game.
            * @method boot
            * @public
            */
            Loader.prototype.boot = function () {
                this._loadingList = [];
                this._loadingParallel = [];
                this._loadingQueue = [];
                this.onQueueComplete = new Kiwi.Signal();
                this.onQueueProgress = new Kiwi.Signal();
            };
            /**
            * Starts loading all the files which are in the file queue.
            *
            * To accurately use the bytesLoaded or bytesTotal properties you will need to set the 'calculateBytes' boolean to true.
            * This may increase load times, as each file in the queue will firstly make XHR HEAD requests for information.
            *
            * When 'calculateBytes' is true the percentLoaded will be the `bytesLoaded / bytesTotal`.
            * Otherwise it is based on the `filesLoaded / numberOfFilesToLoad`.
            *
            * @method start
            * @param [calculateBytes] {Boolean} Setter for the 'calculateBytes' property.
            * @since 1.2.0
            * @public
            */
            Loader.prototype.start = function (calculateBytes) {
                if (calculateBytes === void 0) { calculateBytes = null; }
                if (calculateBytes !== null) {
                    this._calculateBytes = calculateBytes;
                }
                if (this._queueLoading) {
                    Kiwi.Log.warn('Kiwi.Files.Loader: Files in the queue are already being loaded');
                    return;
                }
                //Reset the number of bytes laoded
                this._bytesLoaded = 0;
                this._bytesTotal = 0;
                this.percentLoaded = 0;
                if (this._calculateBytes) {
                    this.calculateQueuedSize(this._startLoading, this);
                }
                else {
                    this._startLoading();
                }
            };
            /**
            * Loops through the file queue and starts the loading process.
            *
            * @method _startLoading
            * @private
            */
            Loader.prototype._startLoading = function () {
                //Any files to load?
                if (this._loadingList.length <= 0) {
                    Kiwi.Log.log('Kiwi.Files.Loader: No files are to load have been found.', '#loading');
                    this.onQueueProgress.dispatch(100, 0, null);
                    this.onQueueComplete.dispatch();
                    return;
                }
                //There are files to load
                var i = 0, file;
                while (i < this._loadingList.length) {
                    if (this._calculateBytes) {
                        this._loadingList[i].onProgress.add(this._updateFileListInformation, this);
                    }
                    this._sortFile(this._loadingList[i]);
                    this._loadingList[i].onComplete.addOnce(this._fileQueueUpdate, this);
                    i++;
                }
                this._queueLoading = true;
                this._bytesLoaded = 0;
                this._startLoadingQueue();
                this._startLoadingAllParallel();
                this._fileQueueUpdate(null, true);
            };
            /**
            * Adds a file to the queue of files to be loaded.
            * Files cannot be added whilst the queue is currently loading,
            * the file to add is currently loading, or has been loaded before.
            *
            * @method addFileToQueue
            * @param file {Kiwi.Files.File} The file to add.
            * @return {Boolean} If the file was added to the queue or not.
            * @since 1.2.0
            * @public
            */
            Loader.prototype.addFileToQueue = function (file) {
                if (this._queueLoading) {
                    Kiwi.Log.warn('Kiwi.Files.Loader: File cannot be added to the queue whilst the queue is currently loading.', '#loading', '#filequeue');
                    return false;
                }
                if (file.loading || file.complete) {
                    Kiwi.Log.warn('Kiwi.Files.Loader: File could not be added as it is currently loading or has already loaded.', '#loading', '#filequeue');
                    return false;
                }
                this._loadingList.push(file);
                return true;
            };
            /**
            * Removes a file from the file queue.
            * Files cannot be removed whilst the queue is loading.
            *
            * @method removeFileFromQueue
            * @param file {Kiwi.Files.File} The file to remove.
            * @return {Boolean} If the file was added to the queue or not.
            * @since 1.2.0
            * @public
            */
            Loader.prototype.removeFileFromQueue = function (file) {
                if (this._queueLoading) {
                    Kiwi.Log.warn('Kiwi.Files.Loader: File cannot be remove from the queue whilst the queue is currently loading.', '#loading', '#filequeue');
                    return false;
                }
                var index = this._loadingList.indexOf(file);
                if (index === -1) {
                    return false;
                }
                if (file.loading) {
                    Kiwi.Log.warn('Kiwi.Files.Loader: Cannot remove the file from the list as it is currently loading.', '#loading', '#filequeue');
                    return false;
                }
                this._loadingList.splice(index, 1);
                return true;
            };
            /**
            * Clears the file queue of all files.
            *
            * @method clearQueue
            * @since 1.2.0
            * @public
            */
            Loader.prototype.clearQueue = function () {
                if (!this._queueLoading) {
                    this._loadingList.length = 0;
                }
                else {
                    Kiwi.Log.error('Kiwi.Files.Loader: Cannot clear the file queue whilst the files are being loaded.', '#loading', '#filequeue');
                }
            };
            /**
            * Starts the process of loading a file outside of the regular queue loading process.
            * Callbacks for load completion need to be added onto the file via 'onComplete' Signal.
            *
            * @method loadFile
            * @public
            */
            Loader.prototype.loadFile = function (file) {
                if (file.loading || file.complete) {
                    Kiwi.Log.error('Kiwi.Files.Loader: Could not add file. File is already loading or has completed loading.');
                    return;
                }
                this._sortFile(file, true);
            };
            /**
            * Sorts a file and places it into either the 'loadingParallel' or 'loadingQueue'
            * depending on the method of loading it is using.
            *
            * @method _sortFile
            * @param file {Kiwi.Files.File}
            * @since 1.2.0
            * @private
            */
            Loader.prototype._sortFile = function (file, startLoading) {
                if (startLoading === void 0) { startLoading = false; }
                if (this.enableParallelLoading && file.loadInParallel) {
                    //Push into the tag loader queue
                    this._loadingParallel.push(file);
                    if (startLoading) {
                        this._startLoadingParallel(file);
                    }
                }
                else {
                    //Push into the xhr queue
                    this._loadingQueue.push(file);
                    if (startLoading) {
                        this._startLoadingQueue();
                    }
                }
            };
            /**
            * Called each time a file has processed whilst loading, or has just completed loading.
            *
            * Calculates the new number of bytes loaded and
            * the percentage of loading done by looping through all of the files.
            *
            * @method _updateFileListInformation
            * @private
            */
            Loader.prototype._updateFileListInformation = function () {
                var i = 0;
                this._completedFiles = 0;
                this._bytesLoaded = 0;
                while (i < this._loadingList.length) {
                    //Was the file loaded, but we have no bytes (must have used the tag loader) and we have their details?
                    if (this._loadingList[i].bytesLoaded === 0 && this._loadingList[i].success && this._loadingList[i].detailsReceived) {
                        this._bytesLoaded += this._loadingList[i].size;
                    }
                    else {
                        //Add the bytes loaded to the list 
                        this._bytesLoaded += this._loadingList[i].bytesLoaded;
                    }
                    //Calculate percentage
                    if (this._loadingList[i].complete) {
                        this._completedFiles++;
                    }
                    i++;
                }
                //Calculate the percentage depending on how accurate we can be.
                if (this._calculateBytes) {
                    this.percentLoaded = (this._bytesLoaded / this._bytesTotal) * 100;
                }
                else {
                    this.percentLoaded = (this._completedFiles / this._loadingList.length) * 100;
                }
            };
            /**
            * Executed by files when they have successfully been loaded.
            * This method checks to see if the files are in the file queue, and dispatches the appropriate events.
            *
            * @method _fileQueueUpdate
            * @param file {Kiwi.Files.File} The file which has been recently loaded.
            * @param [forceProgressCheck=false] {Boolean} If the progress of file loading should be checked, regardless of the file being in the queue or not.
            * @since 1.2.0
            * @private
            */
            Loader.prototype._fileQueueUpdate = function (file, forceProgressCheck) {
                if (forceProgressCheck === void 0) { forceProgressCheck = false; }
                //If the file loaded is in the loadingList
                if (!forceProgressCheck && this._loadingList.indexOf(file) === -1) {
                    return;
                }
                //Update the file information.
                this._updateFileListInformation();
                //Dispatch progress event.
                this.onQueueProgress.dispatch(this.percentLoaded, this.bytesLoaded, file);
                if (this._completedFiles >= this._loadingList.length) {
                    //Clear the file queue and dispatch the loaded event
                    this._queueLoading = false;
                    this.clearQueue();
                    this.onQueueComplete.dispatch();
                }
            };
            /**
            * Starts the loading process in the loadingQueue.
            * @method _startLoadingQueue
            * @return {Boolean}
            * @private
            * @since 1.2.0
            * @return {boolean} Whether the first file is loading
            */
            Loader.prototype._startLoadingQueue = function () {
                //Any files to load?
                if (this._loadingQueue.length <= 0) {
                    Kiwi.Log.log('Kiwi.Files.Loader: No queued files to load.', '#loading');
                    return false;
                }
                //Is the first file currently loading?
                if (this._loadingQueue[0].loading) {
                    return false;
                }
                //Attempt to load the file!
                this._loadingQueue[0].onComplete.addOnce(this._queueFileComplete, this, 1);
                this._loadingQueue[0].load();
                return true;
            };
            /**
            * Executed when a file in the 'loadingQueue' has been successfully loaded.
            * Removes the file from the loadingQueue and executes the '_startLoadingQueue' to start loading the next file.
            *
            * @method _queueFileComplete
            * @param file {Kiwi.Files.File}
            * @since 1.2.0
            * @private
            */
            Loader.prototype._queueFileComplete = function (file) {
                //Remove from the loadingQueue
                var index = this._loadingQueue.indexOf(file);
                if (index === -1) {
                    Kiwi.Log.warn("Something has gone wrong? The file which executed this method doesn't exist in the loadingQueue.", '#loading', '#error');
                    return;
                }
                this._loadingQueue.splice(index, 1);
                //Start loading the next file
                this._startLoadingQueue();
            };
            /**
            * Starts loading a file which can be loaded in parallel.
            * @method _startLoadingParallel
            * @param params file {Kiwi.Files.File}
            * @since 1.2.0
            * @private
            */
            Loader.prototype._startLoadingParallel = function (file) {
                if (!file.loading) {
                    file.onComplete.add(this._parallelFileComplete, this, 1);
                    file.load();
                }
            };
            /**
            * Starts loading all files which can be loaded in parallel.
            * @method _startLoadingAllParallel
            * @since 1.2.0
            * @private
            */
            Loader.prototype._startLoadingAllParallel = function () {
                var i = this._loadingParallel.length, file;
                while (i--) {
                    this._startLoadingParallel(this._loadingParallel[i]);
                }
            };
            /**
            * Executed when a file in the 'loadingParallel' lsit has been successfully loaded.
            * Removes the file from the list and get the fileQueue to check its progress.
            *
            * @method _parallelFileComplete
            * @param file {Kiwi.Files.File}
            * @since 1.2.0
            * @private
            */
            Loader.prototype._parallelFileComplete = function (file) {
                var index = this._loadingParallel.indexOf(file);
                if (index === -1) {
                    Kiwi.Log.warn("Something has gone wrong? The file which executed this method doesn't exist in the loadingParallel.", '#loading', '#error');
                    return;
                }
                this._loadingParallel.splice(index, 1);
            };
            Object.defineProperty(Loader.prototype, "bytesTotal", {
                /**
                * READ ONLY: Returns the total number of bytes for the files in the file queue.
                * Only contains a value if you use the 'calculateBytes' and are loading files
                * OR if you use the 'calculateQueuedSize' method.
                *
                * @property bytesTotal
                * @readOnly
                * @default 0
                * @since 1.2.0
                * @type Number
                * @public
                */
                get: function () {
                    return this._bytesTotal;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Loader.prototype, "bytesLoaded", {
                /**
                * READ ONLY: Returns the total number of bytes for the files in the file queue.
                *
                * If you are using this make sure you set the 'calculateBytes' property to true OR execute the 'calculateQueuedSize' method.
                * Otherwise files that are loaded via tags will not be accurate!
                *
                * @property bytesLoaded
                * @readOnly
                * @default 0
                * @since 1.2.0
                * @type Number
                * @public
                */
                get: function () {
                    return this._bytesLoaded;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Loops through the file queue and gets file information (filesize, ETag, filetype) for each.
            *
            * To get accurate information about the bytesLoaded, bytesTotal, and the percentLoaded
            * set the 'calculateBytes' property to true, as the loader will automatically execute this method before hand.
            *
            * Can only be executed when the file queue is not currently loading.
            *
            * @method calculateQueuedSize
            * @param callback {any}
            * @param [context=null] {any}
            * @public
            */
            Loader.prototype.calculateQueuedSize = function (callback, context) {
                if (context === void 0) { context = null; }
                //Is the queue currently loading files?
                if (this._queueLoading) {
                    Kiwi.Log.warn('Kiwi.Files.Loader: Cannot calculate the size of the files in the filequeue whilst they are loading. ');
                    return;
                }
                //Set the callbacks
                this.onSizeCallback = callback;
                this.onSizeContext = context;
                // Start the process
                this._currentFileIndex = 0;
                this._bytesTotal = 0;
                this._queueLoading = true;
                this._calculateNextFileSize();
            };
            /**
            * Checks to see if all the file sizes have been retrieved.
            * If so completes the "calculateQueuedSize" call.
            * Otherwise requests the next file's details.
            *
            * @method _calculateNextFileSize
            * @private
            */
            Loader.prototype._calculateNextFileSize = function () {
                if (this._currentFileIndex >= this._loadingList.length) {
                    this._queueLoading = false;
                    this.onSizeCallback.call(this.onSizeContext, this._bytesTotal);
                    ;
                    return;
                }
                var file = this._loadingList[this._currentFileIndex];
                //Have we already got the details for this file?
                if (file.detailsReceived) {
                    this._detailsReceived();
                }
                else {
                    var details = file.loadDetails(this._detailsReceived, this);
                    //Skip to the next file if the request could not be made.
                    //Shouldn't happen.
                    if (!details) {
                        this._detailsReceived();
                    }
                }
            };
            /**
            * Executed when by '_calculateNextFileSize' when the files information has been retrieved.
            * Adds its calculated size to the _bytesTotal and executes the 'nextFileSize' method.
            *
            * @method _detailsReceived
            * @private
            */
            Loader.prototype._detailsReceived = function () {
                var file = this._loadingList[this._currentFileIndex];
                if (file.detailsReceived) {
                    this._bytesTotal += file.size;
                }
                this._currentFileIndex++;
                this._calculateNextFileSize();
            };
            /**
            * -----------------------------
            * File Addition Methods
            * -----------------------------
            */
            /**
            * Creates a new file for an image and adds a the file to loading queue.
            * @method addImage
            * @param key {String} The key for the file.
            * @param url {String} The url of the image to load.
            * @param [width] {number} The width of the cell on the image to use once the image is loaded.
            * @param [height] {number} The height of the cell on the image to use once the image is loaded.
            * @param [offsetX] {number} An offset on the x axis of the cell.
            * @param [offsetY] {number} An offset of the y axis of the cell.
            * @param [storeAsGlobal=true] {boolean} If the image should be stored globally or not.
            * @return {Kiwi.Files.File} The file which was created.
            * @public
            */
            Loader.prototype.addImage = function (key, url, width, height, offsetX, offsetY, storeAsGlobal) {
                if (storeAsGlobal === void 0) { storeAsGlobal = true; }
                var params = {
                    type: Kiwi.Files.File.IMAGE,
                    key: null,
                    url: null,
                    fileStore: this.game.fileStore,
                    metadata: {}
                };
                if (Kiwi.Utils.Common.isObject(key)) {
                    var p = key;
                    params.key = p.key;
                    params.url = p.url;
                    params.metadata = {
                        width: p.width,
                        height: p.height,
                        offsetX: p.offsetX,
                        offsetY: p.offsetY
                    };
                    if (p.xhrLoading)
                        params.xhrLoading = p.xhrLoading; //forces blob loading
                    if (p.state)
                        params.state = p.state;
                    if (p.tags)
                        params.tags = p.tags;
                }
                else {
                    if (!storeAsGlobal && this.game.states.current) {
                        params.state = this.game.states.current;
                    }
                    params.key = key;
                    params.url = url;
                    params.metadata = {
                        width: width,
                        height: height,
                        offsetX: offsetX,
                        offsetY: offsetY
                    };
                }
                var file = new Kiwi.Files.TextureFile(this.game, params);
                this.addFileToQueue(file);
                return file;
            };
            /**
            * Creates a new file for a spritesheet and adds the file to the loading queue.
            * @method addSpriteSheet
            * @param key {String} The key for the file.
            * @param url {String} The url of the image to load.
            * @param frameWidth {number} The width of a single cell in the spritesheet.
            * @param frameHeight {number} The height of a single cell in the spritesheet.
            * @param [numCells] {number} The number of cells that are in this spritesheet.
            * @param [rows] {number} The number of cells that are in a row.
            * @param [cols] {number} The number of cells that are in a column.
            * @param [sheetOffsetX] {number} The offset of the whole spritesheet on the x axis.
            * @param [sheetOffsetY] {number} The offset of the whole spritesheet on the y axis.
            * @param [cellOffsetX] {number} The spacing between each cell on the x axis.
            * @param [cellOffsetY] {number} The spacing between each cell on the y axis.
            * @param [storeAsGlobal=true] {boolean}
            * @return {Kiwi.Files.File} The file which was created.
            * @public
            */
            Loader.prototype.addSpriteSheet = function (key, url, frameWidth, frameHeight, numCells, rows, cols, sheetOffsetX, sheetOffsetY, cellOffsetX, cellOffsetY, storeAsGlobal) {
                if (storeAsGlobal === void 0) { storeAsGlobal = true; }
                var params = {
                    type: Kiwi.Files.File.SPRITE_SHEET,
                    key: null,
                    url: null,
                    fileStore: this.game.fileStore,
                    metadata: {}
                };
                if (Kiwi.Utils.Common.isObject(key)) {
                    var p = key;
                    params.key = p.key;
                    params.url = p.url;
                    params.metadata = {
                        frameWidth: p.frameWidth,
                        frameHeight: p.frameHeight,
                        numCells: p.numCells,
                        rows: p.rows,
                        cols: p.cols,
                        sheetOffsetX: p.sheetOffsetX,
                        sheetOffsetY: p.sheetOffsetY,
                        cellOffsetX: p.cellOffsetX,
                        cellOffsetY: p.cellOffsetY
                    };
                    if (p.xhrLoading)
                        params.xhrLoading = p.xhrLoading; //forces blob loading
                    if (p.state)
                        params.state = p.state;
                    if (p.tags)
                        params.tags = p.tags;
                }
                else {
                    if (!storeAsGlobal && this.game.states.current) {
                        params.state = this.game.states.current;
                    }
                    params.key = key;
                    params.url = url;
                    params.metadata = {
                        frameWidth: frameWidth,
                        frameHeight: frameHeight,
                        numCells: numCells,
                        rows: rows,
                        cols: cols,
                        sheetOffsetX: sheetOffsetX,
                        sheetOffsetY: sheetOffsetY,
                        cellOffsetX: cellOffsetX,
                        cellOffsetY: cellOffsetY
                    };
                }
                var file = new Kiwi.Files.TextureFile(this.game, params);
                this.addFileToQueue(file);
                return file;
            };
            /**
            * Creates new file's for loading a texture atlas and adds those files to the loading queue.
            * @method addTextureAtlas
            * @param key {String} The key for the image file.
            * @param imageUrl {String} The url of the image to load.
            * @param jsonID {String} A key for the JSON file.
            * @param jsonURL {String} The url of the json file to load.
            * @param [storeAsGlobal=true] {Boolean} If hte files should be stored globally or not.
            * @return {Kiwi.Files.File} The file which was created.
            * @public
            */
            Loader.prototype.addTextureAtlas = function (key, imageURL, jsonID, jsonURL, storeAsGlobal) {
                if (storeAsGlobal === void 0) { storeAsGlobal = true; }
                var textureParams = {
                    type: Kiwi.Files.File.TEXTURE_ATLAS,
                    key: key,
                    url: imageURL,
                    fileStore: this.game.fileStore,
                    metadata: {
                        jsonID: jsonID
                    }
                };
                var jsonParams = {
                    type: Kiwi.Files.File.JSON,
                    key: jsonID,
                    url: jsonURL,
                    fileStore: this.game.fileStore,
                    metadata: {
                        imageID: key
                    }
                };
                if (!storeAsGlobal && this.game.states.current) {
                    textureParams.state = this.game.states.current;
                    jsonParams.state = this.game.states.current;
                }
                if (Kiwi.Utils.Common.isObject(key)) {
                    var p = key;
                    textureParams.key = p.textureAtlasKey;
                    textureParams.url = p.textureAtlasURL;
                    jsonParams.key = p.jsonKey;
                    jsonParams.url = p.jsonURL;
                    textureParams.metadata.jsonID = jsonParams.key;
                    jsonParams.metadata.imageID = textureParams.key;
                    if (p.state) {
                        textureParams.state = p.state;
                        jsonParams.state = p.state;
                    }
                    if (p.xhrLoading)
                        textureParams.xhrLoading = p.xhrLoading; //forces blob loading
                    if (p.tags) {
                        jsonParams.tags = p.tags;
                        textureParams.tags = p.tags;
                    }
                }
                var imageFile = new Kiwi.Files.TextureFile(this.game, textureParams);
                var jsonFile = new Kiwi.Files.DataFile(this.game, jsonParams);
                this.addFileToQueue(imageFile);
                this.addFileToQueue(jsonFile);
                return imageFile;
            };
            /**
            * Creates a new File to store a audio piece.
            * This method firstly checks to see if the AUDIO file being loaded is supported or not by the browser/device before adding it to the loading queue.
            * You can override this behaviour and tell the audio data to load even if not supported by setting the 'onlyIfSupported' boolean to false.
            * Also you can now pass an array of filepaths, and the first audio filetype that is supported will be loaded.
            *
            * @method addAudio
            * @param key {String} The key for the audio file.
            * @param url {String} The url of the audio to load. You can pass an array of URLs, in which case the first supported audio filetype in the array will be loaded.
            * @param [storeAsGlobal=true] {Boolean} If the file should be stored globally.
            * @param [onlyIfSupported=true] {Boolean} If the audio file should only be loaded if Kiwi detects that the audio file could be played.
            * @return {Kiwi.Files.File} The file which was created.
            * @public
            */
            Loader.prototype.addAudio = function (key, url, storeAsGlobal, onlyIfSupported) {
                if (storeAsGlobal === void 0) { storeAsGlobal = true; }
                if (onlyIfSupported === void 0) { onlyIfSupported = true; }
                var params = {
                    type: Kiwi.Files.File.AUDIO,
                    key: null,
                    url: null,
                    state: null,
                    fileStore: this.game.fileStore
                };
                if (Kiwi.Utils.Common.isObject(key)) {
                    params = key;
                    params.type = Kiwi.Files.File.AUDIO;
                    params.fileStore = this.game.fileStore;
                }
                else {
                    params.key = key;
                    params.url = url;
                    if (!storeAsGlobal && this.game.states.current) {
                        params.state = this.game.states.current;
                    }
                }
                var i = 0, urls, file;
                //If it is a string then try to load that file
                if (Kiwi.Utils.Common.isString(params.url)) {
                    urls = [params.url];
                }
                else {
                    urls = params.url;
                }
                while (i < urls.length) {
                    params.url = urls[i];
                    file = this._attemptToAddAudio(params, onlyIfSupported);
                    if (file) {
                        return file;
                    }
                    i++;
                }
                return null;
            };
            /**
            * This method firstly checks to see if the AUDIO file being loaded is supported or not by the browser/device before adding it to the loading queue.
            * Returns a boolean if the audio file was successfully added or not to the file directory.
            * @method _attemptToAddAudio
            * @param params {Object}
            *   @param params.key {String} The key for the audio file.
            *   @param params.url {String} The url of the audio to load.
            *   @param [params.state=true] {Kiwi.State} The state this file should be for.
            *   @param [params.fileStore] {Kiwi.Files.FileStore}
            * @param [onlyIfSupported=true] {Boolean} If the audio file should only be loaded if Kiwi detects that the audio file could be played.
            * @return {Kiwi.Files.File} The file which was created.
            * @private
            */
            Loader.prototype._attemptToAddAudio = function (params, onlyIfSupported) {
                var file = new Kiwi.Files.AudioFile(this.game, params);
                var support = false;
                switch (file.extension) {
                    case 'mp3':
                        support = Kiwi.DEVICE.mp3;
                        break;
                    case 'ogg':
                    case 'oga':
                        support = Kiwi.DEVICE.ogg;
                        break;
                    case 'm4a':
                        support = Kiwi.DEVICE.m4a;
                        break;
                    case 'wav':
                    case 'wave':
                        support = Kiwi.DEVICE.wav;
                        break;
                }
                if (support == true || onlyIfSupported == false) {
                    this.addFileToQueue(file);
                    return file;
                }
                else {
                    Kiwi.Log.error('Kiwi.Loader: Audio Format not supported on this Device/Browser.', '#audio', '#unsupported');
                    return null;
                }
            };
            /**
            * Creates a new File to store JSON and adds it to the loading queue.
            * @method addJSON
            * @param key {String} The key for the file.
            * @param url {String} The url to the json file.
            * @param [storeAsGlobal=true] {Boolean} If the file should be stored globally.
            * @return {Kiwi.Files.File} The file which was created.
            * @public
            */
            Loader.prototype.addJSON = function (key, url, storeAsGlobal) {
                if (storeAsGlobal === void 0) { storeAsGlobal = true; }
                var params = {
                    type: Kiwi.Files.File.JSON,
                    key: key,
                    url: url,
                    fileStore: this.game.fileStore
                };
                if (Kiwi.Utils.Common.isObject(key)) {
                    var p = key;
                    params.key = p.key;
                    params.url = p.url;
                    if (p.parse)
                        params.parse = p.parse;
                    if (p.state)
                        params.state = p.state;
                    if (p.tags)
                        params.tags = p.tags;
                }
                else {
                    if (!storeAsGlobal && this.game.states.current) {
                        params.state = this.game.states.current;
                    }
                }
                var file = new Kiwi.Files.DataFile(this.game, params);
                this.addFileToQueue(file);
                return file;
            };
            /**
            * Creates a new File to store XML and adds it to the loading queue.
            * @method addXML
            * @param key {String} The key for the file.
            * @param url {String} The url to the xml file.
            * @param [storeAsGlobal=true] {Boolean} If the file should be stored globally.
            * @return {Kiwi.Files.File} The file which was created.
            * @public
            */
            Loader.prototype.addXML = function (key, url, storeAsGlobal) {
                if (storeAsGlobal === void 0) { storeAsGlobal = true; }
                var params = {
                    type: Kiwi.Files.File.XML,
                    key: key,
                    url: url,
                    fileStore: this.game.fileStore
                };
                if (Kiwi.Utils.Common.isObject(key)) {
                    var p = key;
                    params.key = p.key;
                    params.url = p.url;
                    if (p.parse)
                        params.parse = p.parse;
                    if (p.state)
                        params.state = p.state;
                    if (p.tags)
                        params.tags = p.tags;
                }
                else {
                    if (!storeAsGlobal && this.game.states.current) {
                        params.state = this.game.states.current;
                    }
                }
                var file = new Kiwi.Files.DataFile(this.game, params);
                this.addFileToQueue(file);
                return file;
            };
            /**
            * Creates a new File for a Binary file and adds it to the loading queue.
            * @method addBinaryFile
            * @param key {String} The key for the file.
            * @param url {String} The url to the Binary file.
            * @param [storeAsGlobal=true] {Boolean} If the file should be stored globally.
            * @return {Kiwi.Files.File} The file which was created.
            * @public
            */
            Loader.prototype.addBinaryFile = function (key, url, storeAsGlobal) {
                if (storeAsGlobal === void 0) { storeAsGlobal = true; }
                var params = {
                    type: Kiwi.Files.File.BINARY_DATA,
                    key: key,
                    url: url,
                    fileStore: this.game.fileStore
                };
                if (Kiwi.Utils.Common.isObject(key)) {
                    var p = key;
                    params.key = p.key;
                    params.url = p.url;
                    if (p.parse)
                        params.parse = p.parse;
                    if (p.state)
                        params.state = p.state;
                    if (p.tags)
                        params.tags = p.tags;
                }
                else {
                    if (!storeAsGlobal && this.game.states.current) {
                        params.state = this.game.states.current;
                    }
                }
                var file = new Kiwi.Files.DataFile(this.game, params);
                this.addFileToQueue(file);
                return file;
            };
            /**
            * Creates a new File to store a text file and adds it to the loading queue.
            * @method addTextFile
            * @param key {String} The key for the file.
            * @param url {String} The url to the text file.
            * @param [storeAsGlobal=true] {Boolean} If the file should be stored globally.
            * @return {Kiwi.Files.File} The file which was created.
            * @public
            */
            Loader.prototype.addTextFile = function (key, url, storeAsGlobal) {
                if (storeAsGlobal === void 0) { storeAsGlobal = true; }
                var params = {
                    type: Kiwi.Files.File.TEXT_DATA,
                    key: key,
                    url: url,
                    fileStore: this.game.fileStore
                };
                if (Kiwi.Utils.Common.isObject(key)) {
                    var p = key;
                    params.key = p.key;
                    params.url = p.url;
                    if (p.parse)
                        params.parse = p.parse;
                    if (p.state)
                        params.state = p.state;
                    if (p.tags)
                        params.tags = p.tags;
                }
                else {
                    if (!storeAsGlobal && this.game.states.current) {
                        params.state = this.game.states.current;
                    }
                }
                var file = new Kiwi.Files.DataFile(this.game, params);
                this.addFileToQueue(file);
                return file;
            };
            /**
            * Flags this loader for garbage collection. Only use this method if you are SURE you will no longer need it.
            * Otherwise it is best to leave it alone.
            *
            * @method destroy
            * @public
            */
            Loader.prototype.destroy = function () {
                this.onQueueComplete.dispose();
                this.onQueueProgress.dispose();
                delete this.game;
                delete this.onQueueComplete;
                delete this.onQueueProgress;
                var i = 0;
                while (i < this._loadingList.length) {
                    this._loadingList[i].destroy();
                    i++;
                }
                this._loadingList = [];
                var i = 0;
                while (i < this._loadingQueue.length) {
                    this._loadingQueue[i].destroy();
                    i++;
                }
                this._loadingQueue = [];
                var i = 0;
                while (i < this._loadingParallel.length) {
                    this._loadingParallel[i].destroy();
                    i++;
                }
                this._loadingParallel = [];
            };
            /**
            * -----------------------
            * Deprecated - Functionality exists. Maps to its equalvent
            * -----------------------
            **/
            /**
            * Initialise the properities that are needed on this loader.
            * Recommended you use the 'onQueueProgress' / 'onQueueComplete' signals instead.
            *
            * @method init
            * @param [progress=null] {Any} Progress callback method.
            * @param [complete=null] {Any} Complete callback method.
            * @param [calculateBytes=false] {boolean}
            * @deprecated Deprecated as of 1.2.0
            * @public
            */
            Loader.prototype.init = function (progress, complete, calculateBytes) {
                if (progress === void 0) { progress = null; }
                if (complete === void 0) { complete = null; }
                if (calculateBytes === void 0) { calculateBytes = null; }
                if (calculateBytes !== null) {
                    this._calculateBytes = calculateBytes;
                }
                if (progress !== null) {
                    this.onQueueProgress.addOnce(progress);
                }
                if (complete !== null) {
                    this.onQueueComplete.addOnce(complete);
                }
            };
            /**
            * Loops through all of the files that need to be loaded and start the load event on them.
            * @method startLoad
            * @deprecated Use 'start' instead. Deprecated as of 1.2.0
            * @public
            */
            Loader.prototype.startLoad = function () {
                this.start();
            };
            /**
            * Returns a percentage of the amount that has been loaded so far.
            * @method getPercentLoaded
            * @return {Number}
            * @deprecated Use 'percentLoaded' instead. Deprecated as of 1.2.0
            * @public
            */
            Loader.prototype.getPercentLoaded = function () {
                return this.percentLoaded;
            };
            /**
            * Returns a boolean indicating if everything in the loading que has been loaded or not.
            * @method complete
            * @return {boolean}
            * @deprecated Use 'percentLoaded' instead. Deprecated as of 1.2.0
            * @public
            */
            Loader.prototype.complete = function () {
                return (this.percentLoaded === 100);
            };
            /**
            * Quick way of getting / setting the private variable 'calculateBytes'
            * To be made into a public variable once removed.
            * @method calculateBytes
            * @param [value] {boolean}
            * @return {boolean}
            * @public
            */
            Loader.prototype.calculateBytes = function (value) {
                if (typeof value !== "undefined") {
                    this._calculateBytes = value;
                }
                return this._calculateBytes;
            };
            /**
            * Returns the total number of bytes that have been loaded so far from files in the file queue.
            *
            * @method getBytesLoaded
            * @return {Number}
            * @readOnly
            * @deprecated Use 'bytesLoaded' instead. Deprecated as of 1.2.0
            * @public
            */
            Loader.prototype.getBytesLoaded = function () {
                return this.bytesLoaded;
            };
            return Loader;
        })();
        Files.Loader = Loader;
    })(Files = Kiwi.Files || (Kiwi.Files = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Files
* @main Files
*/
var Kiwi;
(function (Kiwi) {
    var Files;
    (function (Files) {
        /**
        * Holds a reference to all of the data Files (json, xml, e.t.c) that are accessible on the State that this DataLibrary is on.
        *
        * @class DataLibrary
        * @namespace Kiwi.Files
        * @constructor
        * @param game {Kiwi.Game} The game that this DataLibrary belongs to.
        * @return {Kiwi.Files.DataLibrary}
        *
        */
        var DataLibrary = (function () {
            function DataLibrary(game) {
                this._game = game;
                this.data = {};
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String} "DataLibrary"
            * @public
            */
            DataLibrary.prototype.objType = function () {
                return "DataLibrary";
            };
            /**
            * Resets the Data Library and makes it ready for the next state.
            * @method clear
            * @public
            */
            DataLibrary.prototype.clear = function () {
                for (var prop in this.data) {
                    delete this.data[prop];
                }
            };
            /**
            * Adds a new data file to the DataLibrary.
            * @method add
            * @param dataFile {Kiwi.Files.File} The File that is to be added.
            * @public
            */
            DataLibrary.prototype.add = function (dataFile) {
                switch (dataFile.dataType) {
                    case Kiwi.Files.File.JSON:
                    case Kiwi.Files.File.XML:
                    case Kiwi.Files.File.BINARY_DATA:
                    case Kiwi.Files.File.TEXT_DATA:
                        this.data[dataFile.key] = dataFile;
                        break;
                    default:
                        //Image file is of unknown type and was not added to data library
                        break;
                }
            };
            /**
           * Rebuild the library from a fileStore. Clears the library and repopulates it.
           * @method rebuild
           * @param fileStore {Kiwi.Files.FileStore} The fileStore which is being used
           * @param state {Kiwi.State} The State so that we know which DataLibrary to add the files tot.
           * @public
           */
            DataLibrary.prototype.rebuild = function (fileStore, state) {
                this.clear();
                Kiwi.Log.log("Kiwi.DataLibrary: Rebuilding Data Library", '#rebuild');
                var fileStoreKeys = fileStore.keys;
                for (var i = 0; i < fileStoreKeys.length; i++) {
                    var file = this._game.fileStore.getFile(fileStoreKeys[i]);
                    if (file.isData) {
                        Kiwi.Log.log("  Kiwi.DataLibrary: Adding Data: " + file.name, '#rebuild', '#adding');
                        state.dataLibrary.add(file);
                    }
                }
            };
            return DataLibrary;
        })();
        Files.DataLibrary = DataLibrary;
    })(Files = Kiwi.Files || (Kiwi.Files = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Files
*
*/
var Kiwi;
(function (Kiwi) {
    var Files;
    (function (Files) {
        /**
        * Base class which handles the loading of an external data file an xhr.
        * TextureFile, AudioFile contain fallback loading via tags and all extended Files contain methods for processing the files.
        *
        * Also can contain information about the file (like file size, last modified, e.t.c.)
        * Uses an object literal in its constructor since 1.2 (which is preferred), but also contains previous construction support.
        *
        * @class File
        * @namespace Kiwi.Files
        * @constructor
        * @param game {Kiwi.Game} The game that this file is for
        * @param params {Object} Options for this file.
        *   @param params.key {String} User defined name for this file. This would be how the user would access it in the file store.
        *   @param params.url {String} Location of the file to be loaded.
        *   @param {Object} [params.metadata={}] Any metadata to be associated with the file.
        *   @param [params.state=null] {Kiwi.State} The state that this file belongs to. Used for defining global assets vs local assets.
        *   @param [params.fileStore=null] {Kiwi.Files.FileStore} The filestore that this file should be save in automatically when loaded.
        *   @param [params.type=UNKNOWN] {Number} The type of file this is.
        *   @param [params.tags] {Array} Any tags to be associated with this file.
        *   @param [params.timeout=TIMEOUT_DELAY] {Number} Sets the timeout delay when loading via ajax.
        * @return {Kiwi.Files.File}
        *
        */
        var File = (function () {
            function File(game, params) {
                /**
                * ---------------
                * Generic Properties
                * ---------------
                **/
                /**
                * Indicates if this file can be loaded in parallel to other files.
                * This is usually only used files are using the tag loaders and not XHR.
                *
                * @property _loadInParallel
                * @type Boolean
                * @default false
                * @since 1.2.0
                * @private
                */
                this._loadInParallel = false;
                /**
                * If this file is using tag loading instead of the XHR method.
                * Only used by extended classes
                *
                * @property useTagLoader
                * @type Boolean
                * @since 1.2.0
                * @protected
                */
                this.useTagLoader = false;
                /**
                * The size of the file that was/is being loaded.
                * Only has a value when the file was loaded by the XHR method OR you request the file information beforehand using 'loadDetails'.
                *
                * @property size
                * @type Number
                * @default 0
                * @since 1.2.0
                * @public
                */
                this.size = 0;
                /**
                * The number of milliseconds that the XHR should wait before timing out.
                * Set this to NULL if you want it to not timeout.
                *
                * Default changed in v1.3.1 to null
                *
                * @property timeOutDelay
                * @type Number
                * @default null
                * @public
                */
                this.timeOutDelay = Kiwi.Files.File.TIMEOUT_DELAY;
                /**
                * The number of attempts at loading there have currently been at loading the file.
                * This is only used with XHR methods of loading.
                * @property attemptCounter
                * @type Number
                * @protected
                */
                this.attemptCounter = 0;
                /**
                * The maximum attempts at loading the file that there is allowed.
                * @property maxLoadAttempts
                * @type Number
                * @default 2
                * @public
                */
                this.maxLoadAttempts = Kiwi.Files.File.MAX_LOAD_ATTEMPTS;
                /**
                * -----------------
                * Loading Status
                * -----------------
                **/
                /**
                * The time at which the loading started.
                * @property timeStarted
                * @type Number
                * @default 0
                * @public
                */
                this.timeStarted = 0;
                /**
                * The time at which progress in loading the file was last occurred.
                * Only contains a value when using XHR methods of loading.
                * @property lastProgress
                * @type Number
                * @public
                */
                this.lastProgress = 0;
                /**
                * The time at which the load finished.
                * @property timeFinished
                * @type Number
                * @default 0
                * @public
                */
                this.timeFinished = 0;
                /**
                * The duration or how long it took to load the file. In milliseconds.
                * @property duration
                * @type Number
                * @default 0
                * @public
                */
                this.duration = 0;
                /**
                * If file loading failed or encountered an error and so was not laoded
                * @property hasError
                * @type boolean
                * @default false
                * @public
                */
                this.hasError = false;
                /**
                * If loading was successful or not.
                * @property success
                * @type boolean
                * @public
                */
                this.success = false;
                /**
                * Indication if the file is currently being loaded or not.
                * @property loading
                * @type boolean
                * @public
                */
                this.loading = false;
                /**
                * Indicates if the file has attempted to load.
                * This is regardless of whether it was a success or not.
                * @property complete
                * @type boolean
                * @default false
                * @public
                */
                this.complete = false;
                /**
                * The amount of percent loaded the file is. This is out of 100.
                * @property percentLoaded
                * @type Number
                * @public
                */
                this.percentLoaded = 0;
                /**
                * The number of bytes that have currently been loaded.
                * Useful when wanting to know exactly how much data has been transferred.
                * Only has a value when using the XHR method of loading.
                *
                * @property bytesLoaded
                * @type Number
                * @default 0
                * @public
                */
                this.bytesLoaded = 0;
                /**
                * The total number of bytes that the file consists off.
                * Only has a value when using the XHR method of loading
                * or you are getting the file details before hand.
                *
                * @property bytesTotal
                * @type Number
                * @default 0
                * @public
                */
                this.bytesTotal = 0;
                /**
                * An indication of whether this files information has been retrieved or not.
                * @property detailsReceived
                * @type boolean
                * @default false
                * @since 1.2.0
                * @public
                */
                this.detailsReceived = false;
                /**
                * --------------------
                * MISC
                * --------------------
                **/
                /**
                * The Entity Tag that is assigned to the file. O
                * Only has a value when either using the XHR loader OR when requesting the file details.
                * @property ETag
                * @type String
                * @public
                */
                this.ETag = '';
                /**
                * The last date/time that this file was last modified.
                * Only has a value when using the XHR method of loading OR when requesting the file details.
                * @property lastModified
                * @type String
                * @default ''
                * @public
                */
                this.lastModified = '';
                /**
                * A method that is to be executed when this file has finished loading.
                * @property onCompleteCallback
                * @type Any
                * @default null
                * @deprecated Use `onComplete`. Deprecated as of 1.2.0
                * @public
                */
                //public onCompleteCallback: any = null;
                /**
                * A method that is to be executed while this file is loading.
                * @property onProgressCallback
                * @type Any
                * @default null
                * @deprecated Use `onProgress`. Deprecated as of 1.2.0
                * @public
                */
                //public onProgressCallback: any = null;
                /**
                * The status of this file that is being loaded.
                * Only used/has a value when the file was/is being loaded by the XHR method.
                * @property status
                * @type Number
                * @default 0
                * @deprecated Deprecated as of 1.2.0
                * @public
                */
                this.status = 0;
                /**
                * The status piece of text that the XHR returns.
                * @property statusText
                * @type String
                * @default ''
                * @deprecated Deprecated as of 1.2.0
                * @public
                */
                this.statusText = '';
                /**
                * The ready state of the XHR loader whilst loading.
                * @property readyState
                * @type Number
                * @default 0
                * @deprecated Deprecated as of 1.2.0
                * @public
                */
                this.readyState = 0;
                /**
                * If this file has timeout when it was loading.
                * @property hasTimedOut
                * @type boolean
                * @default false
                * @deprecated Deprecated as of 1.2.0
                * @public
                */
                this.hasTimedOut = false;
                /**
                * If the file timed out or not.
                * @property timedOut
                * @type Number
                * @default 0
                * @deprecated Deprecated as of 1.2.0
                * @public
                */
                this.timedOut = 0;
                this.game = game;
                this.onComplete = new Kiwi.Signal;
                this.onProgress = new Kiwi.Signal;
                if (Kiwi.Utils.Common.isNumeric(params)) {
                    //Deprecate
                    this._parseParamsOld(params, arguments[2], arguments[3], arguments[4], arguments[5]);
                }
                else {
                    this.key = params.key;
                    this._assignFileDetails(params.url);
                    this.parseParams(params);
                }
            }
            /**
            * Assigns properties and variables for the constructor as in pre 1.2 Kiwi versions.
            *
            * @method _parseParamsOld
            * @since 1.2.0
            * @param dataType {Number} The type of file that is being loaded. For this you can use the STATIC properties that are located on this class for quick code completion.
            * @param path {String} The location of the file that is to be loaded.
            * @param [name=''] {String} A name for the file. If no name is specified then the files name will be used.
            * @param [saveToFileStore=true] {Boolean} If the file should be saved on the file store or not.
            * @param [storeAsGlobal=true] {Boolean} If this file should be stored as a global file, or if it should be destroyed when this state gets switched out.
            * @private
            */
            File.prototype._parseParamsOld = function (dataType, url, name, saveToFileStore, storeAsGlobal) {
                if (name === void 0) { name = ''; }
                if (saveToFileStore === void 0) { saveToFileStore = true; }
                if (storeAsGlobal === void 0) { storeAsGlobal = true; }
                this.dataType = dataType;
                this._assignFileDetails(url);
                if (saveToFileStore) {
                    this.fileStore = this.game.fileStore;
                }
                if (this.game.states.current && !storeAsGlobal) {
                    this.ownerState = this.game.states.current;
                }
            };
            /**
            * Sets properties for this instance based on an object literal passed. Used when the class is being created.
            *
            * @method parseParams
            * @since 1.2.0
            * @param [params] {Object}
            *   @param [params.metadata={}] {Object} Any metadata to be associated with the file.
            *   @param [params.state=null] {Kiwi.State} The state that this file belongs to. Used for defining global assets vs local assets.
            *   @param [params.fileStore=null] {Kiwi.Files.FileStore} The filestore that this file should be save in automatically when loaded.
            *   @param [params.type=UNKNOWN] {Number} The type of file this is.
            *   @param [params.tags] {Array} Any tags to be associated with this file.
            *   @param [params.timeout=TIMEOUT_DELAY] {Number} Sets the timeout delay when loading via ajax.
            * @protected
            */
            File.prototype.parseParams = function (params) {
                this.fileStore = params.fileStore || null;
                this.ownerState = params.state || null;
                this.metadata = params.metadata || {};
                if (Kiwi.Utils.Common.isUndefined(params.timeout)) {
                    this.timeOutDelay = params.timeout;
                }
                else {
                    this.timeOutDelay = Kiwi.Files.File.TIMEOUT_DELAY;
                }
                if (Kiwi.Utils.Common.isUndefined(params.type)) {
                    this.dataType = File.UNKNOWN;
                }
                else {
                    this.dataType = params.type;
                }
                if (params.tags && Kiwi.Utils.Common.isArray(params.tags)) {
                    for (var i = 0; i < params.tags.length; i++) {
                        this.addTag(params.tags[i]);
                    }
                }
            };
            /**
            * Gets the file details from the URL passed. Name, extension, and path are extracted.
            *
            * @method _assignFileDetails
            * @param url {String}
            * @private
            * @since 1.2.0
            */
            File.prototype._assignFileDetails = function (url) {
                this.URL = url;
                if (url.lastIndexOf('/') > -1) {
                    this.name = url.substr(url.lastIndexOf('/') + 1);
                    this.path = url.substr(0, url.lastIndexOf('/') + 1);
                }
                else {
                    this.path = '';
                    this.name = url;
                }
                //  Not safe if there is a query string after the file extension
                this.extension = url.substr(url.lastIndexOf('.') + 1).toLowerCase();
            };
            /**
            * Returns the type of this object
            * @method objType
            * @return {String} "File"
            * @public
            */
            File.prototype.objType = function () {
                return "File";
            };
            Object.defineProperty(File.prototype, "loadInParallel", {
                /**
                * READ ONLY: Indicates if this file can be loaded in parallel to other files.
                * This is usually only used files are using the tag loaders and not XHR.
                *
                * @property loadInParallel
                * @type Boolean
                * @default false
                * @readOnly
                * @since 1.2.0
                * @private
                */
                get: function () {
                    return this._loadInParallel;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Starts the loading process for this file.
            * Passing parameters to this method has been deprecated and only exists for backwards compatibility.
            *
            * @method load
            * @public
            */
            File.prototype.load = function (onCompleteCallback, onProgressCallback, customFileStore, maxLoadAttempts, timeout) {
                //Not currently loading?
                if (this.loading) {
                    Kiwi.Log.error('Kiwi.Files.File: File loading is in progress. Cannot be told to load again.', '#loading');
                    return;
                }
                Kiwi.Log.log("Kiwi.Files.File: Starting to load '" + this.name + "'", '#file', '#loading');
                //Set the variables based on the parameters passed
                //To be deprecated
                if (onCompleteCallback)
                    this.onComplete.add(onCompleteCallback);
                if (onProgressCallback)
                    this.onProgress.add(onProgressCallback);
                if (customFileStore)
                    this.fileStore = customFileStore;
                if (typeof maxLoadAttempts !== "undefined")
                    this.maxLoadAttempts = maxLoadAttempts;
                if (typeof timeout !== "undefined")
                    this.timeOutDelay = timeout;
                //Start Loading!!!
                this._start();
                this._load();
            };
            /**
            * Increments the counter, and calls the approprate loading method.
            * @method _load
            * @since 1.2.0
            * @protected
            */
            File.prototype._load = function () {
                this.attemptCounter++;
                this.xhrLoader('GET', 'text');
            };
            /**
            * Should be called by the loading method. Dispatches the 'onProgress' callback.
            * @method loadProgress
            * @since 1.2.0
            * @protected
            */
            File.prototype.loadProgress = function () {
                this.onProgress.dispatch(this);
            };
            /**
            * Called by the loading methods when the file has been loaded and successfully processed.
            * Dispatches the 'onComplete' callback and sets the appropriate properties.
            * @method loadSuccess
            * @since 1.2.0
            * @protected
            */
            File.prototype.loadSuccess = function () {
                //If already completed skip
                if (this.complete) {
                    return;
                }
                this.success = true;
                this.hasError = false;
                this._stop();
                if (this.fileStore) {
                    this.fileStore.addFile(this.key, this);
                }
                this.onComplete.dispatch(this);
            };
            /**
            * Executed when the loading process fails.
            * This could be for any reason
            *
            * @method loadError
            * @param error {Any} The event / reason for the file to not be loaded.
            * @since 1.2.0
            * @protected
            */
            File.prototype.loadError = function (error) {
                //Try again?
                if (this.attemptCounter >= this.maxLoadAttempts) {
                    //Failed
                    Kiwi.Log.log("Kiwi.Files.File: Failed to load file '" + this.name + "'. Trying Again", '#loading');
                    this.hasError = true;
                    this.success = false;
                    this.error = error;
                    this._stop();
                    this.onComplete.dispatch(this);
                }
                else {
                    Kiwi.Log.log("Kiwi.Files.File: Failed to load file '" + this.name + "'", '#loading');
                    //Try Again
                    this._load();
                }
            };
            /**
            * ---------------
            * XHR Loading
            * ---------------
            **/
            /**
            * Sets up a XHR loader based on the properties of this file and parameters passed.
            *
            * @method xhrLoader
            * @param [method="GET"] {String} The method this request should be made in.
            * @param [responseType="text"] {String} The type of response we are expecting.
            * @param [timeoutDelay] {Number}
            * @protected
            */
            File.prototype.xhrLoader = function (method, responseType, timeoutDelay) {
                var _this = this;
                if (method === void 0) { method = 'GET'; }
                if (responseType === void 0) { responseType = 'text'; }
                if (timeoutDelay === void 0) { timeoutDelay = this.timeOutDelay; }
                this._xhr = new XMLHttpRequest();
                this._xhr.open(method, this.URL, true);
                if (timeoutDelay !== null) {
                    this._xhr.timeout = timeoutDelay;
                }
                this._xhr.responseType = responseType;
                this._xhr.onload = function (event) { return _this.xhrOnLoad(event); };
                this._xhr.onerror = function (event) { return _this.loadError(event); };
                this._xhr.onprogress = function (event) { return _this.xhrOnProgress(event); };
                var _that = this;
                this._xhr.onreadystatechange = function () {
                    _that.readyState = _that._xhr.readyState;
                };
                this._xhr.onloadstart = function (event) {
                    _that.timeStarted = event.timeStamp;
                    _that.lastProgress = event.timeStamp;
                };
                this._xhr.ontimeout = function (event) {
                    _that.hasTimedOut = true;
                };
                this._xhr.onloadend = function (event) {
                    _that.xhrOnLoad(event);
                };
                this._xhr.send();
            };
            /**
            * Progress event fired whilst the file is loading via XHR.
            * @method xhrOnProgress
            * @param event {Any}
            * @protected
            */
            File.prototype.xhrOnProgress = function (event) {
                this.bytesLoaded = parseInt(event.loaded);
                this.bytesTotal = parseInt(event.total);
                this.percentLoaded = Math.round((this.bytesLoaded / this.bytesTotal) * 100);
                this.onProgress.dispatch(this);
            };
            /**
            * Fired when the file has been loaded.
            * Checks that the response contains information before marking it as a success.
            *
            * @method xhrOnLoad
            * @param event {Any}
            * @protected
            */
            File.prototype.xhrOnLoad = function (event) {
                //Deprecate
                this.status = this._xhr.status;
                this.statusText = this._xhr.statusText;
                // If there is a status, then use that for our check. Otherwise we will base it on the response
                if (this.status && this.status === 200 || !this.status && this._xhr.response) {
                    this._getXhrHeaderInfo();
                    this.buffer = this._xhr.response; //Deprecate
                    this.processXhr(this._xhr.response);
                }
                else {
                    this.loadError(event);
                }
            };
            /**
            * Contains the logic for processing the information retrieved via XHR.
            * Assigns the data property.
            * This method is also in charge of calling 'loadSuccess' (or 'loadError') when processing is complete.
            *
            * @method processXhr
            * @param response
            * @protected
            */
            File.prototype.processXhr = function (response) {
                this.data = response;
                this.loadSuccess();
            };
            /**
            * Is executed when this file starts loading.
            * Gets the time and resets properties used in file loading.
            * @method _start
            * @private
            */
            File.prototype._start = function () {
                this.attemptCounter = 0;
                this.loading = true;
                this.timeStarted = Date.now();
                this.percentLoaded = 0;
            };
            /**
            * Is executed when this file stops loading.
            * @method _stop
            * @private
            */
            File.prototype._stop = function () {
                this.loading = false;
                this.complete = true;
                this.percentLoaded = 100;
                this.timeFinished = Date.now();
                this.duration = this.timeFinished - this.timeStarted;
            };
            /**
            * Makes a XHR HEAD request to get information about the file that is going to be downloaded.
            * This is particularly useful when you are wanting to check how large a file is before loading all of the content.
            *
            * @method loadDetails
            * @param [callback] {Any}
            * @param [context] {Any}
            * @return {Boolean} If the request was made
            * @since 1.2.0
            * @public
            */
            File.prototype.loadDetails = function (callback, context) {
                if (callback === void 0) { callback = null; }
                if (context === void 0) { context = null; }
                //Can't continue if regular loading is progressing.
                if (this.loading) {
                    Kiwi.Log.error('Kiwi.Files.File: Cannot get the file details whilst the file is already loading');
                    return false;
                }
                if (callback)
                    this.headCompleteCallback = callback;
                if (context)
                    this.headCompleteContext = context;
                this.xhrHeadRequest();
                return true;
            };
            /**
            * Retrieves the HEAD information from the XHR.
            * This method is used for both 'load' and 'loadDetails' methods.
            *
            * @method _getXhrHeaderInfo
            * @since 1.2.0
            * @private
            */
            File.prototype._getXhrHeaderInfo = function () {
                if (!this._xhr) {
                    return;
                }
                this.status = this._xhr.status;
                this.statusText = this._xhr.statusText;
                //Get the file information...
                this.type = this._xhr.getResponseHeader('Content-Type');
                this.size = parseInt(this._xhr.getResponseHeader('Content-Length'));
                this.lastModified = this._xhr.getResponseHeader('Last-Modified');
                this.ETag = this._xhr.getResponseHeader('ETag');
                this.detailsReceived = true;
            };
            /**
            * Sets up a XMLHttpRequest object and sends a HEAD request.
            * @method xhrHeadRequest
            * @since 1.2.0
            * @private
            */
            File.prototype.xhrHeadRequest = function () {
                var _this = this;
                this._xhr = new XMLHttpRequest();
                this._xhr.open('HEAD', this.fileURL, true);
                if (this.timeOutDelay !== null)
                    this._xhr.timeout = this.timeOutDelay;
                this._xhr.onload = function (event) { return _this.xhrHeadOnLoad(event); };
                this._xhr.onerror = function (event) { return _this.xhrHeadOnError(event); };
                this._xhr.send();
            };
            /**
            * Executed when a xhr head request fails
            * @method xhrHeadOnError
            * @param event {Any}
            * @private
            */
            File.prototype.xhrHeadOnError = function (event) {
                if (this.headCompleteCallback) {
                    this.headCompleteCallback.call(this.headCompleteContext, false);
                }
            };
            /**
            * Executed when a XHR head request has loaded.
            * Checks that the status of the request is 200 before classifying it as a success.
            * @method xhrHeadOnLoad
            * @param event {Any}
            * @private
            */
            File.prototype.xhrHeadOnLoad = function (event) {
                if (this._xhr.status === 200) {
                    this._getXhrHeaderInfo();
                    if (this.headCompleteCallback) {
                        this.headCompleteCallback.call(this.headCompleteContext, true);
                    }
                }
                else {
                    this.xhrHeadOnError(null);
                }
            };
            /**
            * Adds a new tag to this file.
            * @method addTag
            * @param tag {String} The tag that you would like to add
            * @public
            */
            File.prototype.addTag = function (tag) {
                if (this._tags.indexOf(tag) == -1) {
                    this._tags.push(tag);
                }
            };
            /**
            * Removes a tag from this file.
            * @method removeTag
            * @param tag {String} The tag that is to be removed.
            * @public
            */
            File.prototype.removeTag = function (tag) {
                var index = this._tags.indexOf(tag);
                if (index != -1) {
                    this._tags.splice(index, 1);
                }
            };
            /**
            * Checks to see if a tag that is passed exists on this file.
            * Returns a boolean that is used as a indication of the results.
            * True means that the tag exists on this file.
            *
            * @method hasTag
            * @param tag {String} The tag you are checking to see exists.
            * @return {Boolean} If the tag does exist on this file or not.
            * @public
            */
            File.prototype.hasTag = function (tag) {
                if (this._tags.indexOf(tag) == -1) {
                    return false;
                }
                return true;
            };
            Object.defineProperty(File.prototype, "isTexture", {
                /**
                * An indication of if this file is texture. This is READ ONLY.
                * @property isTexture
                * @type boolean
                * @readOnly
                * @public
                */
                get: function () {
                    return (Kiwi.Files.TextureFile.prototype.objType.call(this) === this.objType());
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(File.prototype, "isAudio", {
                /**
                * An indication of if this file is a piece of audio. This is READ ONLY.
                * @property isAudio
                * @type boolean
                * @readOnly
                * @public
                */
                get: function () {
                    return (Kiwi.Files.AudioFile.prototype.objType.call(this) === this.objType());
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(File.prototype, "isData", {
                /**
                * An indication of if this file is data. This is READ ONLY.
                * @property isData
                * @type boolean
                * @readOnly
                * @public
                */
                get: function () {
                    return (Kiwi.Files.DataFile.prototype.objType.call(this) === this.objType());
                },
                enumerable: true,
                configurable: true
            });
            /**
            * ------------------
            * Clean Up
            * ------------------
            **/
            /**
            * Destroys all external object references on this object.
            * @method destroy
            * @since 1.2.0
            * @public
            */
            File.prototype.destroy = function () {
                if (this.fileStore) {
                    this.fileStore.removeFile(this.key);
                }
                this.onComplete.dispose();
                this.onProgress.dispose();
                delete this.fileStore;
                delete this._xhr;
                delete this.data;
                delete this.buffer;
                delete this.game;
                delete this.error;
                delete this.headCompleteCallback;
                delete this.headCompleteContext;
                delete this.onComplete;
                delete this.onProgress;
                delete this.ownerState;
            };
            Object.defineProperty(File.prototype, "fileName", {
                /**
                * ------------------
                * Deprecated
                * ------------------
                **/
                /**
                * The name of the file being loaded.
                * @property fileName
                * @type String
                * @deprecated Use `name`. Deprecated as of 1.2.0
                * @public
                */
                get: function () {
                    return this.name;
                },
                set: function (val) {
                    this.name = val;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(File.prototype, "filePath", {
                /**
                * The location of where the file is placed without the file itself (So without the files name).
                * Example: If the file you are load is located at 'images/awesomeImage.png' then the filepath will be 'images/'
                * @property filePath
                * @type String
                * @deprecated Use `path`. Deprecated as of 1.2.0
                * @public
                */
                get: function () {
                    return this.path;
                },
                set: function (val) {
                    this.path = val;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(File.prototype, "fileExtension", {
                /**
                * The location of where the file is placed without the file itself (So without the files name).
                * Example: If the file you are load is located at 'images/awesomeImage.png' then the filepath will be 'images/'
                * @property filePath
                * @type String
                * @deprecated Use `extension`. Deprecated as of 1.2.0
                * @public
                */
                get: function () {
                    return this.extension;
                },
                set: function (val) {
                    this.extension = val;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(File.prototype, "fileURL", {
                /**
                * The full filepath including the file itself.
                * @property fileURL
                * @type String
                * @deprecated Use `URL`. Deprecated as of 1.2.0
                * @public
                */
                get: function () {
                    return this.URL;
                },
                set: function (val) {
                    this.URL = val;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(File.prototype, "fileType", {
                /**
                * The type of file that is being loaded.
                * Is only ever given a value when used with the XHR method of loading OR if you use 'getFileDetails' before hand.
                * The value is based off of the 'Content-Type' of the XHR's response header returns.
                * @property fileType
                * @type String
                * @deprecated Use `type`. Deprecated as of 1.2.0
                * @public
                */
                get: function () {
                    return this.type;
                },
                set: function (val) {
                    this.type = val;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(File.prototype, "fileSize", {
                /**
                * The size of the file that was/is being loaded.
                * Only has a value when the file was loaded by the XHR method OR you request the file information before hand using 'getFileDetails'.
                * @property fileSize
                * @type Number
                * @deprecated Use `size`. Deprecated as of 1.2.0
                * @public
                */
                get: function () {
                    return this.size;
                },
                set: function (val) {
                    this.size = val;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Attempts to make the file send a XHR HEAD request to get information about the file that is going to be downloaded.
            * This is particularly useful when you are wanting to check how large a file is before loading all of the content.
            * @method getFileDetails
            * @param [callback=null] {Any} The callback to send this FileInfo object to.
            * @param [maxLoadAttempts=1] {number} The maximum amount of load attempts. Only set this if it is different from the default.
            * @param [timeout=this.timeOutDelay] {number} The timeout delay. By default this is the same as the timeout delay property set on this file.
            * @deprecated Use 'loadDetails' instead. Deprecated as of 1.2.0
            * @private
            */
            File.prototype.getFileDetails = function (callback, maxLoadAttempts, timeout) {
                if (callback === void 0) { callback = null; }
                if (timeout === void 0) { timeout = null; }
                if (timeout)
                    this.timeOutDelay = timeout;
                this.loadDetails(callback, null);
            };
            /**
            * The default number of milliseconds that the XHR should wait before timing out.
            * By default this is set to NULL, and so requests will not timeout.
            *
            * Default changed in v1.3.1 to null
            *
            * @property TIMEOUT_DELAY
            * @type Number
            * @static
            * @since 1.2.0
            * @default null
            * @public
            */
            File.TIMEOUT_DELAY = null;
            /**
            * The default maximum attempts at loading the file that there is allowed.
            * @property MAX_LOAD_ATTEMPTS
            * @type Number
            * @default 2
            * @static
            * @since 1.2.0
            * @public
            */
            File.MAX_LOAD_ATTEMPTS = 2;
            /**
            * -------------------
            * File Type
            * -------------------
            **/
            /**
            * A STATIC property that has the number associated with the IMAGE Datatype.
            * @property IMAGE
            * @type number
            * @static
            * @final
            * @default 0
            * @public
            */
            File.IMAGE = 0;
            /**
            * A STATIC property that has the number associated with the SPRITE_SHEET Datatype.
            * @property SPRITE_SHEET
            * @type number
            * @static
            * @final
            * @default 1
            * @public
            */
            File.SPRITE_SHEET = 1;
            /**
            * A STATIC property that has the number associated with the TEXTURE_ATLAS Datatype.
            * @property TEXTUREATLAS
            * @type number
            * @static
            * @final
            * @default 2
            * @public
            */
            File.TEXTURE_ATLAS = 2;
            /**
            * A STATIC property that has the number associated with the AUDIO Datatype.
            * @property AUDIO
            * @type number
            * @static
            * @final
            * @default 3
            * @public
            */
            File.AUDIO = 3;
            /**
            * A STATIC property that has the number associated with the JSON Datatype.
            * @property JSON
            * @type number
            * @static
            * @final
            * @default 4
            * @public
            */
            File.JSON = 4;
            /**
            * A STATIC property that has the number associated with the XML Datatype.
            * @property XML
            * @type number
            * @static
            * @final
            * @default 5
            * @public
            */
            File.XML = 5;
            /**
            * A STATIC property that has the number associated with the BINARY_DATA Datatype.
            * @property BINARY_DATA
            * @type number
            * @static
            * @final
            * @default 6
            * @public
            */
            File.BINARY_DATA = 6;
            /**
            * A STATIC property that has the number associated with the TEXT_DATA Datatype.
            * @property TEXT_DATA
            * @type number
            * @static
            * @final
            * @default 7
            * @public
            */
            File.TEXT_DATA = 7;
            /**
            *
            * @property UNKNOWN
            * @type number
            * @static
            * @final
            * @default 8
            * @public
            */
            File.UNKNOWN = 8;
            return File;
        })();
        Files.File = File;
    })(Files = Kiwi.Files || (Kiwi.Files = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Files
*
*/
var Kiwi;
(function (Kiwi) {
    var Files;
    (function (Files) {
        /**
        * Holds all of the Files (regardless of the file type) that have been loaded throughout a game/are accessable at a particular point in time. Contains methods for dealing with files. Note: Each time the state is switched the file store will remove all references to files that have not been flagged as global.
        *
        * @class FileStore
        * @namespace Kiwi.Files
        * @constructor
        * @param game {Kiwi.Game} The game that this FileStore belongs to.
        * @return {Kiwi.Files.FilesStore}
        *
        */
        var FileStore = (function () {
            function FileStore(game) {
                /**
                * The number of files that are on the file store.
                * @property _size
                * @type Number
                * @default 0
                * @private
                */
                this._size = 0;
                this._game = game;
                this._files = {};
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String} "FileStore"
            * @public
            */
            FileStore.prototype.objType = function () {
                return "FileStore";
            };
            /**
            * The boot method is executed when the DOM elements needed for this game are ready and thus the game can 'boot'.
            * @method boot
            * @public
            */
            FileStore.prototype.boot = function () {
            };
            /**
            * Returns a particular file by the key that you specify.
            * @method getFile
            * @param key {String} The key of the file that you to get.
            * @return {Kiwi.Files.File}
            * @public
            */
            FileStore.prototype.getFile = function (key) {
                return this._files[key];
            };
            /**
            * Returns an object full of files that have a Tag that is associated with it.
            * @method getFilesByTag
            * @param tag {String}
            * @return {Object} All of the files with that tag.
            * @public
            */
            FileStore.prototype.getFilesByTag = function (tag) {
                var obj = {};
                for (var file in this._files) {
                    if (this._files[file].hasTag(tag)) {
                        obj[file] = this._files[file];
                    }
                }
                return obj;
            };
            /**
            * Removes all of the files by a tag that is specified.
            * @method removeFilesByTag
            * @param tag {String}
            * @return {Number} The number of files that were removed.
            * @public
            */
            FileStore.prototype.removeFilesByTag = function (tag) {
                var numberFiles = 0;
                for (var file in this._files) {
                    if (this._files[file].hasTag(tag)) {
                        this.removeFile(file);
                        numberFiles++;
                    }
                }
                return numberFiles;
            };
            Object.defineProperty(FileStore.prototype, "keys", {
                /**
                * Returns all of the keys for every file that exist on this FileStore as an array.
                * @property keys
                * @type String[]
                * @public
                */
                get: function () {
                    var keys = new Array();
                    for (var key in this._files) {
                        keys.push(key);
                    }
                    return keys;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Returns the number of files that are on this FileStore.
            * @method size
            * @return {Number}
            * @public
            */
            FileStore.prototype.size = function () {
                return this._size;
            };
            /**
            * Adds a File with a key to the FileStore. If the key that you specify already exists then this method will return false otherwise it should return true if it was added.
            * @method addFile
            * @param key {String} A unique key that this file should be accessed by.
            * @param value {Kiwi.Files.File} The file that you would like to save on the FileStore.
            * @return {Boolean} If the file was added or not
            * @public
            */
            FileStore.prototype.addFile = function (key, value) {
                if (!this._files[key]) {
                    this._files[key] = value;
                    this._size++;
                    return true;
                }
                return false;
            };
            /**
            * Checks to see if a key that you pass is already being used for another file. Returns true if that key is already in used, false if it isn't.
            * @method exists
            * @param key {String} The key that you are checking.
            * @return {Boolean}
            * @public
            */
            FileStore.prototype.exists = function (key) {
                if (this._files[key]) {
                    return true;
                }
                else {
                    return false;
                }
            };
            /**
            * Removes files on the FileStore that are associated with a particular state.
            * @method removeStateFiles
            * @param state {Kiwi.State}
            * @public
            */
            FileStore.prototype.removeStateFiles = function (state) {
                for (var file in this._files) {
                    if (this._files[file].ownerState === state) {
                        this.removeFile(file);
                    }
                }
            };
            /**
            * Removes all the files on the FileStore which are not associate with a particular state.
            * @method removeGlobalFiles
            * @since 1.3.0
            * @public
            */
            FileStore.prototype.removeGlobalFiles = function () {
                for (var file in this._files) {
                    if (!this._files[file].ownerState) {
                        this.removeFile(file);
                    }
                }
            };
            /**
            * Removes a file by the key that is passed. Returns a boolean indicating if a file was removed or not.
            * Note: Only returns false if that file did not exist in the first place.
            * @method removeFile
            * @param key {String} The key of the file you want to remove.
            * @return {Boolean}
            * @public
            */
            FileStore.prototype.removeFile = function (key, destroy) {
                if (destroy === void 0) { destroy = false; }
                var file = this._files[key];
                if (file) {
                    this._files[key] = null;
                    delete this._files[key];
                    if (destroy) {
                        file.destroy();
                    }
                    return true;
                }
                return false;
            };
            /**
            * Removes all files on the FileStore.
            * Use this method with caution.
            *
            * @method removeAllFiles
            * @since 1.3.0
            * @public
            */
            FileStore.prototype.removeAllFiles = function () {
                for (var file in this._files) {
                    this.removeFile(file);
                }
            };
            return FileStore;
        })();
        Files.FileStore = FileStore;
    })(Files = Kiwi.Files || (Kiwi.Files = {}));
})(Kiwi || (Kiwi = {}));
/**
* Kiwi - System
* @module Kiwi
* @submodule System
* @main System
*/
var Kiwi;
(function (Kiwi) {
    var System;
    (function (System) {
        /**
        * DOM Boot and Ready functions (based on those used by jQuery)
        *
        * @class Bootstrap
        * @namespace Kiwi.System
        *
        */
        var Bootstrap = (function () {
            function Bootstrap() {
                /**
                *
                * @property isReady
                * @type boolean
                * @public
                */
                this.isReady = false;
                /**
                * The parent div in which the layers and input live
                * @property container
                * @type HTMLDivElement
                * @public
                */
                this.container = null;
                /**
                * This div sits on-top of all layers and captures user input
                * @property input
                * @type HTMLDivElement
                * @public
                */
                this.input = null;
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String} "Bootstrap"
            * @public
            */
            Bootstrap.prototype.objType = function () {
                return "Bootstrap";
            };
            /**
            * Called at the start of the game to check to see if the DOM is ready before we do anything requiring it
            * @method boot
            * @param {String} domParent
            * @param {Any} [callback=null]
            * @param {boolean} [createContainer=true]
            * @public
            */
            Bootstrap.prototype.boot = function (domParent, callback, createContainer) {
                var _this = this;
                if (callback === void 0) { callback = null; }
                if (createContainer === void 0) { createContainer = true; }
                this._callback = callback;
                this._domParent = domParent;
                // if this is true a div will be created in browser
                this._createContainer = createContainer;
                // wait until DOM is loaded and call ready
                if (document.readyState === 'complete' || document.readyState === 'interactive') {
                    this.ready();
                }
                else {
                    document.addEventListener('DOMContentLoaded', function () { return _this.ready(); }, false);
                    window.addEventListener('load', function () { return _this.ready(); }, false);
                }
            };
            /**
            * If the DOM is ready it fires our callback, otherwise sets a short timeout to try again
            * @method ready
            * @public
            */
            Bootstrap.prototype.ready = function () {
                var _this = this;
                if (this.isReady === true) {
                    return;
                }
                if (!document.body) {
                    window.setTimeout(function () { return _this.ready(); }, 13);
                }
                else {
                    //document.removeEventListener('DOMContentLoaded', () => this.ready(), false);
                    this.isReady = true;
                    if (this._createContainer === true) {
                        //  No domParent was given so we create our own container for the game with a unique ID
                        if (this._domParent === '') {
                            Kiwi.Log.log('  Kiwi.Game: No DOM parent specified. Appending the game to the body.', '#dom');
                            this.container = document.createElement('div');
                            this._setupContainer('KiwiGame' + Date.now().toString());
                            document.body.appendChild(this.container);
                        }
                        else {
                            if (document.querySelector(this._domParent)) {
                                Kiwi.Log.log("  Kiwi.Game: Game being created inside '" + this._domParent + "'.", '#dom');
                                this.container = document.querySelector(this._domParent);
                                this._setupContainer();
                            }
                            else if (document.getElementById(this._domParent)) {
                                Kiwi.Log.log("  Kiwi.Game: Game being created inside '" + this._domParent + "'.", '#dom');
                                this.container = document.getElementById(this._domParent);
                                this._setupContainer();
                            }
                            else {
                                Kiwi.Log.log("  Kiwi.Game: The element '" + this._domParent + "' could not be found. Appending the game to the body.", '#dom');
                                this.container = document.createElement('div');
                                this._setupContainer(this._domParent);
                                document.body.appendChild(this.container);
                            }
                        }
                    }
                    if (this._callback !== null) {
                        this._callback();
                    }
                }
            };
            /**
            *
            * @method _setupContainer
            * @param {String} id
            * @private
            */
            Bootstrap.prototype._setupContainer = function (id) {
                if (id === void 0) { id = ''; }
                if (id) {
                    this.container.id = id;
                }
                //Set the containers width/height of the default values.
                //If the user has change the constraints then the Stage will handle the update to the container.
                this.container.style.width = Kiwi.Stage.DEFAULT_WIDTH + 'px';
                this.container.style.height = Kiwi.Stage.DEFAULT_HEIGHT + 'px';
                this.container.style.position = 'relative';
                this.container.style.overflow = 'hidden';
            };
            return Bootstrap;
        })();
        System.Bootstrap = Bootstrap;
    })(System = Kiwi.System || (Kiwi.System = {}));
})(Kiwi || (Kiwi = {}));
/**
* Kiwi - System
* @module Kiwi
* @submodule System
*/
var Kiwi;
(function (Kiwi) {
    var System;
    (function (System) {
        /**
        * Detects device support capabilities. Using some elements from System.js by MrDoob and Modernizr
        * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/audio.js
        *
        * @class Device
        * @constructor
        * @namespace Kiwi.System
        *
        * @author mrdoob
        * @author Modernizr team
        *
        */
        var Device = (function () {
            function Device() {
                //  Operating System
                /**
                *
                * @property iOS
                * @type boolean
                * @public
                */
                this.iOS = false;
                /**
                *
                * @property android
                * @type boolean
                * @public
                */
                this.android = false;
                /**
                *
                * @property chromeOS
                * @type boolean
                * @public
                */
                this.chromeOS = false;
                /**
                *
                * @property linux
                * @type boolean
                * @public
                */
                this.linux = false;
                /**
                *
                * @property maxOS
                * @type boolean
                * @public
                */
                this.macOS = false;
                /**
                *
                * @property windows
                * @type boolean
                * @public
                */
                this.windows = false;
                /**
                *
                * @property windowsPhone
                * @type boolean
                * @public
                */
                this.windowsPhone = false;
                //  Features
                /**
                *
                * @property canvas
                * @type boolean
                * @public
                */
                this.canvas = false;
                /**
                *
                * @property file
                * @type boolean
                * @public
                */
                this.file = false;
                /**
                *
                * @property fileSystem
                * @type boolean
                * @public
                */
                this.fileSystem = false;
                /**
                *
                * @property localStorage
                * @type boolean
                * @public
                */
                this.localStorage = false;
                /**
                *
                * @property webGL
                * @type boolean
                * @public
                */
                this.webGL = false;
                /**
                *
                * @property worker
                * @type boolean
                * @public
                */
                this.worker = false;
                /**
                *
                * @property blob
                * @type boolean
                * @public
                */
                this.blob = false;
                /**
                *
                * @property touch
                * @type boolean
                * @public
                */
                this.touch = false;
                /**
                * If the type of touch events are pointers (event msPointers)
                * @property pointerEnabled
                * @type boolean
                * @public
                */
                this.pointerEnabled = false;
                //  Browser
                /**
                *
                * @property arora
                * @type boolean
                * @public
                */
                this.arora = false;
                /**
                *
                * @property chrome
                * @type boolean
                * @public
                */
                this.chrome = false;
                /**
                *
                * @property epiphany
                * @type boolean
                * @public
                */
                this.epiphany = false;
                /**
                *
                * @property firefox
                * @type boolean
                * @public
                */
                this.firefox = false;
                /**
                *
                * @property ie
                * @type boolean
                * @public
                */
                this.ie = false;
                /**
                *
                * @property ieVersion
                * @type Number
                * @public
                */
                this.ieVersion = 0;
                /**
                *
                * @property ieMobile
                * @type boolean
                * @public
                */
                this.ieMobile = false;
                /**
                *
                * @property mobileSafari
                * @type boolean
                * @public
                */
                this.mobileSafari = false;
                /**
                *
                * @property midori
                * @type boolean
                * @public
                */
                this.midori = false;
                /**
                *
                * @property opera
                * @type boolean
                * @public
                */
                this.opera = false;
                /**
                *
                * @property safari
                * @type boolean
                * @public
                */
                this.safari = false;
                /**
                *
                * @property webApp
                * @type boolean
                * @public
                */
                this.webApp = false;
                //  Audio
                /**
                *
                * @property audioData
                * @type boolean
                * @public
                */
                this.audioData = false;
                /**
                *
                * @property webaudio
                * @type boolean
                * @public
                */
                this.webaudio = false;
                /**
                *
                * @property ogg
                * @type boolean
                * @public
                */
                this.ogg = false;
                /**
                *
                * @property mp3
                * @type boolean
                * @public
                */
                this.mp3 = false;
                /**
                *
                * @property wav
                * @type boolean
                * @public
                */
                this.wav = false;
                /**
                *
                * @property m4a
                * @type boolean
                * @public
                */
                this.m4a = false;
                //  Device
                /**
                *
                * @property iPhone
                * @type boolean
                * @public
                */
                this.iPhone = false;
                /**
                *
                * @property iPhone4
                * @type boolean
                * @public
                */
                this.iPhone4 = false;
                /**
                *
                * @property iPad
                * @type boolean
                * @public
                */
                this.iPad = false;
                /**
                *
                * @property pixelRatio
                * @type Number
                * @public
                */
                this.pixelRatio = 0;
                this._checkAudio();
                this._checkBrowser();
                this._checkDevice();
                this._checkFeatures();
                this._checkOS();
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String} "Device"
            * @public
            */
            Device.prototype.objType = function () {
                return "Device";
            };
            /**
            *
            * @method _checkOS
            * @private
            */
            Device.prototype._checkOS = function () {
                var ua = navigator.userAgent;
                if (/Android/.test(ua)) {
                    this.android = true;
                }
                else if (/CrOS/.test(ua)) {
                    this.chromeOS = true;
                }
                else if (/iP[ao]d|iPhone/i.test(ua)) {
                    this.iOS = true;
                }
                else if (/Linux/.test(ua)) {
                    this.linux = true;
                }
                else if (/Mac OS/.test(ua)) {
                    this.macOS = true;
                }
                else if (/Windows Phone/.test(ua)) {
                    this.windowsPhone = true;
                }
                else if (/Windows/.test(ua)) {
                    this.windows = true;
                }
            };
            /**
            *
            * @method _checkFeatures
            * @private
            */
            Device.prototype._checkFeatures = function () {
                if (typeof window['Blob'] !== 'undefined')
                    this.blob = true;
                // Check availability of rendering contexts
                this.canvas = !!window['CanvasRenderingContext2D'];
                this.webGL = !!window['WebGLRenderingContext'];
                try {
                    this.localStorage = !!localStorage.getItem;
                }
                catch (error) {
                    this.localStorage = false;
                }
                this.file = !!window['File'] && !!window['FileReader'] && !!window['FileList'] && !!window['Blob'];
                this.fileSystem = !!window['requestFileSystem'];
                this.worker = !!window['Worker'];
                if ('ontouchstart' in document.documentElement ||
                    (window.navigator.msPointerEnabled && window.navigator.msMaxTouchPoints > 0) ||
                    (window.navigator.pointerEnabled && window.navigator.maxTouchPoints > 0)) {
                    this.touch = true;
                }
                if (window.navigator.pointerEnabled || window.navigator.msPointerEnabled) {
                    this.pointerEnabled = true;
                }
            };
            /**
            *
            * @method _checkBrowser
            * @private
            */
            Device.prototype._checkBrowser = function () {
                var ua = navigator.userAgent;
                var an = navigator.appName;
                if (/Arora/.test(ua)) {
                    this.arora = true;
                }
                else if (/Chrome/.test(ua)) {
                    this.chrome = true;
                }
                else if (/Epiphany/.test(ua)) {
                    this.epiphany = true;
                }
                else if (/Firefox/.test(ua)) {
                    this.firefox = true;
                }
                else if (/Mobile Safari/.test(ua)) {
                    this.mobileSafari = true;
                }
                else if (/MSIE (\d+\.\d+);/.test(ua)) {
                    this.ie = true;
                    this.ieVersion = parseInt(RegExp.$1);
                    if (/IEMobile/.test(ua)) {
                        this.ieMobile = true;
                    }
                }
                else if (/Trident/.test(ua)) {
                    this.ie = true;
                    /rv:(\d+\.\d+)\)/.test(ua);
                    this.ieVersion = parseInt(RegExp.$1);
                }
                else if (/Midori/.test(ua)) {
                    this.midori = true;
                }
                else if (/Opera/.test(ua)) {
                    this.opera = true;
                }
                else if (/Safari/.test(ua)) {
                    this.safari = true;
                }
                // WebApp mode in iOS
                if (navigator['standalone']) {
                    this.webApp = true;
                }
            };
            /**
            *
            * @method _checkAudio
            * @private
            */
            Device.prototype._checkAudio = function () {
                this.audioData = !!(window['Audio']);
                this.webaudio = !!(window['webkitAudioContext'] || window['AudioContext']);
                var audioElement = document.createElement('audio');
                var result = false;
                try {
                    if (result = !!audioElement.canPlayType) {
                        if (audioElement.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, '')) {
                            this.ogg = true;
                        }
                        if (audioElement.canPlayType('audio/mpeg;').replace(/^no$/, '')) {
                            this.mp3 = true;
                        }
                        // Mimetypes accepted:
                        //   developer.mozilla.org/En/Media_formats_supported_by_the_audio_and_video_elements
                        //   bit.ly/iphoneoscodecs
                        if (audioElement.canPlayType('audio/wav; codecs="1"').replace(/^no$/, '')) {
                            this.wav = true;
                        }
                        if (audioElement.canPlayType('audio/x-m4a;') || audioElement.canPlayType('audio/aac;').replace(/^no$/, '')) {
                            this.m4a = true;
                        }
                    }
                }
                catch (e) { }
            };
            /**
            *
            * @method _checkDevice
            * @private
            */
            Device.prototype._checkDevice = function () {
                this.pixelRatio = window['devicePixelRatio'] || 1;
                this.iPhone = navigator.userAgent.toLowerCase().indexOf('iphone') != -1;
                this.iPhone4 = (this.pixelRatio == 2 && this.iPhone);
                this.iPad = navigator.userAgent.toLowerCase().indexOf('ipad') != -1;
            };
            /**
            *
            * @method getAll
            * @return {String}
            * @public
            */
            Device.prototype.getAll = function () {
                var output = '';
                output = output.concat('Device\n');
                output = output.concat('iPhone : ' + this.iPhone + '\n');
                output = output.concat('iPhone4 : ' + this.iPhone4 + '\n');
                output = output.concat('iPad : ' + this.iPad + '\n');
                output = output.concat('\n');
                output = output.concat('Operating System\n');
                output = output.concat('iOS: ' + this.iOS + '\n');
                output = output.concat('Android: ' + this.android + '\n');
                output = output.concat('ChromeOS: ' + this.chromeOS + '\n');
                output = output.concat('Linux: ' + this.linux + '\n');
                output = output.concat('MacOS: ' + this.macOS + '\n');
                output = output.concat('Windows: ' + this.windows + '\n');
                output = output.concat('\n');
                output = output.concat('Browser\n');
                output = output.concat('Arora: ' + this.arora + '\n');
                output = output.concat('Chrome: ' + this.chrome + '\n');
                output = output.concat('Epiphany: ' + this.epiphany + '\n');
                output = output.concat('Firefox: ' + this.firefox + '\n');
                output = output.concat('Internet Explorer: ' + this.ie + ' (' + this.ieVersion + ')\n');
                output = output.concat('Mobile Safari: ' + this.mobileSafari + '\n');
                output = output.concat('Midori: ' + this.midori + '\n');
                output = output.concat('Opera: ' + this.opera + '\n');
                output = output.concat('Safari: ' + this.safari + '\n');
                output = output.concat('\n');
                output = output.concat('Features\n');
                output = output.concat('Blob: ' + this.blob + '\n');
                output = output.concat('Canvas: ' + this.canvas + '\n');
                output = output.concat('File: ' + this.file + '\n');
                output = output.concat('FileSystem: ' + this.fileSystem + '\n');
                output = output.concat('LocalStorage: ' + this.localStorage + '\n');
                output = output.concat('WebGL: ' + this.webGL + '\n');
                output = output.concat('Worker: ' + this.worker + '\n');
                output = output.concat('Touch: ' + this.touch + '\n');
                output = output.concat('\n');
                output = output.concat('Audio\n');
                output = output.concat('Audio Data: ' + this.canvas + '\n');
                output = output.concat('Web Audio: ' + this.canvas + '\n');
                output = output.concat('Can play OGG: ' + this.canvas + '\n');
                output = output.concat('Can play MP3: ' + this.canvas + '\n');
                output = output.concat('Can play M4A: ' + this.canvas + '\n');
                output = output.concat('Can play WAV: ' + this.canvas + '\n');
                return output;
            };
            return Device;
        })();
        System.Device = Device;
    })(System = Kiwi.System || (Kiwi.System = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Textures
*
*/
var Kiwi;
(function (Kiwi) {
    var Textures;
    (function (Textures) {
        /**
        * A TextureAtlas is the base class that is created for each image that is loaded through Kiwi. Each TextureAtlas contains a name (the same as the key that the user chose when loading the image in),the HTMLImageElement that it is for and a number of cells.
        *
        * @class TextureAtlas
        * @namespace Kiwi.Textures
        * @constructor
        * @param name {string} Name of the texture atlas. This is usually defined by the developer when loading the assets.
        * @param type {number} The type of texture atlas that this is. There are currently only three types.
        * @param cells {any} The cells that are within this image..
        * @param image {HTMLImageElement/HTMLCanvasElement} The image that the texture atlas is using.
        * @param [sequences] {Sequence[]} Any sequences of cells for this texture atlas. Used for animation.
        * @return {Kiwi.TextureAtlas}
        *
        */
        var TextureAtlas = (function () {
            function TextureAtlas(name, type, cells, image, sequences) {
                /**
                * Indicates that the image data has changed, and needs to be reuplaoded to the gpu in webGL mode.
                * @property dirty
                * @type boolean
                * @public
                */
                this.dirty = false;
                /**
                * The cell that is to be render at the start.
                * @property cellIndex
                * @type number
                * @default 0
                * @public
                */
                this.cellIndex = 0;
                this.name = name;
                this.cells = cells || new Array();
                this.sequences = sequences || new Array();
                this.image = image;
                this._type = type;
            }
            /**
            * The type of object that this texture atlas is.
            * @method objType
            * @return {string} "TextureAtlas"
            * @public
            */
            TextureAtlas.prototype.objType = function () {
                return "TextureAtlas";
            };
            Object.defineProperty(TextureAtlas.prototype, "type", {
                /**
                * Will return to you this type of texture atlas. This is READ ONLY.
                * @type number
                * @public
                */
                get: function () {
                    return this._type;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Creates a GLTextureWrapper to allow the atlas to communicate efficiently with the video card. This is mostly an internal method.
            *
            * If you are extending TextureAtlas to incorporate multiple textures, you will need to override this method.
            * @method createGLTextureWrapper
            * @param gl {WebGLRenderingContext} The rendering context.
            * @param textureManager {Kiwi.Renderers.GLTextureManager} The texture manager.
            * @public
            * @since 1.1.0
            */
            TextureAtlas.prototype.createGLTextureWrapper = function (gl, textureManager) {
                // Create a default texture wrapper
                this.glTextureWrapper = new Kiwi.Renderers.GLTextureWrapper(gl, this);
                // If this were a multi-texture atlas, we would reassign wrapper values here
                // Register wrapper/s to texture manager
                textureManager.registerTextureWrapper(gl, this.glTextureWrapper);
            };
            /**
            * Sends the texture to the video card.
            * @method enableGL
            * @param gl {WebGLRenderingContext}
            * @param renderer {Renderer}
            * @param textureManager {GLTextureManager}
            * @public
            * @since 1.1.0
            */
            TextureAtlas.prototype.enableGL = function (gl, renderer, textureManager) {
                // Set resolution uniforms
                renderer.updateTextureSize(gl, new Float32Array([this.image.width, this.image.height]));
                // Upload texture
                textureManager.useTexture(gl, this.glTextureWrapper);
                // If necessary, refresh the texture
                if (this.dirty)
                    this.refreshTextureGL(gl);
            };
            /**
            * Will reload the texture into video memory for WebGL rendering.
            *
            * @method refreshTextureGL
            * @param glContext {WebGLRenderingContext}
            * @public
            * @since 1.0.1
            */
            TextureAtlas.prototype.refreshTextureGL = function (glContext) {
                if (this.glTextureWrapper)
                    this.glTextureWrapper.refreshTexture(glContext);
                // Clean dirty flag, even if glTextureWrapper failed, so we don't keep calling it
                this.dirty = false;
            };
            /**
            * Will populate this texture atlas with information based on a JSON file that was passed.
            *
            * @method readJSON
            * @param {any} atlasJSON
            * @public
            */
            TextureAtlas.prototype.readJSON = function (atlasJSON) {
                //populate from json
                var obj = JSON.parse(atlasJSON);
                if (obj.name !== undefined)
                    this.name = obj.name;
                for (var i = 0; i < obj.cells.length; i++) {
                    this.cells.push(obj.cells[i]);
                    if (obj.cells[i].hitboxes === undefined) {
                        this.cells[i].hitboxes = new Array();
                        this.cells[i].hitboxes.push({ x: 0, y: 0, w: this.cells[i].w, h: this.cells[i].h });
                    }
                }
                if (obj.sequences) {
                    for (var i = 0; i < obj.sequences.length; i++) {
                        var seq = new Kiwi.Animations.Sequence(obj.sequences[i].name, obj.sequences[i].cells);
                        if (obj.sequences[i].speed !== undefined)
                            seq.speed = obj.sequences[i].speed;
                        if (obj.sequences[i].loop !== undefined)
                            seq.loop = obj.sequences[i].loop;
                        this.sequences.push(seq);
                    }
                }
            };
            /**
            * The number that defines a single image type of texture atlas
            * @property SINGLE_IMAGE
            * @static
            * @default 0
            * @type number
            * @final
            * @public
            */
            TextureAtlas.SINGLE_IMAGE = 0;
            /**
            * The number that defines a spritesheet type of texture atlas
            * @property SPRITE_SHEET
            * @static
            * @default 1
            * @type number
            * @final
            * @public
            */
            TextureAtlas.SPRITE_SHEET = 1;
            /**
            * The number that defines a normal texture atlas
            * @property TEXTURE_ATLAS
            * @static
            * @default 2
            * @type number
            * @final
            * @public
            */
            TextureAtlas.TEXTURE_ATLAS = 2;
            return TextureAtlas;
        })();
        Textures.TextureAtlas = TextureAtlas;
    })(Textures = Kiwi.Textures || (Kiwi.Textures = {}));
})(Kiwi || (Kiwi = {}));
/**
* Contains Objects that are used when dealing specifically with Textures/Images. Majority of these classes are for Internal Kiwi use.
*
* @module Kiwi
* @submodule Textures
* @main Textures
*
*/
var Kiwi;
(function (Kiwi) {
    var Textures;
    (function (Textures) {
        /**
        * Holds a reference to all of the image files (jpg, png, e.t.c) that are accessible on the State this TextureLibrary is on.
        *
        * @class TextureLibrary
        * @namespace Kiwi.Textures
        * @constructor
        * @param game {Game} The game that this texture library belongs to.
        * @return {Kiwi.TextureLibrary}
        *
        */
        var TextureLibrary = (function () {
            function TextureLibrary(game) {
                this._game = game;
                this.textures = new Object();
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {string}
            * @public
            */
            TextureLibrary.prototype.objType = function () {
                return "TextureLibrary";
            };
            /**
            * Resets the texture library.
            * @method clear
            * @public
            */
            TextureLibrary.prototype.clear = function () {
                for (var prop in this.textures) {
                    delete this.textures[prop];
                }
            };
            /**
            * Adds a texture atlas to the library.
            * @method add
            * @param atlas {Kiwi.Textures.TextureAtlas}
            * @public
            */
            TextureLibrary.prototype.add = function (atlas) {
                this.textures[atlas.name] = atlas;
                if (this._game.renderOption === Kiwi.RENDERER_WEBGL) {
                    if (Kiwi.Utils.Common.base2Sizes.indexOf(atlas.image.width) == -1 || Kiwi.Utils.Common.base2Sizes.indexOf(atlas.image.height) == -1) {
                        Kiwi.Log.log("Kiwi.TextureLibrary: Warning:Image is not of base2 size and may not render correctly.", '#texture', '#base2');
                    }
                    var renderManager = this._game.renderer;
                    renderManager.addTexture(this._game.stage.gl, atlas);
                }
            };
            /**
            * Adds a new image file to the texture library.
            * @method addFromFile
            * @param imageFile {Kiwi.File}
            * @public
            */
            TextureLibrary.prototype.addFromFile = function (imageFile) {
                if (this._game.renderOption === Kiwi.RENDERER_WEBGL && this._game.deviceTargetOption != Kiwi.TARGET_COCOON) {
                    imageFile = this._rebuildImage(imageFile);
                }
                switch (imageFile.dataType) {
                    case Kiwi.Files.File.SPRITE_SHEET:
                        this.textures[imageFile.key] = this._buildSpriteSheet(imageFile);
                        break;
                    case Kiwi.Files.File.IMAGE:
                        this.textures[imageFile.key] = this._buildImage(imageFile);
                        break;
                    case Kiwi.Files.File.TEXTURE_ATLAS:
                        this.textures[imageFile.key] = this._buildTextureAtlas(imageFile);
                        break;
                    default:
                        //Image file is of unknown type and was not added to texture library
                        break;
                }
            };
            /**
            * Used to rebuild a Texture from the FileStore into a base2 size if it doesn't have it already.
            * @method _rebuildImage
            * @param imageFile {Kiwi.File} The image file that is to be rebuilt.
            * @return {Kiwi.File} The new image file.
            * @private
            */
            TextureLibrary.prototype._rebuildImage = function (imageFile) {
                //Check to see if it is base 2
                var newImg = Kiwi.Utils.Common.convertToBase2(imageFile.data);
                //Was it resized? We can check to see if the width/height has changed.
                if (imageFile.data.width !== newImg.width || imageFile.data.height !== newImg.height) {
                    if (imageFile.dataType === Kiwi.Files.File.SPRITE_SHEET) {
                        //If no rows were passed then calculate them now.
                        if (!imageFile.metadata.rows)
                            imageFile.metadata.rows = imageFile.data.height / imageFile.metadata.frameHeight;
                        //If no columns were passed then calculate them again.
                        if (!imageFile.metadata.cols)
                            imageFile.metadata.cols = imageFile.data.width / imageFile.metadata.frameWidth;
                    }
                    else if (imageFile.dataType === Kiwi.Files.File.IMAGE) {
                        if (!imageFile.metadata.width)
                            imageFile.metadata.width = imageFile.data.width;
                        if (!imageFile.metadata.height)
                            imageFile.metadata.height = imageFile.data.height;
                    }
                    Kiwi.Log.log('Kiwi.TextureLibrary: ' + imageFile.name + ' has been rebuilt to be base2.', '#texture', '#base2');
                    //Assign the new image to the data
                    imageFile.data = newImg;
                }
                return imageFile;
            };
            /**
            * Used to build a new texture atlas based on the image file provided. Internal use only.
            * @method _buildTextureAtlas
            * @param imageFile {Kiwi.File} The image file that is to be used.
            * @return {Kiwi.Textures.TextureAtlas} The new texture atlas that is created.
            * @private
            */
            TextureLibrary.prototype._buildTextureAtlas = function (imageFile) {
                var atlas = new Kiwi.Textures.TextureAtlas(imageFile.key, Kiwi.Textures.TextureAtlas.TEXTURE_ATLAS, null, imageFile.data);
                var m = imageFile.metadata;
                try {
                    var json = this._game.fileStore.getFile(m.jsonID).data;
                    json.trim();
                    atlas.readJSON(json);
                    return atlas;
                }
                catch (e) {
                    Kiwi.Log.error("  Kiwi.Textures.TextureLibrary: Failed to extract information for '" + imageFile.key + "' from JSON file '" + m.jsonID + "'", '#error', '#texture', 'Message: ' + e.message);
                }
                return null;
            };
            /**
            * Builds a spritesheet atlas from the an image file that is provided.
            * @method _buildSpriteSheet
            * @param imageFile {Kiwi.File} The image file that is to be used.
            * @return {Kiwi.Textures.SpriteSheet} The SpriteSheet that was just created.
            * @private
            */
            TextureLibrary.prototype._buildSpriteSheet = function (imageFile) {
                var m = imageFile.metadata;
                //BEWARE THE SWITCH TO CELLWIDTH AND FRAMEWIDTH
                var spriteSheet = new Kiwi.Textures.SpriteSheet(imageFile.key, imageFile.data, m.frameWidth, m.frameHeight, m.numCells, m.rows, m.cols, m.sheetOffsetX, m.sheetOffsetY, m.cellOffsetX, m.cellOffsetY);
                return spriteSheet;
            };
            /**
            * Builds a single image atlas from a image file that is provided.
            * @method _buildImage
            * @param imageFile {File} The image file that is to be used.
            * @return {Kiwi.Textures.SingleImage} The SingleImage that was created.
            * @private
            */
            TextureLibrary.prototype._buildImage = function (imageFile) {
                var m = imageFile.metadata;
                return new Kiwi.Textures.SingleImage(imageFile.key, imageFile.data, m.width, m.height, m.offsetX, m.offsetY);
            };
            /**
             * Rebuild the library from a fileStore. Clears the library and repopulates it.
             * @method rebuild
             * @param {Kiwi.Files.FileStore} fileStore
             * @param {Kiwi.State} state
             * @public
             */
            TextureLibrary.prototype.rebuild = function (fileStore, state) {
                this.clear();
                Kiwi.Log.log("Kiwi.TextureLibrary: Rebuilding Texture Library", '#texture', '#rebuild');
                var fileStoreKeys = fileStore.keys;
                for (var i = 0; i < fileStoreKeys.length; i++) {
                    var file = this._game.fileStore.getFile(fileStoreKeys[i]);
                    if (file.isTexture) {
                        Kiwi.Log.log("  Kiwi.TextureLibrary: Adding Texture: " + file.name, '#texture', '#added');
                        state.textureLibrary.addFromFile(file);
                    }
                }
            };
            return TextureLibrary;
        })();
        Textures.TextureLibrary = TextureLibrary;
    })(Textures = Kiwi.Textures || (Kiwi.Textures = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Textures
*
*/
var Kiwi;
(function (Kiwi) {
    var Textures;
    (function (Textures) {
        /**
        * A special type of TextureAtlas that is created when loading in images that are design to be SpriteSheets. A SpriteSheet will generally contain multiple cells and can also contain sequences which are then automatically added as Animations when this texture is used on a Sprite.
        *
        * @class SpriteSheet
        * @extends TextureAtlas
        * @namespace Kiwi.Textures
        * @constructor
        * @param name {string} The name of the spritesheet.
        * @param texture {HTMLImageElement/HTMLCanvasElement} The image that is being used for the spritesheet.
        * @param cellWidth {number} The width of a single cell.
        * @param cellHeight {number} The height of a single cell.
        * @param [numCells] {number} The number of cells in total.
        * @param [rows] {number} The number of cells that make up a row.
        * @param [cols] {number} The number of cells that make up a column.
        * @param [sheetOffsetX] {number} The offset of the whole sheet on the x axis. Useful if the image has a border you don't want to show.
        * @param [sheetOffsetY] {number} The offset of the whole sheet on the y axis. Useful if the image has a border you don't want to show.
        * @param [cellOffsetX] {number} An offset between cells on the x axis. Useful if there is a border between cells which is not to be shown.
        * @param [cellOffsetY] {number} An offset between cells on the y axis. Useful if there is a border between cells which is not to be shown.
        * @return {SpriteSheet}
        */
        var SpriteSheet = (function (_super) {
            __extends(SpriteSheet, _super);
            function SpriteSheet(name, texture, cellWidth, cellHeight, numCells, rows, cols, sheetOffsetX, sheetOffsetY, cellOffsetX, cellOffsetY) {
                this.cellWidth = cellWidth;
                this.cellHeight = cellHeight;
                this._cols = cols || texture.width / cellWidth;
                this._rows = rows || texture.height / cellHeight;
                this.numCells = numCells || this.cols * this.rows;
                this.sheetOffsetX = sheetOffsetX || 0;
                this.sheetOffsetY = sheetOffsetY || 0;
                this.cellOffsetX = cellOffsetX || 0;
                this.cellOffsetY = cellOffsetY || 0;
                _super.call(this, name, Kiwi.Textures.TextureAtlas.SPRITE_SHEET, this.generateAtlasCells(), texture, this.sequences);
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {string} "SpriteSheet"
            * @public
            */
            SpriteSheet.prototype.objType = function () {
                return "SpriteSheet";
            };
            Object.defineProperty(SpriteSheet.prototype, "rows", {
                /**
                * Get the number of rows.
                * @type number
                * @public
                */
                get: function () {
                    return this._rows;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SpriteSheet.prototype, "cols", {
                /**
                * Get the number of columns.
                * @type number
                * @public
                */
                get: function () {
                    return this._cols;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Generates the atlas cells based on the information that was provided.
            *
            * @method generateAtlasCells
            * @return {Array}
            * @public
            */
            SpriteSheet.prototype.generateAtlasCells = function () {
                var cells = new Array();
                var cellNumeric = new Array();
                var dx = this.sheetOffsetX;
                var dy = this.sheetOffsetY;
                var i = 0;
                for (var y = 0; y < this.rows; y++) {
                    for (var x = 0; x < this.cols; x++) {
                        if (i >= this.numCells)
                            continue;
                        cells.push({
                            x: dx,
                            y: dy,
                            w: this.cellWidth,
                            h: this.cellHeight,
                            hitboxes: [
                                {
                                    x: 0,
                                    y: 0,
                                    w: this.cellWidth,
                                    h: this.cellHeight
                                }
                            ]
                        });
                        cellNumeric.push(i++);
                        dx += this.cellOffsetX + this.cellWidth;
                    }
                    dx = this.sheetOffsetX;
                    dy += this.cellOffsetY + this.cellHeight;
                }
                //generate default sequence
                this.sequences = new Array();
                this.sequences.push(new Kiwi.Animations.Sequence('default', cellNumeric));
                return cells;
            };
            return SpriteSheet;
        })(Textures.TextureAtlas);
        Textures.SpriteSheet = SpriteSheet;
    })(Textures = Kiwi.Textures || (Kiwi.Textures = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Textures
*
*/
var Kiwi;
(function (Kiwi) {
    var Textures;
    (function (Textures) {
        /**
        * A special type of TextureAtlas that is used when the user has loaded a single image. This type of TextureAtlas contains only one cell which is generally the whole width/height of the image and starts at the coordinates 0/0. A SingleImage has a space to store sequences but this will not be used.
        *
        * @class SingleImage
        * @extends TextureAtlas
        * @namespace Kiwi.Textures
        * @constructor
        * @param name {string} The name of the single image
        * @param image {HTMLImageElement/HTMLCanvasElement} the image that is being used.
        * @param [width] {number} the width of the image
        * @param [height] {number} the height of the image
        * @param [offsetX] {number} the offset of the image on the x axis. Useful if the image has a border that you don't want to show.
        * @param [offsetY] {number} the offset of the image of the y axis. Useful if the image has a border that you don't want to show.
        * @return {Kiwi.SingleImage}
        */
        var SingleImage = (function (_super) {
            __extends(SingleImage, _super);
            function SingleImage(name, image, width, height, offsetX, offsetY) {
                this.width = width || image.width;
                this.height = height || image.height;
                this.offsetX = offsetX || 0;
                this.offsetY = offsetY || 0;
                _super.call(this, name, Kiwi.Textures.TextureAtlas.SINGLE_IMAGE, this.generateAtlasCells(), image);
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {string} "SingleImage"
            * @public
            */
            SingleImage.prototype.objType = function () {
                return "SingleImage";
            };
            /**
            * This method generates the single image cell based off the information that was passed during instantion.
            * @method generateAtlasCells
            * @returns{ Array }
            * @public
            */
            SingleImage.prototype.generateAtlasCells = function () {
                return [{ x: this.offsetX, y: this.offsetY, w: this.width, h: this.height, hitboxes: [{ x: 0, y: 0, w: this.width, h: this.height }] }];
            };
            return SingleImage;
        })(Textures.TextureAtlas);
        Textures.SingleImage = SingleImage;
    })(Textures = Kiwi.Textures || (Kiwi.Textures = {}));
})(Kiwi || (Kiwi = {}));
/**
* Contains various methods that can be used when you are wanting to ease a Tween.
*
* @module Tweens
* @submodule Easing
* @main Easing
*/
var Kiwi;
(function (Kiwi) {
    var Animations;
    (function (Animations) {
        var Tweens;
        (function (Tweens) {
            var Easing;
            (function (Easing) {
                /**
                *
                * @class Back
                * @namespace Kiwi.Animations.Tweens.Easing
                *
                */
                var Back = (function () {
                    function Back() {
                    }
                    /**
                    * The type of object this is.
                    * @method objType
                    * @return {String} "Back"
                    * @public
                    */
                    Back.prototype.objType = function () {
                        return "Back";
                    };
                    /**
                    *
                    * @method In
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Back.In = function (k) {
                        var s = 1.70158;
                        return k * k * ((s + 1) * k - s);
                    };
                    /**
                    *
                    * @method Out
                    * @param {Any} k
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Back.Out = function (k) {
                        var s = 1.70158;
                        return --k * k * ((s + 1) * k + s) + 1;
                    };
                    /**
                    *
                    * @method InOut
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Back.InOut = function (k) {
                        var s = 1.70158 * 1.525;
                        if ((k *= 2) < 1)
                            return 0.5 * (k * k * ((s + 1) * k - s));
                        return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
                    };
                    return Back;
                })();
                Easing.Back = Back;
            })(Easing = Tweens.Easing || (Tweens.Easing = {}));
        })(Tweens = Animations.Tweens || (Animations.Tweens = {}));
    })(Animations = Kiwi.Animations || (Kiwi.Animations = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Tweens
* @submodule Easing
*
*/
var Kiwi;
(function (Kiwi) {
    var Animations;
    (function (Animations) {
        var Tweens;
        (function (Tweens) {
            var Easing;
            (function (Easing) {
                /**
                *
                * @class Bounce
                * @namespace Kiwi.Animations.Tweens.Easing
                *
                */
                var Bounce = (function () {
                    function Bounce() {
                    }
                    /**
                    * The type of object that this is.
                    * @method objType
                    * @return {String} "Bounce"
                    * @public
                    */
                    Bounce.prototype.objType = function () {
                        return "Bounce";
                    };
                    /**
                    *
                    * @method In
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Bounce.In = function (k) {
                        return 1 - Kiwi.Animations.Tweens.Easing.Bounce.Out(1 - k);
                    };
                    /**
                    *
                    * @method Out
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Bounce.Out = function (k) {
                        if (k < (1 / 2.75)) {
                            return 7.5625 * k * k;
                        }
                        else if (k < (2 / 2.75)) {
                            return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
                        }
                        else if (k < (2.5 / 2.75)) {
                            return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
                        }
                        else {
                            return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
                        }
                    };
                    /**
                    *
                    * @method InOut
                    * @param {Any} k
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Bounce.InOut = function (k) {
                        if (k < 0.5)
                            return Kiwi.Animations.Tweens.Easing.Bounce.In(k * 2) * 0.5;
                        return Kiwi.Animations.Tweens.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;
                    };
                    return Bounce;
                })();
                Easing.Bounce = Bounce;
            })(Easing = Tweens.Easing || (Tweens.Easing = {}));
        })(Tweens = Animations.Tweens || (Animations.Tweens = {}));
    })(Animations = Kiwi.Animations || (Kiwi.Animations = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Tweens
* @submodule Easing
*
*/
var Kiwi;
(function (Kiwi) {
    var Animations;
    (function (Animations) {
        var Tweens;
        (function (Tweens) {
            var Easing;
            (function (Easing) {
                /**
                *
                *
                * @class Circular
                * @namespace Kiwi.Animations.Tweens.Easing
                *
                */
                var Circular = (function () {
                    function Circular() {
                    }
                    /**
                    * The type of object that this is.
                    * @method objType
                    * @return {String} "Circular"
                    * @public
                    */
                    Circular.prototype.objType = function () {
                        return "Circular";
                    };
                    /**
                    *
                    * @method In
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    */
                    Circular.In = function (k) {
                        return 1 - Math.sqrt(1 - k * k);
                    };
                    /**
                    *
                    * @method Out
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    */
                    Circular.Out = function (k) {
                        return Math.sqrt(1 - (--k * k));
                    };
                    /**
                    *
                    * @method InOut
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    */
                    Circular.InOut = function (k) {
                        if ((k *= 2) < 1)
                            return -0.5 * (Math.sqrt(1 - k * k) - 1);
                        return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
                    };
                    return Circular;
                })();
                Easing.Circular = Circular;
            })(Easing = Tweens.Easing || (Tweens.Easing = {}));
        })(Tweens = Animations.Tweens || (Animations.Tweens = {}));
    })(Animations = Kiwi.Animations || (Kiwi.Animations = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Tweens
* @submodule Easing
*
*/
var Kiwi;
(function (Kiwi) {
    var Animations;
    (function (Animations) {
        var Tweens;
        (function (Tweens) {
            var Easing;
            (function (Easing) {
                /**
                *
                * @class Cubic
                * @namespace Kiwi.Animations.Tweens.Easing
                *
                */
                var Cubic = (function () {
                    function Cubic() {
                    }
                    /**
                    * The type of object that this is.
                    * @method objType
                    * @return {String} "Cubic"
                    * @public
                    */
                    Cubic.prototype.objType = function () {
                        return "Cubic";
                    };
                    /**
                    *
                    * @method In
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Cubic.In = function (k) {
                        return k * k * k;
                    };
                    /**
                    *
                    * @method Out
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Cubic.Out = function (k) {
                        return --k * k * k + 1;
                    };
                    /**
                    *
                    * @method InOut
                    * @param k {Any}
                    * @static
                    * @public
                    */
                    Cubic.InOut = function (k) {
                        if ((k *= 2) < 1)
                            return 0.5 * k * k * k;
                        return 0.5 * ((k -= 2) * k * k + 2);
                    };
                    return Cubic;
                })();
                Easing.Cubic = Cubic;
            })(Easing = Tweens.Easing || (Tweens.Easing = {}));
        })(Tweens = Animations.Tweens || (Animations.Tweens = {}));
    })(Animations = Kiwi.Animations || (Kiwi.Animations = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Tweens
* @submodule Easing
*
*/
var Kiwi;
(function (Kiwi) {
    var Animations;
    (function (Animations) {
        var Tweens;
        (function (Tweens) {
            var Easing;
            (function (Easing) {
                /**
                *
                *
                * @class Elastic
                * @namespace Kiwi.Animations.Tweens.Easing
                *
                */
                var Elastic = (function () {
                    function Elastic() {
                    }
                    /**
                    * The type of object that this is.
                    * @method objType
                    * @return {String} "Elastic"
                    * @public
                    */
                    Elastic.prototype.objType = function () {
                        return "Elastic";
                    };
                    /**
                    *
                    * @method In
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Elastic.In = function (k) {
                        var s, a = 0.1, p = 0.4;
                        if (k === 0)
                            return 0;
                        if (k === 1)
                            return 1;
                        if (!a || a < 1) {
                            a = 1;
                            s = p / 4;
                        }
                        else
                            s = p * Math.asin(1 / a) / (2 * Math.PI);
                        return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
                    };
                    /**
                    *
                    * @method Out
                    * @param {Any} k
                    * @static
                    * @public
                    */
                    Elastic.Out = function (k) {
                        var s, a = 0.1, p = 0.4;
                        if (k === 0)
                            return 0;
                        if (k === 1)
                            return 1;
                        if (!a || a < 1) {
                            a = 1;
                            s = p / 4;
                        }
                        else
                            s = p * Math.asin(1 / a) / (2 * Math.PI);
                        return (a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1);
                    };
                    /**
                    *
                    * @method InOut
                    * @param k {Any}
                    * @static
                    * @public
                    */
                    Elastic.InOut = function (k) {
                        var s, a = 0.1, p = 0.4;
                        if (k === 0)
                            return 0;
                        if (k === 1)
                            return 1;
                        if (!a || a < 1) {
                            a = 1;
                            s = p / 4;
                        }
                        else
                            s = p * Math.asin(1 / a) / (2 * Math.PI);
                        if ((k *= 2) < 1)
                            return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
                        return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
                    };
                    return Elastic;
                })();
                Easing.Elastic = Elastic;
            })(Easing = Tweens.Easing || (Tweens.Easing = {}));
        })(Tweens = Animations.Tweens || (Animations.Tweens = {}));
    })(Animations = Kiwi.Animations || (Kiwi.Animations = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Tweens
* @submodule Easing
*
*/
var Kiwi;
(function (Kiwi) {
    var Animations;
    (function (Animations) {
        var Tweens;
        (function (Tweens) {
            var Easing;
            (function (Easing) {
                /**
                *
                *
                * @class Exponential
                * @namespace Kiwi.Animations.Tweens.Easing
                *
                */
                var Exponential = (function () {
                    function Exponential() {
                    }
                    /**
                    * The type of object that this is.
                    * @method objType
                    * @return {String} "Exponential"
                    * @public
                    */
                    Exponential.prototype.objType = function () {
                        return "Exponential";
                    };
                    /**
                    *
                    * @method In
                    * @param k {Any}
                    * @return {String}
                    * @static
                    * @public
                    */
                    Exponential.In = function (k) {
                        return k === 0 ? 0 : Math.pow(1024, k - 1);
                    };
                    /**
                    *
                    * @method Out
                    * @param k {Any}
                    * @return {String}
                    * @static
                    * @public
                    */
                    Exponential.Out = function (k) {
                        return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
                    };
                    /**
                    *
                    * @method InOut
                    * @param k {Any}
                    * @return {String}
                    * @static
                    * @public
                    */
                    Exponential.InOut = function (k) {
                        if (k === 0)
                            return 0;
                        if (k === 1)
                            return 1;
                        if ((k *= 2) < 1)
                            return 0.5 * Math.pow(1024, k - 1);
                        return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
                    };
                    return Exponential;
                })();
                Easing.Exponential = Exponential;
            })(Easing = Tweens.Easing || (Tweens.Easing = {}));
        })(Tweens = Animations.Tweens || (Animations.Tweens = {}));
    })(Animations = Kiwi.Animations || (Kiwi.Animations = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Tweens
* @submodule Easing
*
*/
var Kiwi;
(function (Kiwi) {
    var Animations;
    (function (Animations) {
        var Tweens;
        (function (Tweens) {
            var Easing;
            (function (Easing) {
                /**
                *
                * @class Linear
                * @namespace Kiwi.Animations.Tweens.Easing
                *
                */
                var Linear = (function () {
                    function Linear() {
                    }
                    /**
                    * The type of object that this is.
                    * @method objType
                    * @return {String} "Linear"
                    * @public
                    */
                    Linear.prototype.objType = function () {
                        return "Linear";
                    };
                    /**
                    *
                    * @method None
                    * @param {Any} k
                    * @return {Number}
                    * @static
                    */
                    Linear.None = function (k) {
                        return k;
                    };
                    return Linear;
                })();
                Easing.Linear = Linear;
            })(Easing = Tweens.Easing || (Tweens.Easing = {}));
        })(Tweens = Animations.Tweens || (Animations.Tweens = {}));
    })(Animations = Kiwi.Animations || (Kiwi.Animations = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Tweens
* @submodule Easing
*
*/
var Kiwi;
(function (Kiwi) {
    var Animations;
    (function (Animations) {
        var Tweens;
        (function (Tweens) {
            var Easing;
            (function (Easing) {
                /**
                *
                *
                * @class Quadratic
                * @namespace Kiwi.Animations.Tweens.Easing
                *
                */
                var Quadratic = (function () {
                    function Quadratic() {
                    }
                    /**
                    * The type of object that this is.
                    * @method objType
                    * @return {String} "Quadratic"
                    * @public
                    */
                    Quadratic.prototype.objType = function () {
                        return "Quadratic";
                    };
                    /**
                    *
                    * @method In
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Quadratic.In = function (k) {
                        return k * k;
                    };
                    /**
                    *
                    * @method Out
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Quadratic.Out = function (k) {
                        return k * (2 - k);
                    };
                    /**
                    *
                    * @method InOut
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Quadratic.InOut = function (k) {
                        if ((k *= 2) < 1)
                            return 0.5 * k * k;
                        return -0.5 * (--k * (k - 2) - 1);
                    };
                    return Quadratic;
                })();
                Easing.Quadratic = Quadratic;
            })(Easing = Tweens.Easing || (Tweens.Easing = {}));
        })(Tweens = Animations.Tweens || (Animations.Tweens = {}));
    })(Animations = Kiwi.Animations || (Kiwi.Animations = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Tweens
* @submodule Easing
*
*/
var Kiwi;
(function (Kiwi) {
    var Animations;
    (function (Animations) {
        var Tweens;
        (function (Tweens) {
            var Easing;
            (function (Easing) {
                /**
                *
                * @class Quartic
                * @namespace Kiwi.Animations.Tweens.Easing
                *
                */
                var Quartic = (function () {
                    function Quartic() {
                    }
                    /**
                    * The type of object that this is.
                    * @method objType
                    * @return {String} "Quartic"
                    * @public
                    */
                    Quartic.prototype.objType = function () {
                        return "Quartic";
                    };
                    /**
                    *
                    * @method In
                    * @param k {Any}
                    * @return {String}
                    * @static
                    * @public
                    */
                    Quartic.In = function (k) {
                        return k * k * k * k;
                    };
                    /**
                    *
                    * @method Out
                    * @param k {Any}
                    * @return {String}
                    * @static
                    * @public
                    */
                    Quartic.Out = function (k) {
                        return 1 - (--k * k * k * k);
                    };
                    /**
                    *
                    * @method InOut
                    * @param k {Any}
                    * @return {String}
                    * @static
                    * @public
                    */
                    Quartic.InOut = function (k) {
                        if ((k *= 2) < 1)
                            return 0.5 * k * k * k * k;
                        return -0.5 * ((k -= 2) * k * k * k - 2);
                    };
                    return Quartic;
                })();
                Easing.Quartic = Quartic;
            })(Easing = Tweens.Easing || (Tweens.Easing = {}));
        })(Tweens = Animations.Tweens || (Animations.Tweens = {}));
    })(Animations = Kiwi.Animations || (Kiwi.Animations = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Tweens
* @submodule Easing
*
*/
var Kiwi;
(function (Kiwi) {
    var Animations;
    (function (Animations) {
        var Tweens;
        (function (Tweens) {
            var Easing;
            (function (Easing) {
                /**
                *
                * @class Quintic
                * @namespace Kiwi.Animations.Tweens.Easing
                *
                */
                var Quintic = (function () {
                    function Quintic() {
                    }
                    /**
                    * The type of object that this is.
                    * @method objType
                    * @return {String} "Quintic"
                    * @public
                    */
                    Quintic.prototype.objType = function () {
                        return "Quintic";
                    };
                    /**
                    *
                    * @method In
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Quintic.In = function (k) {
                        return k * k * k * k * k;
                    };
                    /**
                    *
                    * @method Out
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Quintic.Out = function (k) {
                        return --k * k * k * k * k + 1;
                    };
                    /**
                    *
                    * @method InOut
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Quintic.InOut = function (k) {
                        if ((k *= 2) < 1)
                            return 0.5 * k * k * k * k * k;
                        return 0.5 * ((k -= 2) * k * k * k * k + 2);
                    };
                    return Quintic;
                })();
                Easing.Quintic = Quintic;
            })(Easing = Tweens.Easing || (Tweens.Easing = {}));
        })(Tweens = Animations.Tweens || (Animations.Tweens = {}));
    })(Animations = Kiwi.Animations || (Kiwi.Animations = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Tweens
* @submodule Easing
*
*/
var Kiwi;
(function (Kiwi) {
    var Animations;
    (function (Animations) {
        var Tweens;
        (function (Tweens) {
            var Easing;
            (function (Easing) {
                /**
                *
                * @class Sinusoidal
                * @namespace Kiwi.Animations.Tweens.Easing
                *
                */
                var Sinusoidal = (function () {
                    function Sinusoidal() {
                    }
                    /**
                    * The type of object that this is.
                    * @method objType
                    * @return {String} "Sinusoidal"
                    * @public
                    */
                    Sinusoidal.prototype.objType = function () {
                        return "Sinusoidal";
                    };
                    /**
                    *
                    * @method In
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Sinusoidal.In = function (k) {
                        return 1 - Math.cos(k * Math.PI / 2);
                    };
                    /**
                    *
                    * @method Out
                    * @param k {Any}
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Sinusoidal.Out = function (k) {
                        return Math.sin(k * Math.PI / 2);
                    };
                    /**
                    *
                    * @method InOut
                    * @param {Any} k
                    * @return {Number}
                    * @static
                    * @public
                    */
                    Sinusoidal.InOut = function (k) {
                        return 0.5 * (1 - Math.cos(Math.PI * k));
                    };
                    return Sinusoidal;
                })();
                Easing.Sinusoidal = Sinusoidal;
            })(Easing = Tweens.Easing || (Tweens.Easing = {}));
        })(Tweens = Animations.Tweens || (Animations.Tweens = {}));
    })(Animations = Kiwi.Animations || (Kiwi.Animations = {}));
})(Kiwi || (Kiwi = {}));
/**
* The section of Kiwi which holds the scripts that manage Tween's in Kiwi. The scripts in this section are based on Tween.js by sole and have been converted to TypeScript and integrated into Kiwi. https://github.com/sole/tween.js
*
* @module Animations
* @submodule Tweens
* @main Tweens
*/
var Kiwi;
(function (Kiwi) {
    var Animations;
    (function (Animations) {
        var Tweens;
        (function (Tweens) {
            /**
            * The TweenManager is automatically created on every game. This class is responsible for the creation and management of tweens for the game.
            *
            * Based on tween.js by sole. Converted to TypeScript and integrated into Kiwi.
            * https://github.com/sole/tween.js
            *
            * @class TweenManager
            * @namespace Kiwi.Animations.Tweens
            * @constructor
            * @param game {Kiwi.Game} Current game
            * @param [clock] {Kiwi.Time.Clock} Clock to use for tweens.
            *   Defaults to game.time.clock.
            * @return {Kiwi.Animations.TweenManager}
            *
            * @author     sole / http://soledadpenades.com
            * @author     mrdoob / http://mrdoob.com
            * @author     Robert Eisele / http://www.xarg.org
            * @author     Philippe / http://philippe.elsass.me
            * @author     Robert Penner / http://www.robertpenner.com/easing_terms_of_use.html
            * @author     Paul Lewis / http://www.aerotwist.com/
            * @author     lechecacharro
            * @author     Josh Faul / http://jocafa.com/
            * @author     egraether / http://egraether.com/
            *
            */
            var TweenManager = (function () {
                function TweenManager(game, clock) {
                    this._game = game;
                    this._tweens = [];
                    this.clock = clock || this._game.time.clock;
                }
                /**
                * The type of object that this is.
                * @method objType
                * @return {String} "TweenManager"
                * @public
                */
                TweenManager.prototype.objType = function () {
                    return "TweenManager";
                };
                /**
                * Returns all of tweens that are on the manager.
                * @method getAll
                * @return Kiwi.Animations.Tween[]
                * @public
                */
                TweenManager.prototype.getAll = function () {
                    return this._tweens;
                };
                /**
                * Removes all of the tweens on the manager.
                * @method removeAll
                * @public
                */
                TweenManager.prototype.removeAll = function () {
                    this._tweens.length = 0;
                };
                /**
                * Creates a new Tween.
                * @method create
                * @param object {Any} The object that this tween is to apply.
                * @return {Kiwi.Animations.Tween} The tween that was created.
                * @public
                */
                TweenManager.prototype.create = function (object) {
                    var tween = new Kiwi.Animations.Tween(object, this._game);
                    this.validateClock();
                    tween.manager = this;
                    return tween;
                };
                /**
                * Adds a tween to the manager.
                * @method add
                * @param tween {Kiwi.Animations.Tween} The tween that you want to add to the manager.
                * @return {Kiwi.Animations.Tween}
                * @public
                */
                TweenManager.prototype.add = function (tween) {
                    tween.setParent(this._game);
                    tween.manager = this;
                    this.validateClock();
                    this._tweens.push(tween);
                    return tween;
                };
                /**
                * Removes a tween from this manager.
                * @method remove
                * @param tween {Kiwi.Animations.Tween} The tween that you would like to remove.
                * @return {Kiwi.Animations.Tween} The tween passed in.
                * @public
                */
                TweenManager.prototype.remove = function (tween) {
                    var i = this._tweens.indexOf(tween);
                    if (i !== -1) {
                        this._tweens.splice(i, 1);
                    }
                    return tween;
                };
                /**
                * The update loop.
                * @method update
                * @return {boolean} Whether anything was updated
                * @public
                */
                TweenManager.prototype.update = function () {
                    var i = 0, numTweens = this._tweens.length;
                    if (this._tweens.length === 0) {
                        return false;
                    }
                    while (i < numTweens) {
                        if (this._tweens[i].update(this.clock.elapsed() * 1000)) {
                            i++;
                        }
                        else {
                            this._tweens.splice(i, 1);
                            numTweens--;
                        }
                    }
                    return true;
                };
                /**
                * Validate clock; if no valid clock is found, set one from game
                * @method validateClock
                * @public
                * @since 1.2.0
                */
                TweenManager.prototype.validateClock = function () {
                    if (!this.clock) {
                        this.clock = this._game.time.clock;
                        if (!this.clock) {
                            Kiwi.Log.error("Tween manager could not find valid clock!");
                        }
                    }
                };
                return TweenManager;
            })();
            Tweens.TweenManager = TweenManager;
        })(Tweens = Animations.Tweens || (Animations.Tweens = {}));
    })(Animations = Kiwi.Animations || (Kiwi.Animations = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Animations
* @submodule Tweens
*
*/
var Kiwi;
(function (Kiwi) {
    var Animations;
    (function (Animations) {
        /**
        * Manages the tweening of properties/values on a single object. A Tween is the animation of a number between an initially value to and final value (that you specify).
        * Note: When using a Tween you need to make sure that the Tween has been added to a TweenManager. You can either do this by creating the Tween via the Manager or alternatively using the 'add' method on the TweenManager. Otherwise the tween will not work.
        *
        * Based on tween.js by sole. Converted to TypeScript and integrated into Kiwi.
        * https://github.com/sole/tween.js
        *
        * @class Tween
        * @constructor
        * @namespace Kiwi.Animations
        * @param object {Any} The object that this tween is taking affect on.
        * @param game {Kiwi.Game} The game that this tween is for.
        * @return {Kiwi.Animations.Tween} This tween.
        *
        * @author     sole / http://soledadpenades.com
        * @author     mrdoob / http://mrdoob.com
        * @author     Robert Eisele / http://www.xarg.org
        * @author     Philippe / http://philippe.elsass.me
        * @author     Robert Penner / http://www.robertpenner.com/easing_terms_of_use.html
        * @author     Paul Lewis / http://www.aerotwist.com/
        * @author     lechecacharro
        * @author     Josh Faul / http://jocafa.com/
        * @author     egraether / http://egraether.com/
        *
        */
        var Tween = (function () {
            function Tween(object, game) {
                if (game === void 0) { game = null; }
                /**
                * The game that this tween belongs to.
                * @property _game
                * @type Kiwi.Game
                * @private
                */
                this._game = null;
                /**
                * The manager that this tween belongs to.
                * @property _manager
                * @type Kiwi.Animations.Tweens.TweenManager
                * @private
                */
                this._manager = null;
                /**
                * The object that this tween is affecting.
                * @property _object
                * @type Any
                * @private
                */
                this._object = null;
                /**
                * The starting values of the properties that the tween is animating.
                * @property _valuesStart
                * @type Object
                * @private
                */
                this._valuesStart = {};
                /**
                * The end values of the properties that the tween is animating.
                * @property _valuesEnd
                * @type Object
                * @private
                */
                this._valuesEnd = {};
                /**
                * The duration of the tween, in milliseconds.
                * @property _duration
                * @type Number
                * @private
                */
                this._duration = 1000;
                /**
                * The amount of time to delay the tween by. In Milliseconds.
                * @property _delayTime
                * @type Number
                * @private
                */
                this._delayTime = 0;
                /**
                * The time at which the tween started.
                * @property _startTime
                * @type Number
                * @private
                */
                this._startTime = null;
                /**
                * The easing function that is to be used while tweening.
                * @property _easingFunction
                * @type Function
                * @default Kiwi.Tweens.Easing.Linear.None
                * @private
                */
                this._easingFunction = Kiwi.Animations.Tweens.Easing.Linear.None;
                /**
                * [NEEDS DESCRIPTION]
                * @property _interpolationFunction
                * @type Function
                * @default Kiwi.Utils.Interpolation.Linear
                * @private
                */
                this._interpolationFunction = Kiwi.Utils.GameMath.linearInterpolation;
                /**
                * An array containing all of the tweens that are to be played when this one finishes.
                * @property _chainedTweens
                * @type Tween[]
                * @private
                */
                this._chainedTweens = [];
                /**
                * The method that is to be called when the tween starts playing.
                * @property _onStartCallback
                * @type Function
                * @default null
                * @private
                */
                this._onStartCallback = null;
                /**
                * The context that the _onStartCallback method is to be called in.
                * @property _onStartContext
                * @type Any
                * @default null
                * @private
                */
                this._onStartContext = null;
                /**
                * A boolean indicating if the starting callback has been called or not.
                * @property _onStartCallbackFired
                * @type boolean
                * @default false
                * @private
                */
                this._onStartCallbackFired = false;
                /**
                * A callback method that will be called each time the tween updates.
                * @property _onUpdateCallback
                * @type Function
                * @default null
                * @private
                */
                this._onUpdateCallback = null;
                /**
                * The context that the update callback has when called.
                * @property _onUpdateContext
                * @type any
                * @default null
                * @private
                */
                this._onUpdateContext = null;
                /**
                * A method to be called when the tween finish's tweening.
                * @property _onCompleteCallback
                * @type function
                * @default null
                * @private
                */
                this._onCompleteCallback = null;
                /*
                * A boolean indicating whether or not the _onCompleteCallback has been called.
                * Is reset each time you tell the tween to start.
                * @property _onCompleteCalled
                * @type boolean
                * @default false
                * @private
                */
                this._onCompleteCalled = false;
                /**
                * The context that the onCompleteCallback should have when called.
                * @property _onCompleteContext
                * @type any
                * @default null
                * @private
                */
                this._onCompleteContext = null;
                /**
                * An indication of whether or not this tween is currently running.
                * @property isRunning.
                * @type boolean
                * @default false
                * @public
                */
                this.isRunning = false;
                this._object = object;
                if (game !== null) {
                    this._game = game;
                    this._manager = this._game.tweens;
                }
                this.isRunning = false;
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String} "Tween"
            * @public
            */
            Tween.prototype.objType = function () {
                return "Tween";
            };
            Object.defineProperty(Tween.prototype, "manager", {
                /**
                * The manager that this tween belongs to.
                * @property manager
                * @type Kiwi.Animations.Tweens.TweenManager
                * @private
                * @since 1.2.0
                */
                get: function () {
                    return this._manager;
                },
                set: function (value) {
                    this._manager = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Tween.prototype, "object", {
                /**
                * The object that this tween is affecting.
                * If you change this, it will continue to tween,
                * but any properties that are not on the new object
                * will be discarded from the tween.
                * @property object
                * @type any
                * @public
                */
                get: function () {
                    return this._object;
                },
                set: function (value) {
                    var i, newValues = {};
                    this._object = value;
                    for (i in this._valuesEnd) {
                        if (value[i]) {
                            newValues[i] = this._valuesEnd[i];
                        }
                    }
                    this._valuesEnd = newValues;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Sets up the various properties that define this tween.
            * The ending position/properties for this tween, how long the tween should go for, easing method to use and if should start right way.
            *
            * @method to
            * @param properties {Object} The ending location of the properties that you want to tween.
            * @param [duration=1000] {Number} The duration of the tween.
            * @param [ease=null] {Any} The easing method to be used. If not specifed then this will default to LINEAR.
            * @param [autoStart=false] {boolean} If the tween should start right away.
            * @return {Kiwi.Animations.Tween}
            * @public
            */
            Tween.prototype.to = function (properties, duration, ease, autoStart) {
                if (duration === void 0) { duration = 1000; }
                if (ease === void 0) { ease = null; }
                if (autoStart === void 0) { autoStart = false; }
                this._duration = duration;
                //  If properties isn't an object this will fail, sanity check it here somehow?
                this._valuesEnd = properties;
                if (ease !== null) {
                    this._easingFunction = ease;
                }
                if (autoStart === true) {
                    return this.start();
                }
                else {
                    return this;
                }
            };
            /**
            * Gets the initial values for the properties that it is to animate and starts the tween process.
            * @method start
            * @public
            */
            Tween.prototype.start = function () {
                var property;
                if (this._game === null || this._object === null) {
                    return;
                }
                this.isRunning = true;
                this._manager.add(this);
                this._onStartCallbackFired = false;
                this._onCompleteCalled = false;
                this._startTime = this._manager.clock.elapsed() * 1000 + this._delayTime;
                for (var property in this._valuesEnd) {
                    // This prevents the interpolation of null values or of non-existing properties
                    if (this._object[property] === null || !(property in this._object)) {
                        continue;
                    }
                    // check if an Array was provided as property value
                    if (this._valuesEnd[property] instanceof Array) {
                        if (this._valuesEnd[property].length === 0) {
                            continue;
                        }
                        // create a local copy of the Array with the start value at the front
                        this._valuesEnd[property] = [this._object[property]].concat(this._valuesEnd[property]);
                    }
                    //  Check if property is a function
                    if (typeof this._object[property] === "function") {
                        this._valuesStart[property] = this._object[property]();
                    }
                    else {
                        this._valuesStart[property] = this._object[property];
                    }
                }
                return this;
            };
            /**
            * Stops the Tween from running and removes it from the manager.
            * @method stop
            * @public
            */
            Tween.prototype.stop = function () {
                if (this._manager !== null) {
                    this._manager.remove(this);
                }
                this.isRunning = false;
                return this;
            };
            /**
            * Sets the game and the manager of this tween.
            * @method setParent
            * @param {Kiwi.Game} value
            * @public
            */
            Tween.prototype.setParent = function (value) {
                this._game = value;
                this._manager = this._game.tweens;
            };
            /**
            * Sets the amount of delay that the tween is to have before it starts playing.
            * @method delay
            * @param amount {Number} The amount of time to delay the tween by.
            * @return {Kiwi.Animations.Tween}
            * @public
            */
            Tween.prototype.delay = function (amount) {
                this._delayTime = amount;
                return this;
            };
            /**
            * Sets the easing method that is to be used when animating this tween.
            * @method easing
            * @param easing {Function} The easing function to use.
            * @return {Kiwi.Animations.Tween}
            * @public
            */
            Tween.prototype.easing = function (easing) {
                this._easingFunction = easing;
                return this;
            };
            /**
            * [REQUIRES DESCRIPTION]
            * @method interpolation
            * @param {Any} interpolation
            * @return {Kiwi.Animations.Tween}
            * @public
            */
            Tween.prototype.interpolation = function (interpolation) {
                this._interpolationFunction = interpolation;
                return this;
            };
            /**
            * Adds another tween that should start playing once tween has completed.
            * @method chain
            * @param tween {Kiwi.Animations.Tween}
            * @return {Kiwi.Animations.Tween}
            * @public
            */
            Tween.prototype.chain = function (tween) {
                this._chainedTweens.push(tween);
                return this;
            };
            /**
            * Adds a function that is to be executed when the tween start playing.
            * @method onStart
            * @param callback {Function} The function that is to be executed on tween start.
            * @param context {any} The context that function is to have when called.
            * @return {Kiwi.Animations.Tween}
            * @public
            */
            Tween.prototype.onStart = function (callback, context) {
                this._onStartCallback = callback;
                this._onStartContext = context;
                return this;
            };
            /**
            * Adds a function that is to be executed when this tween updates while it is playing.
            * @method onUpdate
            * @param callback {Function} The method that is to be executed.
            * @param context {Any} The context the method is to have when called.
            * @public
            */
            Tween.prototype.onUpdate = function (callback, context) {
                this._onUpdateCallback = callback;
                this._onUpdateContext = context;
                return this;
            };
            /**
            * Defines a method that is to be called when this tween is finished.
            * @method onComplete
            * @param callback {Function} The method that is to be executed.
            * @param context {Any} The context the method is to have when called.
            * @public
            */
            Tween.prototype.onComplete = function (callback, context) {
                this._onCompleteCallback = callback;
                this._onCompleteContext = context;
                return this;
            };
            /**
            * The update loop is executed every frame whilst the tween is running.
            * @method update
            * @param time {Number}
            * @return {boolean} Whether the Tween is still running
            * @public
            */
            Tween.prototype.update = function (time) {
                if (time < this._startTime - this._delayTime) {
                    return false;
                }
                if (this._onStartCallbackFired === false) {
                    if (this._onStartCallback !== null) {
                        this._onStartCallback.call(this._onStartContext, this._object);
                    }
                    this._onStartCallbackFired = true;
                }
                var elapsed = (time - this._startTime) / this._duration;
                elapsed = elapsed > 1 ? 1 :
                    elapsed < 0 ? 0 :
                        elapsed;
                var value = this._easingFunction(elapsed);
                for (var property in this._valuesStart) {
                    var start = this._valuesStart[property];
                    var end = this._valuesEnd[property];
                    //  Add checks for object, array, numeric up front
                    if (end instanceof Array) {
                        this._object[property] =
                            this._interpolationFunction(end, value);
                    }
                    else {
                        if (typeof this._object[property] === "function") {
                            this._object[property](start + (end - start) * value);
                        }
                        else {
                            this._object[property] = start + (end - start) * value;
                        }
                    }
                }
                if (this._onUpdateCallback !== null) {
                    this._onUpdateCallback.call(this._onUpdateContext, this._object, value);
                }
                if (elapsed === 1) {
                    this.isRunning = false;
                    if (this._onCompleteCallback !== null &&
                        this._onCompleteCalled === false) {
                        this._onCompleteCalled = true;
                        this._onCompleteCallback.call(this._onCompleteContext, this._object);
                    }
                    for (var i = 0; i < this._chainedTweens.length; i++) {
                        this._chainedTweens[i].start();
                    }
                    return false;
                }
                return true;
            };
            return Tween;
        })();
        Animations.Tween = Tween;
    })(Animations = Kiwi.Animations || (Kiwi.Animations = {}));
})(Kiwi || (Kiwi = {}));
/**
* Contains the classes which are related to the rendering of GameObjects.
*
* @module Kiwi
* @submodule Renderers
* @main
*/
var Kiwi;
(function (Kiwi) {
    var Renderers;
    (function (Renderers) {
        /**
        *
        * @class CanvasRenderer
        * @constructor
        * @namespace Kiwi.Renderers
        * @param game {Kiwi.Game} The game that this canvas renderer belongs to.
        * @return {Kiwi.Renderes.CanvasRenderer}
        *
        */
        var CanvasRenderer = (function () {
            function CanvasRenderer(game) {
                this.numDrawCalls = 0;
                this._game = game;
            }
            /**
            * The boot method is executed when all of the DOM elements that are needed to play the game are ready.
            * @method boot
            * @public
            */
            CanvasRenderer.prototype.boot = function () {
            };
            /**
            * Returns the type of object that this is.
            * @method objType
            * @return {String} "CanvasRenderer"
            * @public
            */
            CanvasRenderer.prototype.objType = function () {
                return "CanvasRenderer";
            };
            /**
            * This method recursively goes through a State's members and runs the render method of each member that is a Entity.
            * If it is a Group then this method recursively goes through that Groups members the process that happened to the State's members happens to the Group's members.
            *
            * @method _recurse
            * @param child {object} The child that is being checked.
            * @private
            */
            CanvasRenderer.prototype._recurse = function (child) {
                // Do not render non-visible objects or their children
                if (!child.visible)
                    return;
                if (child.childType() === Kiwi.GROUP) {
                    for (var i = 0; i < child.members.length; i++) {
                        this._recurse(child.members[i]);
                    }
                }
                else {
                    this.numDrawCalls++;
                    child.render(this._currentCamera);
                }
            };
            //for gl compatibility - refactor me
            CanvasRenderer.prototype.requestRendererInstance = function (rendererID, params) {
                if (params === void 0) { params = null; }
                return null;
            };
            CanvasRenderer.prototype.requestSharedRenderer = function (rendererID, params) {
                if (params === void 0) { params = null; }
                return null;
            };
            CanvasRenderer.prototype.initState = function (state) {
            };
            CanvasRenderer.prototype.endState = function (state) {
            };
            /**
            * Renders all of the Elements that are on a particular camera.
            * @method render
            * @param camera {Kiwi.Camera}
            * @public
            */
            CanvasRenderer.prototype.render = function (camera) {
                var root = this._game.states.current.members;
                //clear 
                var fillCol = this._game.stage.rgbaColor;
                // If there is an alpha, clear the canvas before fill
                if (fillCol.a < 255) {
                    this._game.stage.ctx.clearRect(0, 0, this._game.stage.canvas.width, this._game.stage.canvas.height);
                }
                this._game.stage.ctx.fillStyle = "rgba(" + fillCol.r + "," + fillCol.g + "," + fillCol.b + "," + fillCol.a / 255 + ")";
                this._game.stage.ctx.fillRect(0, 0, this._game.stage.canvas.width, this._game.stage.canvas.height);
                // Stop drawing if there is nothing to draw
                if (root.length == 0) {
                    return;
                }
                this.numDrawCalls = 0;
                this._currentCamera = camera;
                //apply camera transform, accounting for rotPoint offsets
                var cm = camera.transform.getConcatenatedMatrix();
                var ct = camera.transform;
                this._game.stage.ctx.save();
                this._game.stage.ctx.setTransform(cm.a, cm.b, cm.c, cm.d, cm.tx, cm.ty);
                this._game.stage.ctx.transform(1, 0, 0, 1, -ct.rotPointX, -ct.rotPointY);
                for (var i = 0; i < root.length; i++) {
                    this._recurse(root[i]);
                }
                this._game.stage.ctx.restore();
            };
            return CanvasRenderer;
        })();
        Renderers.CanvasRenderer = CanvasRenderer;
    })(Renderers = Kiwi.Renderers || (Kiwi.Renderers = {}));
})(Kiwi || (Kiwi = {}));
/**
* @module Kiwi
* @submodule Renderers
* @main Renderers
* @namespace Kiwi.Renderers
*/
var Kiwi;
(function (Kiwi) {
    var Renderers;
    (function (Renderers) {
        /**
        * Manages all rendering using WebGL.
        * Directly manages renderer objects, including factory methods
        * for their creation.
        * Creates manager objects for shaders and textures.
        * Manages gl state at game initialisation, at state start and end,
        * and per frame.
        * Runs the recursive scene graph rendering sequence every frame.
        * @class GLRenderManager
        * @extends IRenderer
        * @constructor
        * @param game {Kiwi.Game} The game that this renderer belongs to.
        * @return {Kiwi.Renderers.GLRenderManager}
        */
        var GLRenderManager = (function () {
            function GLRenderManager(game) {
                /**
                * The renderer object that is in use during a rendering batch.
                * @property _currentRenderer
                * @type Kiwi.Renderers.Renderer
                * @private
                */
                this._currentRenderer = null;
                /**
                * Tally of number of entities rendered per frame
                * @property _entityCount
                * @type number
                * @default 0
                * @private
                */
                this._entityCount = 0;
                /**
                * Tally of number of draw calls per frame
                * @property numDrawCalls
                * @type number
                * @default 0
                * @public
                */
                this.numDrawCalls = 0;
                /**
                * Maximum allowable sprites to render per frame.
                * Note: Not currently used  - candidate for deletion
                * @property _maxItems
                * @type number
                * @default 1000
                * @private
                */
                this._maxItems = 1000;
                /**
                * The most recently bound texture atlas.
                * @property _currentTextureAtlas
                * @type TextureAtlas
                * @private
                */
                this._currentTextureAtlas = null;
                /**
                * An array of renderers.
                *
                * Shared renderers are used for batch rendering.
                * Multiple gameobjects can use the same renderer instance and add
                * rendering info to a batch rather than rendering individually.
                * This means only one draw call is necessary to render a number of
                * objects. The most common use of this is standard 2d sprite rendering,
                * and the TextureAtlasRenderer is added by default as a shared
                * renderer. Sprites, StaticImages and Tilemaps (core gameobjects)
                * can all use the same renderer/shader combination and be drawn as
                * part of the same batch.
                *
                * Custom gameobjects can also choose to use a shared renderer, fo example in the case that a custom gameobject's rendering requirements matched the TextureAtlasRenderer
                * capabilities.
                *
                * @property _sharedRenderers
                * @type Array
                * @private
                */
                this._sharedRenderers = {};
                this._game = game;
                this._currentBlendMode = new Kiwi.Renderers.GLBlendMode(this._game.stage.gl, { mode: "DEFAULT" });
            }
            /**
            * Initialises all WebGL rendering services
            * @method boot
            * @public
            */
            GLRenderManager.prototype.boot = function () {
                this._textureManager = new Renderers.GLTextureManager();
                this._shaderManager = new Kiwi.Shaders.ShaderManager();
                //this.filters = new Kiwi.Filters.GLFilterManager(this._game, this._shaderManager);
                this._init();
            };
            /**
            * The type of object that this is.
            * @method objType
            * @return {string} "GLRenderManager"
            * @public
            */
            GLRenderManager.prototype.objType = function () {
                return "GLRenderManager";
            };
            /**
            * Adds a texture to the Texture Manager.
            * @method addTexture
            * @param {WebGLRenderingContext} gl
            * @param {Kiwi.Textures.TextureAtlas} atlas
            * @public
            */
            GLRenderManager.prototype.addTexture = function (gl, atlas) {
                this._textureManager.uploadTexture(gl, atlas);
            };
            /**
            * Adds a renderer to the sharedRenderer array.
            *
            * The rendererID is a string that must match a renderer property
            * of the Kiwi.Renderers object. If a match is found and an instance
            * does not already exist, then a renderer is instantiated and added
            * to the array.
            * @method addSharedRenderer
            * @param {string} rendererID
            * @param {object} params
            * @return {boolean} success
            * @public
            */
            GLRenderManager.prototype.addSharedRenderer = function (rendererID, params) {
                if (params === void 0) { params = null; }
                //does renderer exist?
                if (Kiwi.Renderers[rendererID]) {
                    //already added?
                    if (!(rendererID in this._sharedRenderers)) {
                        this._sharedRenderers[rendererID] = new Kiwi.Renderers[rendererID](this._game.stage.gl, this._shaderManager, params);
                        return true;
                    }
                }
                return false;
            };
            /**
            * Adds a cloned renderer to the sharedRenderer array.
            * The rendererID is a string that must match a renderer property of
            * the Kiwi.Renderers object. The cloneID is the name for the
            * cloned renderer.
            *
            * If a match is found and an instance does not already exist,
            * then a renderer is instantiated and added to the array.
            *
            * Cloned shared renderers are useful if some items in your scene
            * will use a special shader or blend mode, but others will not.
            * You can subsequently access the clones with a normal
            * `requestSharedRenderer()` call. You should use this instead of
            * `requestRendererInstance()` whenever possible, because shared
            * renderers are more efficient than instances.
            *
            * @method addSharedRendererClone
            * @param {string} rendererID
            * @param {string} cloneID
            * @param {object} params
            * @return {boolean} success
            * @public
            * @since 1.1.0
            */
            GLRenderManager.prototype.addSharedRendererClone = function (rendererID, cloneID, params) {
                if (params === void 0) { params = null; }
                if (typeof params === "undefined") {
                    params = null;
                }
                //does renderer exist?
                if (Kiwi.Renderers[rendererID]) {
                    //already added?
                    if (!(cloneID in this._sharedRenderers)) {
                        this._sharedRenderers[cloneID] = new Kiwi.Renderers[rendererID](this._game.stage.gl, this._shaderManager, params);
                        return true;
                    }
                }
                return false;
            };
            /**
            * Requests a shared renderer. A game object that wants to use a shared
            * renderer uses this method to obtain a reference to the shared
            * renderer instance.
            * @method requestSharedRenderer
            * @param {string} rendererID
            * @param {object} params
            * @return {Kiwi.Renderers.Renderer} A shared renderer
            *	or null if none found.
            * @public
            */
            GLRenderManager.prototype.requestSharedRenderer = function (rendererID, params) {
                if (params === void 0) { params = null; }
                var renderer = this._sharedRenderers[rendererID];
                if (renderer) {
                    return renderer;
                }
                else {
                    if (this.addSharedRenderer(rendererID, params)) {
                        return this._sharedRenderers[rendererID];
                    }
                    else {
                        Kiwi.Log.log("No renderer called " + rendererID, '#renderer', '#webgl');
                    }
                }
                //failed request
                return null;
            };
            /**
            * Requests a new renderer instance. This factory method is the only
            * way gameobjects should instantiate their own renderer.
            *
            * The rendererID is a string that must match a renderer property
            * of the Kiwi.Renderers object. If a match is found then a renderer
            * is instantiated and returned. Gameobjects which have rendering
            * requirements that do not suit batch rendering use this technique.
            * @method requestRendererInstance
            * @param {string} rendererID The name of the requested renderer
            * @param {object} params
            * @return {Kiwi.Renderers.Renderer} A renderer or null if none found.
            * @public
            */
            GLRenderManager.prototype.requestRendererInstance = function (rendererID, params) {
                if (params === void 0) { params = null; }
                if (rendererID in Kiwi.Renderers) {
                    var renderer = new Kiwi.Renderers[rendererID](this._game.stage.gl, this._shaderManager, params);
                    return renderer;
                }
                else {
                    Kiwi.Log.log("No renderer with id " + rendererID + " exists", '#renderer', '#webgl');
                }
                return null; //fail
            };
            /*
            public get filtersEnabled(): boolean {
                return this._filtersEnabled;
            }
    
            public set filtersEnabled(val: boolean) {
                this._filtersEnabled = val;
            }
    
            private _filtersEnabled: boolean = false;
            
            /**
            * Performs initialisation required for single game instance -
            * happens once, at bootup. Sets global GL state.
            * Initialises managers for shaders and textures.
            * Instantiates the default shared renderer (`TextureAtlasRenderer`)
            * @method _init
            * @private
            */
            GLRenderManager.prototype._init = function () {
                Kiwi.Log.log("Initialising WebGL", '#renderer', '#webgl');
                var gl = this._game.stage.gl;
                //init stage and viewport
                this._stageResolution = new Float32Array([this._game.stage.width, this._game.stage.height]);
                // Manually override scaling under CocoonJS
                if (this._game.deviceTargetOption === Kiwi.TARGET_COCOON) {
                    this.scaleViewport(gl, this._game.stage.scaleType, window.innerWidth, window.innerHeight);
                }
                else {
                    this.scaleViewport(gl, Kiwi.Stage.SCALE_NONE, this._game.stage.width, this._game.stage.height);
                }
                //set default gl state
                gl.enable(gl.BLEND);
                this._switchBlendMode(gl, this._currentBlendMode);
                //shader manager
                this._shaderManager.init(gl, "TextureAtlasShader");
                //camera matrix
                this.camMatrix = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
                this._camMatrixOffset = new Kiwi.Geom.Matrix();
                //stage res needs update on stage resize
                this._game.stage.onResize.add(function (width, height) {
                    this._stageResolution = new Float32Array([width, height]);
                    if (this.currentRenderer)
                        this._currentRenderer.updateStageResolution(gl, this._stageResolution);
                    //this.filters.updateFilterResolution(gl,width, height);
                    // Manually override scaling under CocoonJS
                    if (this._game.deviceTargetOption === Kiwi.TARGET_COCOON) {
                        this.scaleViewport(gl, this._game.stage.scaleType, window.innerWidth, window.innerHeight);
                    }
                    else {
                        this.scaleViewport(gl, Kiwi.Stage.SCALE_NONE, width, height);
                    }
                }, this);
                /* if (this.filtersEnabled && !this.filters.isEmpty) {
                    this.filters.enableFrameBuffers(gl);
                }*/
            };
            /**
            * Scales the viewport according to a scale mode and space dimensions.
            *
            * This is used internally for compatibility with CocoonJS and should not be called.
            * @method scaleViewport
            * @param gl {WebGLRenderingContext}
            * @param mode {number} Scale mode; should be either
            *	Kiwi.Stage.SCALE_FIT, Kiwi.Stage.SCALE_STRETCH, or
            *	Kiwi.Stage.SCALE_NONE. Defaults to Kiwi.Stage.SCALE_NONE
            * @param width {number} Width of the target space
            * @param height {number} Height of the target space
            * @public
            * @since 1.1.1
            */
            GLRenderManager.prototype.scaleViewport = function (gl, mode, width, height) {
                var offset = new Kiwi.Geom.Point(0, 0);
                switch (mode) {
                    case Kiwi.Stage.SCALE_FIT:
                        // Compute aspect ratios
                        var arStage = this._game.stage.width / this._game.stage.height;
                        var arSpace = width / height;
                        if (arStage < arSpace) {
                            // Width is too wide
                            var newWidth = height * arStage;
                            offset.x = (width - newWidth) / 2;
                            // Compress target space
                            width = newWidth;
                        }
                        else {
                            // Height is too wide
                            var newHeight = width / arStage;
                            offset.y = (height - newHeight) / 2;
                            // Compress target space
                            height = newHeight;
                        }
                        break;
                    case Kiwi.Stage.SCALE_STRETCH:
                        break;
                    case Kiwi.Stage.SCALE_NONE:
                        width = this._game.stage.width;
                        height = this._game.stage.height;
                        break;
                    default:
                        break;
                }
                gl.viewport(offset.x, offset.y, width, height);
            };
            /**
            * Performs initialisation required when switching to a different state.
            * Called when a state has been switched to.
            * The textureManager is told to clear its contents from video memory,
            * then rebuild its cache of textures from the state's texture library.
            * @method initState
            * @public
            */
            GLRenderManager.prototype.initState = function (state) {
                this._textureManager.clearTextures(this._game.stage.gl);
                this._textureManager.uploadTextureLibrary(this._game.stage.gl, state.textureLibrary);
            };
            /**
            * Performs cleanup required before switching to a different state.
            * Called whwn a state is about to be switched from.
            * The textureManager is told to empty its cache.
            * @method endState
            * @param state {Kiwi.State}
            * @public
            */
            GLRenderManager.prototype.endState = function (state) {
                this._textureManager.clearTextures(this._game.stage.gl);
                Kiwi.Log.log("Ending WebGL on State", '#renderer', '#webgl');
            };
            /**
            * Manages rendering of the scene graph - called once per frame.
            * Sets up per frame gl uniforms such as the view matrix and
            * camera offset. Clears the current renderer ready for a new batch.
            * Initiates recursive render of scene graph starting at the root.
            * @method render
            * @param camera {Camera}
            * @public
            */
            GLRenderManager.prototype.render = function (camera) {
                var gl = this._game.stage.gl;
                //clear stage every frame
                var col = this._game.stage.normalizedColor;
                // Colour must be multiplied by alpha to create consistent results.
                // This is probably due to browsers implementing an inferior
                // blendfunc: ONE, ONE_MINUS_SRC_ALPHA is most common, and gives
                // bad results with alphas. When this is used on a partially
                // transparent game canvas, it does not blend correctly.
                // Without being able to override the browser's own object renderer,
                // this is a necessary kludge. The "clean" solution is as follows:
                // gl.clearColor(col.r, col.g, col.b, col.a);
                gl.clearColor(col.r * col.a, col.g * col.a, col.b * col.a, col.a);
                gl.clear(gl.COLOR_BUFFER_BIT);
                // Reset current renderer.
                // This prevents runtime created shaders from being uploaded
                // and the render manager failing to notice, causing crashes.
                this._currentRenderer = null;
                // Stop drawing if there is nothing to draw
                if (this._game.states.current.members.length == 0) {
                    return;
                }
                // Reset stats
                this.numDrawCalls = 0;
                this._textureManager.numTextureWrites = 0;
                this._entityCount = 0;
                // Set cam matrix uniform
                var cm = camera.transform.getConcatenatedMatrix();
                var ct = camera.transform;
                this._camMatrixOffset.identity();
                this._camMatrixOffset.translate(-ct.anchorPointX, -ct.anchorPointY);
                this._camMatrixOffset.prependMatrix(cm);
                // Overwrite cam matrix properties rather than recreating matrix.
                // This is necessary to keep the cam matrix synchronised
                // with other renderers: if there is only one render batch,
                // then `enable` will only pass the cam matrix on the first frame,
                // and subsequent camera movements will not be passed to the shader.
                this.camMatrix[0] = this._camMatrixOffset.a;
                this.camMatrix[1] = this._camMatrixOffset.b;
                this.camMatrix[3] = this._camMatrixOffset.c;
                this.camMatrix[4] = this._camMatrixOffset.d;
                this.camMatrix[6] = this._camMatrixOffset.tx;
                this.camMatrix[7] = this._camMatrixOffset.ty;
                // Mandate blend mode in CocoonJS
                // This must be called per-frame, because CocoonJS seems to
                // interfere with blend modes on a per-frame basis.
                if (this._game.deviceTargetOption == Kiwi.TARGET_COCOON) {
                    this._switchBlendMode(gl, this._currentBlendMode);
                }
                this.collateRenderSequence();
                this.collateBatches();
                this.renderBatches(gl, camera);
                /*if (this._filtersEnabled && !this.filters.isEmpty) {
                    this.filters.applyFilters(gl);
                    gl.useProgram(this._shaderManager.currentShader.shaderProgram);
                    gl.bindTexture(gl.TEXTURE_2D, this._currentTextureAtlas.glTextureWrapper.texture);
                }*/
            };
            /**
            * Creates a new render sequence
            * @method collateRenderSequence
            * @public
            */
            GLRenderManager.prototype.collateRenderSequence = function () {
                this._sequence = [];
                var root = this._game.states.current;
                this.collateChild(root);
            };
            /**
            * Adds a child to the render sequence
            * (may be a group with children of its own).
            * @method collateChild
            * @public
            */
            GLRenderManager.prototype.collateChild = function (child) {
                // Do not render non-visible objects or their children
                if (!child.visible)
                    return;
                if (child.childType() === Kiwi.GROUP) {
                    for (var i = 0; i < child.members.length; i++) {
                        this.collateChild(child.members[i]);
                    }
                }
                else {
                    var entity = child;
                    this._sequence.push({
                        entity: entity,
                        renderer: entity.glRenderer,
                        shader: entity.glRenderer.shaderPair,
                        isBatchRenderer: entity.glRenderer.isBatchRenderer,
                        texture: entity.atlas
                    });
                }
            };
            /**
            * Sorts the render sequence into batches.
            * Each batch requires the same renderer/shader/texture combination.
            * @method collateBatches
            * @public
            */
            GLRenderManager.prototype.collateBatches = function () {
                var currentRenderer = null;
                var currentShader = null;
                var currentTexture = null;
                this._batches = [];
                var batchIndex;
                for (var i = 0; i < this._sequence.length; i++) {
                    if (!this._sequence[i].isBatchRenderer ||
                        this._sequence[i].renderer !== currentRenderer ||
                        this._sequence[i].shader !== currentShader ||
                        this._sequence[i].texture !== currentTexture) {
                        //create a new batch
                        var batchIndex = this._batches.push(new Array()) - 1;
                        currentRenderer = this._sequence[i].renderer;
                        currentShader = this._sequence[i].shader;
                        currentTexture = this._sequence[i].texture;
                    }
                    this._batches[batchIndex].push(this._sequence[i]);
                }
            };
            /**
            * Renders all the batches
            * @method renderBatches
            * @param {WebGLRenderingContext} gl
            * @param {Kiwi.Camera} camera
            * @public
            */
            GLRenderManager.prototype.renderBatches = function (gl, camera) {
                for (var i = 0; i < this._batches.length; i++)
                    this.renderBatch(gl, this._batches[i], camera);
            };
            /**
            * Renders a single batch
            * @method renderBatch
            * @param {WebGLRenderingContext} gl
            * @param {object} batch
            * @param {Kiwi.Camera} camera
            * @public
            */
            GLRenderManager.prototype.renderBatch = function (gl, batch, camera) {
                // Acquire renderer
                var rendererSwitched = false;
                if (batch[0].entity.glRenderer !== this._currentRenderer) {
                    rendererSwitched = true;
                    this._switchRenderer(gl, batch[0].entity);
                }
                // Clear renderer for fresh data
                this._currentRenderer.clear(gl, { camMatrix: this.camMatrix });
                // Call render functions
                for (var i = 0; i < batch.length; i++)
                    batch[i].entity.renderGL(gl, camera);
                // Upload textures
                if (batch[0].entity.atlas !== this._currentTextureAtlas || batch[0].entity.atlas.dirty || (rendererSwitched && batch[0].entity.atlas == this._currentTextureAtlas))
                    this._switchTexture(gl, batch[0].entity);
                // Manage blend mode
                // We must always apply BlendMode under CocoonJS, because some (but not all) operations on other canvases may silently change the blend mode and not change it back.
                if (!this._currentBlendMode.isIdentical(batch[0].entity.glRenderer.blendMode) || this._currentBlendMode.dirty || this._game.deviceTargetOption === Kiwi.TARGET_COCOON)
                    this._switchBlendMode(gl, batch[0].entity.glRenderer.blendMode);
                // Render
                this._currentRenderer.draw(gl);
            };
            /**
            * Calls the render function on a single entity
            * @method renderEntity
            * @param {WebGLRenderingContext} gl
            * @param {Kiwi.Entity} entity
            * @param {Kiwi.Camera} camera
            * @public
            * @deprecated Used internally; should not be called from external functions
            */
            GLRenderManager.prototype.renderEntity = function (gl, entity, camera) {
                this.renderBatch(gl, [entity], camera);
            };
            /**
            * Ensures the atlas and renderer needed for a batch is setup
            * @method setupGLState
            * @param {WebGLRenderingContext} gl
            * @public
            * @deprecated Used internally; should not be called from external functions.
            */
            GLRenderManager.prototype.setupGLState = function (gl, entity) {
                if (entity.atlas !== this._currentTextureAtlas)
                    this._switchTexture(gl, entity);
                if (entity.glRenderer !== this._currentRenderer)
                    this._switchRenderer(gl, entity);
            };
            /**
            * Switch renderer to the one needed by the entity that needs rendering
            * @method _switchRenderer
            * @param gl {WebGLRenderingContext}
            * @param entity {Kiwi.Entity}
            * @private
            */
            GLRenderManager.prototype._switchRenderer = function (gl, entity) {
                if (this._currentRenderer)
                    this._currentRenderer.disable(gl);
                this._currentRenderer = entity.glRenderer;
                this._currentRenderer.enable(gl, { camMatrix: this.camMatrix, stageResolution: this._stageResolution });
            };
            /**
            * Switch texture to the one needed by the entity that needs rendering
            * @method _switchTexture
            * @param gl {WebGLRenderingContext}
            * @param entity {Kiwi.Entity}
            * @private
            */
            GLRenderManager.prototype._switchTexture = function (gl, entity) {
                this._currentTextureAtlas = entity.atlas;
                entity.atlas.enableGL(gl, this._currentRenderer, this._textureManager);
            };
            /**
            * Switch blend mode to a new set of constants
            * @method _switchBlendMode
            * @param gl {WebGLRenderingContext}
            * @param blendMode {Kiwi.Renderers.GLBlendMode}
            * @private
            * @since 1.1.0
            */
            GLRenderManager.prototype._switchBlendMode = function (gl, blendMode) {
                this._currentBlendMode = blendMode;
                this._currentBlendMode.apply(gl);
            };
            return GLRenderManager;
        })();
        Renderers.GLRenderManager = GLRenderManager;
    })(Renderers = Kiwi.Renderers || (Kiwi.Renderers = {}));
})(Kiwi || (Kiwi = {}));
/**
* GLSL ES Shaders are used for WebGL rendering.
* ShaderPair objects encapsulate GLSL ES vertex and fragment shader programs.
*   ShaderPairs contain the GLSL code, provide an interface to uniforms and attributes, and have the ability to link and compile the shaders.
* The ShaderManager keeps track of each ShaderPair, and controls which one is bound for use at any particular time.
*   Only the ShaderManager can create ShaderPairs. When a renderer (see note on renderes below) requests a ShaderPair the ShaderManager will either
*       1) Return a reference to an already instantiated ShaderPair, and set the GL state to use the shader program or
*       2) Return a reference to a new ShaderPair, which will be linked and compiled and bound for use.
*   All ShaderPairs must be housed as properties of the Kiwi.Shaders object.
*
* Kiwi.Renderer objects use a ShaderPair to draw.
*   They must request a ShaderPair from the ShaderManager.
*   Many renderers may use the same ShaderPair.
*   Some renderers may at different times use multiple ShaderPairs (only one is possible at any given time)
*
* @module Kiwi
* @submodule Shaders
* @main Shaders
* @namespace Kiwi.Shaders
*/
var Kiwi;
(function (Kiwi) {
    var Shaders;
    (function (Shaders) {
        /**
        * Manages all WebGL Shaders. Maintains a list of ShaderPairs
        *
        * Provides an interface for using a specific ShaderPair, adding new ShaderPairs, and requesting a reference to a ShaderPair instance.
        * Renderes use shaderPairs to draw. Multiple renderers may use the same compiled shader program.
        * This Manager ensures only one compiled instance of each program is created
        * @class ShaderManager
        * @extends IRenderer
        * @constructor
        * @return {Kiwi.Shaders.ShaderManager}
        */
        var ShaderManager = (function () {
            function ShaderManager() {
                /**
                * An object containing a set of properties each of which references a ShaderPair.
                * @property _shaderPairs
                * @type Object
                * @private
                */
                this._shaderPairs = {};
            }
            Object.defineProperty(ShaderManager.prototype, "currentShader", {
                /**
                * The shader program that is currently set to be used useing gl.useProgram.
                * @property currentShader
                * @type Array
                * @private
                */
                get: function () {
                    return this._currentShader;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Sets up a default shaderPair.
            * @method init
            * @param {WebGLRenderingContext} gl
            * @param {String} defaultShaderID
            * @public
            */
            ShaderManager.prototype.init = function (gl, defaultShaderID) {
                this._currentShader = this.requestShader(gl, defaultShaderID);
            };
            /**
            * Provides a reference to a ShaderPair. If the requested ShaderPair exists as a property on the _shaderPairs object it will be returned if already loaded,
            * otherwise it will be loaded, then returned.
            *
            * If the request is not on the list, the Kiwi.Shaders object will  be checked for a property name that matches shaderID and a new ShaderPair
            * will be instantiated, loaded, and set for use.
    
            * @method requestShader
            * @param {WebGLRenderingContext} gl
            * @param {String} shaderID
            * @param {boolean} use
            * @return {Kiwi.Shaders.ShaderPair} a ShaderPair instance - null on fail
            * @public
            */
            ShaderManager.prototype.requestShader = function (gl, shaderID, use) {
                if (use === void 0) { use = true; }
                var shader;
                //in list already?
                if (shaderID in this._shaderPairs) {
                    shader = this._shaderPairs[shaderID];
                    if (!shader.loaded) {
                        this._loadShader(gl, shader);
                    }
                    if (use)
                        this._useShader(gl, shader);
                    return shader;
                }
                else {
                    //not in list, does it exist?
                    if (this.shaderExists(gl, shaderID)) {
                        shader = this._addShader(gl, shaderID);
                        this._loadShader(gl, shader);
                        if (use)
                            this._useShader(gl, shader);
                        return shader;
                    }
                    else {
                        Kiwi.Log.log("Shader " + shaderID + " does not exist.", '#renderer', '#webgl');
                    }
                }
                //unsuccessful request
                return null;
            };
            /**
            * Tests to see if a ShaderPair property named ShaderID exists on Kiwi.Shaders. Can be used to test for the availability of specific shaders (for fallback)
            * @method shaderExists
            * @param {WebGLRenderingContext} gl
            * @param {String} shaderID
            * @return {Boolean} success
            * @public
            */
            ShaderManager.prototype.shaderExists = function (gl, shaderID) {
                return shaderID in Kiwi.Shaders;
            };
            /**
            * Creates a new instance of a ShaderPair and adds a reference to the _shaderPairs object
            * @method _addShader
            * @param {WebGLRenderingContext} gl
            * @param {String} shaderID
            * @return {Kiwi.Shaders.ShaderPair}
            * @private
            */
            ShaderManager.prototype._addShader = function (gl, shaderID) {
                this._shaderPairs[shaderID] = new Kiwi.Shaders[shaderID]();
                return this._shaderPairs[shaderID];
            };
            /**
            * Tells a ShaderPair to load (compile and link)
            * @method _loadShader
            * @param {WebGLRenderingContext} gl
            * @param {Kiwi.Shaders.ShaderPair} shader
            * @private
            */
            ShaderManager.prototype._loadShader = function (gl, shader) {
                shader.init(gl);
            };
            /**
            * Changes gl state so that the shaderProgram contined in a ShaderPir is bound for use
            * @method _useShader
            * @param {WebGLRenderingContext} gl
            * @param {Kiwi.Shaders.ShaderPair} shader
            * @private
            */
            ShaderManager.prototype._useShader = function (gl, shader) {
                if (shader !== this._currentShader) {
                    this._currentShader = shader;
                }
                gl.useProgram(shader.shaderProgram);
            };
            return ShaderManager;
        })();
        Shaders.ShaderManager = ShaderManager;
    })(Shaders = Kiwi.Shaders || (Kiwi.Shaders = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Renderers
*
* @namespace Kiwi.Renderers
*/
var Kiwi;
(function (Kiwi) {
    var Renderers;
    (function (Renderers) {
        /**
        * Wraps a webGL texture object
        * @class GLTextureWrapper
        * @constructor
        * @param gl {WebGLRenderingContext}
        * @param atlas {Kiwi.Textures.TextureAtlas} The wrapper will default to wrapping atlas.image.
        * @return {Kiwi.Renderers.GLTextureWrapper}
        */
        var GLTextureWrapper = (function () {
            function GLTextureWrapper(gl, atlas, upload) {
                if (upload === void 0) { upload = false; }
                /**
                * Returns whether the texture has been created
                * @property created
                * @type boolean
                */
                this._created = false;
                /**
                * Returns whether the texture has been uploaded to video memory
                * @property uploaded
                * @type boolean
                */
                this._uploaded = false;
                this.textureAtlas = atlas;
                this._image = atlas.image;
                this._numBytes = this._image.width * this._image.height * 4;
                this.createTexture(gl);
                if (upload)
                    this.uploadTexture(gl);
            }
            Object.defineProperty(GLTextureWrapper.prototype, "numBytes", {
                get: function () {
                    return this._numBytes;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(GLTextureWrapper.prototype, "created", {
                get: function () {
                    return this._created;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(GLTextureWrapper.prototype, "uploaded", {
                get: function () {
                    return this._uploaded;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(GLTextureWrapper.prototype, "image", {
                /**
                * The image wrapped by this wrapper.
                * @property image
                * @type HTMLImageElement
                * @public
                */
                get: function () {
                    return (this._image);
                },
                set: function (image) {
                    this._image = image;
                    this._numBytes = this._image.width * this._image.height * 4;
                    this._uploaded = false;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Creates a webgl texture object
            * @method createTexture
            * @param gl {WebGLRenderingContext}
            * @public
            */
            GLTextureWrapper.prototype.createTexture = function (gl) {
                this.texture = gl.createTexture();
                this._created = true;
                return true;
            };
            /**
            * Uploads a webgl texture object to video memory
            * @method uploadTexture
            * @param gl {WebGLRenderingContext}
            * @public
            */
            GLTextureWrapper.prototype.uploadTexture = function (gl) {
                var success = false;
                if (!this.created) {
                    this.createTexture(gl);
                }
                if (this.uploaded) {
                    Kiwi.Log.log("...not uploading:the image is already uploaded.", '#renderer', '#webgl');
                }
                else {
                    gl.bindTexture(gl.TEXTURE_2D, this.texture);
                    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this._image);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.bindTexture(gl.TEXTURE_2D, null);
                    //check gl error here
                    this._uploaded = true;
                    success = true;
                }
                return success;
            };
            /**
            * Re-uploads a webgl texture object to video memory
            * @method refreshTexture
            * @param gl {WebGLRenderingContext}
            * @public
            */
            GLTextureWrapper.prototype.refreshTexture = function (gl) {
                this.numBytes = this._image.width * this._image.height * 4;
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this._image);
            };
            /**
            * Deletes a webgl texture
            * @method deleteTexture
            * @param gl {WebGLRenderingContext}
            * @public
            */
            GLTextureWrapper.prototype.deleteTexture = function (gl) {
                gl.deleteTexture(this.texture);
                this._uploaded = false;
                this._created = false;
                return true;
            };
            return GLTextureWrapper;
        })();
        Renderers.GLTextureWrapper = GLTextureWrapper;
    })(Renderers = Kiwi.Renderers || (Kiwi.Renderers = {}));
})(Kiwi || (Kiwi = {}));
/**
*
*
* @module Kiwi
* @submodule Renderers
* @main Renderers
* @namespace Kiwi.Renderers
*/
var Kiwi;
(function (Kiwi) {
    var Renderers;
    (function (Renderers) {
        /**
       * Manages GL Texture objects, including creation, uploading, destruction and memory management
       * @class GLTextureManager
       * @constructor
       * @return {GLTextureManager}
       */
        var GLTextureManager = (function () {
            function GLTextureManager() {
                /**
                * The number of textures uploads in the last frame
                * @property numTextureWrites
                * @type number
                * @public
                */
                this.numTextureWrites = 0;
                this._numTexturesUsed = 0;
                this._usedTextureMem = 0;
                this.maxTextureMem = GLTextureManager.DEFAULT_MAX_TEX_MEM_MB * 1024 * 1024;
                this._textureWrapperCache = new Array();
            }
            Object.defineProperty(GLTextureManager.prototype, "usedTextureMem", {
                get: function () {
                    return this._usedTextureMem;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(GLTextureManager.prototype, "numTexturesUsed", {
                get: function () {
                    return this._numTexturesUsed;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Adds a texture wrapper to the cache
            * @method _addTextureToCache
            * @param glTexture {GLTextureWrapper}
            * @private
            */
            GLTextureManager.prototype._addTextureToCache = function (glTexture) {
                this._textureWrapperCache.push(glTexture);
            };
            /**
            * Deletes a texture from memory and removes the wrapper from the cache
            * @method _deleteTexture
            * @param gl {WebGLRenderingContext}
            * @param idx {number}
            * @private
            */
            GLTextureManager.prototype._deleteTexture = function (gl, idx) {
                this._textureWrapperCache[idx].deleteTexture(gl);
                this._usedTextureMem -= this._textureWrapperCache[idx].numBytes;
                this._numTexturesUsed--;
            };
            /**
            * Uploads a texture to video memory
            * @method _uploadTexture
            * @param gl {WebGLRenderingContext}
            * @param glTextureWrapper {GLTextureWrapper}
            * @return boolean
            * @private
            */
            GLTextureManager.prototype._uploadTexture = function (gl, glTextureWrapper) {
                //only upload it if it fits
                if (glTextureWrapper.numBytes + this._usedTextureMem <= this.maxTextureMem) {
                    glTextureWrapper.uploadTexture(gl);
                    this._usedTextureMem += glTextureWrapper.numBytes;
                    this._numTexturesUsed++;
                    return true;
                }
                return false;
            };
            /**
            * Uploads a texture library to video memory
            * @method uploadTextureLibrary
            * @param gl {WebGLRenderingContext}
            * @param textureLibrary {Kiwi.Textures.TextureLibrary}
            * @public
            */
            GLTextureManager.prototype.uploadTextureLibrary = function (gl, textureLibrary) {
                this._textureWrapperCache = new Array();
                for (var tex in textureLibrary.textures) {
                    // Tell the atlas to prepare its wrappers
                    textureLibrary.textures[tex].createGLTextureWrapper(gl, this);
                }
            };
            /**
            * Uploads a single texture to video memory
            * @method uploadTexture
            * @param gl {WebGLRenderingContext}
            * @param textureAtlas {Kiwi.Textures.TextureAtlas}
            * @public
            */
            GLTextureManager.prototype.uploadTexture = function (gl, textureAtlas) {
                textureAtlas.createGLTextureWrapper(gl, this);
            };
            /**
            * Adds a texture wrapper to the manager. This both adds the wrapper to the manager cache, and attempts to upload the attached texture to video memory.
            * @method registerTextureWrapper
            * @param gl {WebGLRenderingContext}
            * @param glTextureWrapper {GLTextureWrapper}
            * @public
            * @since 1.1.0
            */
            GLTextureManager.prototype.registerTextureWrapper = function (gl, glTextureWrapper) {
                this._addTextureToCache(glTextureWrapper);
                // Only upload it if it fits
                if (!this._uploadTexture(gl, glTextureWrapper)) {
                    Kiwi.Log.log("...skipped uploading texture due to allocated texture memory exceeded.", '#renderer', '#webgl');
                }
            };
            /**
            * Removes all textures from video memory and clears the wrapper cache
            * @method clearTextures
            * @param gl {WebGLRenderingContext}
            * @public
            */
            GLTextureManager.prototype.clearTextures = function (gl) {
                for (var i = 0; i < this._textureWrapperCache.length; i++) {
                    // Delete from graphics memory
                    this._deleteTexture(gl, i);
                    //kill the reference on the atlas
                    this._textureWrapperCache[i].textureAtlas.glTextureWrapper = null;
                }
                this._textureWrapperCache = new Array();
            };
            /**
            * Binds the texture ready for use, uploads it if it isn't already
            * @method useTexture
            * @param gl {WebGLRenderingContext}
            * @param glTextureWrapper {GLTextureWrappery}
            * @param [textureUnit=0] {number} Optional parameter for multitexturing. You can have up to 32 textures available to a shader at one time, in the range 0-31. If you don't need multiple textures, this is perfectly safe to ignore.
            * @return boolean
            * @public
            */
            GLTextureManager.prototype.useTexture = function (gl, glTextureWrapper, textureUnit) {
                if (textureUnit === void 0) { textureUnit = 0; }
                textureUnit = Kiwi.Utils.GameMath.clamp(Kiwi.Utils.GameMath.truncate(textureUnit), 31); // Convert to integer in range 0-31.
                if (!glTextureWrapper.created || !glTextureWrapper.uploaded) {
                    if (!this._uploadTexture(gl, glTextureWrapper)) {
                        this._freeSpace(gl, glTextureWrapper.numBytes);
                        this._uploadTexture(gl, glTextureWrapper);
                    }
                    this.numTextureWrites++;
                }
                //use texture
                if (glTextureWrapper.created && glTextureWrapper.uploaded) {
                    // Determine target texture unit
                    // This could be determined as:
                    //   var targetTextureUnit = "TEXTURE" + textureUnit;
                    //   gl.activeTexture(gl[targetTextureUnit]);
                    // But because the Khronos WebGL spec defines 
                    // the glenums of TEXTURE0-31 to be consecutive,
                    // this should be safe and fast:
                    var targetTextureUnit = gl.TEXTURE0 + textureUnit;
                    gl.activeTexture(targetTextureUnit);
                    // Bind texture to unit
                    gl.bindTexture(gl.TEXTURE_2D, glTextureWrapper.texture);
                    //gl.uniform2fv(textureSizeUniform, new Float32Array([glTextureWrapper.image.width, glTextureWrapper.image.height]));
                    return true;
                }
                return false;
            };
            /**
            * Attempts to free space in video memory.
            *
            * This removes textures sequentially, starting from the first cached texture. This may remove textures that are in use. These should automatically re-upload into the last position. After a few frames, this will push in-use textures to the safe end of the queue.
            *
            * If there are too many textures in use to fit in memory, they will all be cycled every frame, even if it would be more efficient to swap out one or two very large textures and preserve several smaller ones. This is an issue with this implementation and should be fixed.
            *
            * This behaviour was changed in v1.1.0. Previous versions used a different memory freeing algorithm.
            * @method _freeSpace
            * @param gl {WebGLRenderingContext}
            * @param numBytesToRemove {number}
            * @return boolean
            * @private
            */
            GLTextureManager.prototype._freeSpace = function (gl, numBytesToRemove) {
                // Sequential remover
                var bytesRemoved = 0;
                for (var i = 0; i < this._textureWrapperCache.length; i++) {
                    // Scrub uploaded textures
                    if (this._textureWrapperCache[i].uploaded) {
                        bytesRemoved += this._textureWrapperCache[i].numBytes;
                        this._deleteTexture(gl, i);
                    }
                    // Break on reaching or exceeding free target
                    if (numBytesToRemove <= bytesRemoved)
                        return true;
                }
                return false;
            };
            /**
            * The default maximum amount of texture memory to use before swapping textures
            * @property DEFAULT_MAX_TEX_MEM_MB
            * @type number
            * @public
            * @static
            */
            GLTextureManager.DEFAULT_MAX_TEX_MEM_MB = 1024;
            return GLTextureManager;
        })();
        Renderers.GLTextureManager = GLTextureManager;
    })(Renderers = Kiwi.Renderers || (Kiwi.Renderers = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Renderers
* @namespace Kiwi.Renderers
*/
var Kiwi;
(function (Kiwi) {
    var Renderers;
    (function (Renderers) {
        /**
        * Encapsulates a WebGL Array Buffer
        * @class GLArrayBuffer
        * @constructor
        * @namespace Kiwi.Renderers
        * @param gl {WebGLRenderingContext}
        * @param [_itemSize] {number}
        * @param [items] {number[]}
        * @param [init=true] {boolean}
        * @return {Kiwi.RenderersGLArrayBuffer}
        */
        var GLArrayBuffer = (function () {
            function GLArrayBuffer(gl, _itemSize, items, upload) {
                if (upload === void 0) { upload = true; }
                /**
                * Returns whether the buffer has been created
                * @property created
                * @type boolean
                * @public
                * @readonly
                */
                this._created = false;
                /**
                * Returns whether the buffer has been uploaded to video memory
                * @property created
                * @type boolean
                * @public
                * @readonly
                */
                this._uploaded = false;
                this.items = items || GLArrayBuffer.squareVertices;
                this.itemSize = _itemSize || 2;
                this.numItems = this.items.length / this.itemSize;
                this.createBuffer(gl);
                if (upload) {
                    this.uploadBuffer(gl, this.items);
                }
            }
            Object.defineProperty(GLArrayBuffer.prototype, "created", {
                get: function () {
                    return this._created;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(GLArrayBuffer.prototype, "uploaded", {
                get: function () {
                    return this._uploaded;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Clears the item array.
            * @method clear
            * @public
            */
            GLArrayBuffer.prototype.clear = function () {
                this.items = new Array();
            };
            /**
            * Creates the array buffer.
            * @method createBuffer
            * @param gl {WebGLRenderingContext}
            * @return {WebGLBuffer}
            * @public
            */
            GLArrayBuffer.prototype.createBuffer = function (gl) {
                this.buffer = gl.createBuffer();
                this._created = true;
                return true;
            };
            /**
            * Uploads the array buffer.
            * @method uploadBuffer
            * @param gl {WebGLRenderingContext}
            * @param items {Array}
            * @return {boolean}
            * @public
            */
            GLArrayBuffer.prototype.uploadBuffer = function (gl, items) {
                this.items = items;
                this.numItems = this.items.length / this.itemSize;
                var f32 = new Float32Array(this.items);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
                gl.bufferData(gl.ARRAY_BUFFER, f32, gl.DYNAMIC_DRAW);
                this._uploaded = true;
                return true;
            };
            /**
            * Deletes the array buffer.
            * @method deleteBuffer
            * @param gl {WebGLRenderingContext}
            * @return {boolean}
            * @public
            */
            GLArrayBuffer.prototype.deleteBuffer = function (gl) {
                gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
                gl.deleteBuffer(this.buffer);
                this.uploaded = false;
                this.created = false;
                return true;
            };
            /**
            *
            * @property squareVertices
            * @type number[]
            * @static
            * @default [0, 0, 100, 0, 100, 100, 0, 100]
            * @public
            */
            GLArrayBuffer.squareVertices = [
                0, 0,
                100, 0,
                100, 100,
                0, 100
            ];
            /**
            *
            * @property squareUVs
            * @type number[]
            * @static
            * @default [0, 0, .1, 0, .1, .1, 0, .1]
            * @public
            */
            GLArrayBuffer.squareUVs = [
                0, 0,
                .1, 0,
                .1, .1,
                0, .1
            ];
            /**
            *
            * @property squareCols
            * @type number[]
            * @static
            * @default [1, 1, 1, 1]
            * @public
            */
            GLArrayBuffer.squareCols = [
                1, 1, 1, 1
            ];
            return GLArrayBuffer;
        })();
        Renderers.GLArrayBuffer = GLArrayBuffer;
    })(Renderers = Kiwi.Renderers || (Kiwi.Renderers = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Renderers
* @namespace Kiwi.Renderers
*
*/
var Kiwi;
(function (Kiwi) {
    var Renderers;
    (function (Renderers) {
        /**
        * The Blend Mode object for recording and applying GL blend functions on a renderer.
        * @class GLBlendMode
        * @constructor
        * @namespace Kiwi.Renderers
        * @param gl {WebGLRenderingContext}
        * @param params {Object}
        * @return {Kiwi.Renderers.GLBlendMode}
        * @ since 1.1.0
        */
        var GLBlendMode = (function () {
            function GLBlendMode(gl, params) {
                this.gl = gl;
                this.dirty = true;
                // Set default parameters
                this._srcRGB = gl.SRC_ALPHA;
                this._dstRGB = gl.ONE_MINUS_SRC_ALPHA;
                this._srcAlpha = gl.ONE;
                this._dstAlpha = gl.ONE;
                this._modeRGB = gl.FUNC_ADD;
                this._modeAlpha = gl.FUNC_ADD;
                // Process params
                if (typeof params === "undefined") {
                    params = null;
                }
                if (params)
                    this.readConfig(params);
            }
            /**
            * Set a blend mode from a param object.
            *
            * This is the main method for configuring blend modes on a renderer. It resolves to a pair of calls to blendEquationSeparate and blendFuncSeparate. The params object should specify compatible terms, namely { srcRGB: a, dstRGB: b, srcAlpha: c, dstAlpha: d, modeRGB: e, modeAlpha: f }. You should set abcdef using either direct calls to a gl context (ie. gl.SRC_ALPHA) or by using predefined strings.
            *
            * The predefined string parameters for blendEquationSeparate are:
            *
            * FUNC_ADD, FUNC_SUBTRACT, and FUNC_REVERSE_SUBTRACT.
            *
            * The predefined string parameters for blendFuncSeparate are:
            *
            * ZERO, ONE, SRC_COLOR, ONE_MINUS_SRC_COLOR, DST_COLOR, ONE_MINUS_DST_COLOR, SRC_ALPHA, ONE_MINUS_SRC_ALPHA, DST_ALPHA, ONE_MINUS_DST_ALPHA, SRC_ALPHA_SATURATE, CONSTANT_COLOR, ONE_MINUS_CONSTANT_COLOR, CONSTANT_ALPHA, and ONE_MINUS_CONSTANT_ALPHA.
            *
            * @method readConfig
            * @param params {Object}
            * @public
            */
            GLBlendMode.prototype.readConfig = function (params) {
                if (params.mode !== undefined)
                    this.setMode(params.mode);
                else {
                    // Expecting a series of constants in "number" type from a GL object, or valid string names corresponding to same.
                    // Sanitise input - do not change unspecified values
                    params.srcRGB = this.makeConstant(params.srcRGB);
                    if (typeof params.srcRGB !== "undefined")
                        this._srcRGB = params.srcRGB;
                    params.dstRGB = this.makeConstant(params.dstRGB);
                    if (typeof params.dstRGB !== "undefined")
                        this._dstRGB = params.dstRGB;
                    params.srcAlpha = this.makeConstant(params.srcAlpha);
                    if (typeof params.srcAlpha !== "undefined")
                        this._srcAlpha = params.srcAlpha;
                    params.dstAlpha = this.makeConstant(params.dstAlpha);
                    if (typeof params.dstAlpha !== "undefined")
                        this._dstAlpha = params.dstAlpha;
                    params.modeRGB = this.makeConstant(params.modeRGB);
                    if (typeof params.modeRGB !== "undefined")
                        this._modeRGB = params.modeRGB;
                    params.modeAlpha = this.makeConstant(params.modeAlpha);
                    if (typeof params.modeAlpha !== "undefined")
                        this._modeAlpha = params.modeAlpha;
                }
                this.dirty = true;
            };
            /**
            * Formats a parameter into a GL context-compatible number. This recognises valid constant names, such as "SRC_ALPHA" or "REVERSE_AND_SUBTRACT", with some tolerance for case. It does not check for valid numeric codes.
            * @method makeConstant
            * @param code {String}
            * @return {number}
            * @private
            */
            GLBlendMode.prototype.makeConstant = function (code) {
                // Numbers are assumed to be correct.
                if (typeof code == "number")
                    return (code);
                if (typeof code == "string")
                    code = code.toUpperCase();
                switch (code) {
                    case "ZERO":
                        code = this.gl.ZERO;
                        break;
                    case "ONE":
                        code = this.gl.ONE;
                        break;
                    case "SRC_COLOR":
                    case "SRC_COLOUR":
                        code = this.gl.SRC_COLOR;
                        break;
                    case "ONE_MINUS_SRC_COLOR":
                    case "ONE_MINUS_SRC_COLOUR":
                        code = this.gl.ONE_MINUS_SRC_COLOR;
                        break;
                    case "DST_COLOR":
                    case "DST_COLOUR":
                        code = this.gl.DST_COLOR;
                        break;
                    case "ONE_MINUS_DST_COLOR":
                    case "ONE_MINUS_DST_COLOUR":
                        code = this.gl.ONE_MINUS_DST_COLOR;
                        break;
                    case "SRC_ALPHA":
                        code = this.gl.SRC_ALPHA;
                        break;
                    case "ONE_MINUS_SRC_ALPHA":
                        code = this.gl.ONE_MINUS_SRC_ALPHA;
                        break;
                    case "DST_ALPHA":
                        code = this.gl.DST_ALPHA;
                        break;
                    case "ONE_MINUS_DST_ALPHA":
                        code = this.gl.ONE_MINUS_DST_ALPHA;
                        break;
                    case "SRC_ALPHA_SATURATE":
                        code = this.gl.SRC_ALPHA_SATURATE;
                        break;
                    case "CONSTANT_COLOR":
                    case "CONSTANT_COLOUR":
                        code = this.gl.CONSTANT_COLOR;
                        break;
                    case "ONE_MINUS_CONSTANT_COLOR":
                    case "ONE_MINUS_CONSTANT_COLOUR":
                        code = this.gl.ONE_MINUS_CONSTANT_COLOR;
                        break;
                    case "CONSTANT_ALPHA":
                        code = this.gl.CONSTANT_ALPHA;
                        break;
                    case "ONE_MINUS_CONSTANT_ALPHA":
                        code = this.gl.ONE_MINUS_CONSTANT_ALPHA;
                        break;
                    case "FUNC_ADD":
                        code = this.gl.FUNC_ADD;
                        break;
                    case "FUNC_SUBTRACT":
                        code = this.gl.FUNC_SUBTRACT;
                        break;
                    case "FUNC_REVERSE_SUBTRACT":
                        code = this.gl.FUNC_REVERSE_SUBTRACT;
                        break;
                    default:
                        code = undefined;
                        break;
                }
                return (code);
            };
            /**
            * Sets a blend mode by name. Name is case-tolerant.
            *
            * These are shortcuts to setting the blend function parameters manually. A listing of valid modes follows. Each is listed with the parameters modeRGB, modeAlpha, srcRGB, dstRGB, srcAlpha, and dstAlpha, constants used in the gl calls "blendEquationSeparate(modeRGB, modeAlpha)" and "blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha". This is very technical, and will probably only be useful if you are developing your own shaders for Kiwi.js.
            *
            * "NORMAL" or any non-recognised string will draw as normal, blending colour via alpha. FUNC_ADD, FUNC_ADD, SRC_ALPHA, ONE_MINUS_SRC_ALPHA, ONE, ONE.
            *
            * "ADD" or "ADDITIVE" will add pixels to the background, creating a lightening effect. FUNC_ADD, FUNC_ADD, SRC_ALPHA, ONE, ONE, ONE.
            *
            * "SUBTRACT" or "SUBTRACTIVE" will subtract pixels from the background, creating an eerie dark effect. FUNC_REVERSE_SUBTRACT, FUNC_ADD, SRC_ALPHA, ONE, ONE, ONE.
            *
            * "ERASE" or "ERASER" will erase the game canvas itself, allowing the page background to show through. You can later draw over this erased region. FUNC_REVERSE_SUBTRACT, FUNC_REVERSE_SUBTRACT, SRC_ALPHA, ONE_MINUS_SRC_ALPHA, ONE, ONE.
            *
            * "BLACK" or "BLACKEN" will turn all colour black, but preserve alpha. FUNC_ADD, FUNC_ADD, ZERO, ONE_MINUS_SRC_ALPHA, ONE, ONE.
            *
            * Blend modes as seen in Adobe Photoshop are not reliably available via WebGL blend modes. Such blend modes require shaders to create.
            * @method setMode
            * @param mode {String}
            * @public
            */
            GLBlendMode.prototype.setMode = function (mode) {
                mode = mode.toUpperCase();
                switch (mode) {
                    case "ADDITIVE":
                    case "ADD":
                        this._srcRGB = this.gl.SRC_ALPHA;
                        this._dstRGB = this.gl.ONE;
                        this._srcAlpha = this.gl.ONE;
                        this._dstAlpha = this.gl.ONE;
                        this._modeRGB = this.gl.FUNC_ADD;
                        this._modeAlpha = this.gl.FUNC_ADD;
                        break;
                    case "SUBTRACT":
                    case "SUBTRACTIVE":
                        this._srcRGB = this.gl.SRC_ALPHA;
                        this._dstRGB = this.gl.ONE;
                        this._srcAlpha = this.gl.ONE;
                        this._dstAlpha = this.gl.ONE;
                        this._modeRGB = this.gl.FUNC_REVERSE_SUBTRACT;
                        this._modeAlpha = this.gl.FUNC_ADD;
                        break;
                    case "ERASE":
                    case "ERASER":
                        this._srcRGB = this.gl.SRC_ALPHA;
                        this._dstRGB = this.gl.ONE_MINUS_SRC_ALPHA;
                        this._srcAlpha = this.gl.ONE;
                        this._dstAlpha = this.gl.ONE;
                        this._modeRGB = this.gl.FUNC_REVERSE_SUBTRACT;
                        this._modeAlpha = this.gl.FUNC_REVERSE_SUBTRACT;
                        break;
                    case "BLACK":
                    case "BLACKEN":
                        this._srcRGB = this.gl.ZERO;
                        this._dstRGB = this.gl.ONE_MINUS_SRC_ALPHA;
                        this._srcAlpha = this.gl.ONE;
                        this._dstAlpha = this.gl.ONE;
                        this._modeRGB = this.gl.FUNC_ADD;
                        this._modeAlpha = this.gl.FUNC_ADD;
                        break;
                    case "NORMAL":
                    default:
                        this._srcRGB = this.gl.SRC_ALPHA;
                        this._dstRGB = this.gl.ONE_MINUS_SRC_ALPHA;
                        this._srcAlpha = this.gl.ONE;
                        this._dstAlpha = this.gl.ONE;
                        this._modeRGB = this.gl.FUNC_ADD;
                        this._modeAlpha = this.gl.FUNC_ADD;
                        break;
                }
                this.dirty = true;
            };
            /**
            * Compares against another GLBlendMode
            * @method isIdentical
            * @return {Boolean} Is this GLBlendMode identical to the passed GLBlendMode?
            * @param blendMode {Kiwi.Renderers.GLBlendMode}
            * @public
            */
            GLBlendMode.prototype.isIdentical = function (blendMode) {
                if (this == blendMode)
                    return (true);
                if (this._srcRGB == blendMode._srcRGB
                    && this._dstRGB == blendMode._dstRGB
                    && this._srcAlpha == blendMode._srcAlpha
                    && this._dstAlpha == blendMode._dstAlpha
                    && this._modeRGB == blendMode._modeRGB
                    && this._modeAlpha == blendMode._modeAlpha)
                    return (true);
                return (false);
            };
            /**
            * Sets the blend mode on the video card
            * @method apply
            * @param gl {WebGLRenderingContext}
            * @public
            */
            GLBlendMode.prototype.apply = function (gl) {
                gl.blendEquationSeparate(this._modeRGB, this._modeAlpha);
                gl.blendFuncSeparate(this._srcRGB, this._dstRGB, this._srcAlpha, this._dstAlpha);
                // Remove dirty flag
                this.dirty = false;
            };
            return GLBlendMode;
        })();
        Renderers.GLBlendMode = GLBlendMode;
    })(Renderers = Kiwi.Renderers || (Kiwi.Renderers = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Renderers
*
*/
var Kiwi;
(function (Kiwi) {
    var Renderers;
    (function (Renderers) {
        /**
        * Encapsulates a WebGL Element Array Buffer
        * @class GLElementArrayBuffer
        * @constructor
        * @namespace Kiwi.Renderers
        * @param gl {WebGLRenderingContent}
        * @param [_itemSize] {number}
        * @param [_indices] {number[]}
        * @param [init=true] {boolean}
        * @return {GLElementArrayBuffer}
        */
        var GLElementArrayBuffer = (function () {
            function GLElementArrayBuffer(gl, _itemSize, _indices, init) {
                if (init === void 0) { init = true; }
                this.indices = _indices || GLElementArrayBuffer.square;
                this.itemSize = _itemSize || 1;
                this.numItems = this.indices.length / this.itemSize;
                if (init) {
                    this.buffer = this.init(gl);
                }
            }
            /**
            * Clears the indices array.
            * @method clear
            * @public
            */
            GLElementArrayBuffer.prototype.clear = function () {
                this.indices = new Array();
            };
            /**
            * Initialises the Element Array Buffer
            * @method init
            * @param gl {WebGLRenderingContext}
            * @return {WebGLBuffer}
            * @public
            */
            GLElementArrayBuffer.prototype.init = function (gl) {
                var buffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.indices), gl.STATIC_DRAW);
                return buffer;
            };
            /**
            * Refreshes the Element Array Buffer
            * @method refresh
            * @param gl {WebGLRenderingContext}
            * @param indices {number[]}
            * @return {WebGLBuffer}
            * @public
            */
            GLElementArrayBuffer.prototype.refresh = function (gl, indices) {
                this.numItems = this.indices.length / this.itemSize;
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.indices), gl.STATIC_DRAW);
                return this.buffer;
            };
            /**
            * The required indices for a single quad.
            * @property square
            * @static
            * @type number[]
            * @default [0,1,2,0,2,3]
            * @public
            */
            GLElementArrayBuffer.square = [
                0, 1, 2,
                0, 2, 3
            ];
            return GLElementArrayBuffer;
        })();
        Renderers.GLElementArrayBuffer = GLElementArrayBuffer;
    })(Renderers = Kiwi.Renderers || (Kiwi.Renderers = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Renderers
* @namespace Kiwi.Renderers
*/
var Kiwi;
(function (Kiwi) {
    var Renderers;
    (function (Renderers) {
        var Renderer = (function () {
            /**
            * Base class for WebGL Renderers. Not for instantiation.
            * @class Renderer
            * @constructor
            * @namespace Kiwi.Renderers
            * @param gl {WebGLRenderingContext}
            * @param shaderManager {Kiwi.Shaders.ShaderManager}
            * @param [params=null] {object}
            * @return {Kiwi.Renderers.Renderer}
            */
            function Renderer(gl, shaderManager, isBatchRenderer) {
                if (isBatchRenderer === void 0) { isBatchRenderer = false; }
                /**
                *
                * @property loaded
                * @type Array
                * @public
                */
                this.loaded = false;
                /**
                * Returns whether this is a batch renderer.
                * @property isBatchRenderer
                * @type boolean
                * @public
                */
                this._isBatchRenderer = false;
                this.shaderManager = shaderManager;
                this._isBatchRenderer = isBatchRenderer;
                this.loaded = true;
                this.blendMode = new Kiwi.Renderers.GLBlendMode(gl, { mode: "NORMAL" });
            }
            /**
            * Enables the renderer (for override)
            * @method enable
            * @param gl {WebGLRenderingContext}
            * @param [params=null] {object}
            * @public
            */
            Renderer.prototype.enable = function (gl, params) {
                if (params === void 0) { params = null; }
            };
            /**
            * Enables the renderer (for override)
            * @method disable
            * @param gl {WebGLRenderingContext}
            * @param [params=null] {object}
            * @public
            */
            Renderer.prototype.disable = function (gl) {
            };
            /**
            * Enables the renderer (for override)
            * @method clear
            * @param gl {WebGLRenderingContext}
            * @param [params=null] {object}
            * @public
            */
            Renderer.prototype.clear = function (gl, params) {
            };
            /**
            * Draw to the draw or frame buffer (for override)
            * @method draw
            * @param gl {WebGLRenderingContext}
            * @public
            */
            Renderer.prototype.draw = function (gl) {
            };
            /**
            * Updates the stage resolution uniforms (for override)
            * @method updateStageResolution
            * @param gl {WebGLRenderingContext}
            * @param res {Float32Array}
            * @public
            */
            Renderer.prototype.updateStageResolution = function (gl, res) {
            };
            /**
           * Updates the texture size uniforms (for override)
           * @method updateTextureSize
           * @param gl {WebGLRenderingContext}
           * @param size {Float32Array}
           * @public
           */
            Renderer.prototype.updateTextureSize = function (gl, size) {
            };
            Object.defineProperty(Renderer.prototype, "isBatchRenderer", {
                get: function () {
                    return this._isBatchRenderer;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Identifier for this renderer
            * @property RENDERER_ID
            * @type String
            * @public
            * @static
            */
            Renderer.RENDERER_ID = "Renderer";
            return Renderer;
        })();
        Renderers.Renderer = Renderer;
    })(Renderers = Kiwi.Renderers || (Kiwi.Renderers = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Renderers
* @namespace Kiwi.Renderers
*/
var Kiwi;
(function (Kiwi) {
    var Renderers;
    (function (Renderers) {
        var TextureAtlasRenderer = (function (_super) {
            __extends(TextureAtlasRenderer, _super);
            /**
            * The Renderer object for rendering Texture Atlases
            * @class TextureAtlasRenderer
            * @constructor
            * @extends Kiwi.Renderers.Renderer
            * @namespace Kiwi.Renderers
            * @param gl {WebGLRenderingContext}
            * @param shaderManager {Kiwi.Shaders.ShaderManager}
            * @param [params=null] {object}
            * @return {Kiwi.Renderers.TextureAtlasRenderer}
            */
            function TextureAtlasRenderer(gl, shaderManager, params) {
                if (params === void 0) { params = null; }
                _super.call(this, gl, shaderManager, true);
                /**
                * The reference to the shaderPair.
                * @property _shaderPairName
                * @type String
                * @private
                * @since 1.1.0
                */
                this._shaderPairName = "TextureAtlasShader";
                /**
                * The maximum number of items that can be rendered by the renderer (not enforced)
                * @property _maxItems
                * @type number
                * @private
                */
                this._maxItems = 1000;
                /**
                * Geometry point used in rendering.
                *
                * @property _pt1
                * @type Kiwi.Geom.Point
                * @private
                */
                this._pt1 = new Kiwi.Geom.Point(0, 0);
                /**
                * Geometry point used in rendering.
                *
                * @property _pt2
                * @type Kiwi.Geom.Point
                * @private
                */
                this._pt2 = new Kiwi.Geom.Point(0, 0);
                /**
                * Geometry point used in rendering.
                *
                * @property _pt3
                * @type Kiwi.Geom.Point
                * @private
                */
                this._pt3 = new Kiwi.Geom.Point(0, 0);
                /**
                * Geometry point used in rendering.
                *
                * @property _pt4
                * @type Kiwi.Geom.Point
                * @private
                */
                this._pt4 = new Kiwi.Geom.Point(0, 0);
                var bufferItemSize = 5;
                this._vertexBuffer = new Renderers.GLArrayBuffer(gl, bufferItemSize);
                var vertsPerQuad = 6;
                this._indexBuffer = new Renderers.GLElementArrayBuffer(gl, 1, this._generateIndices(this._maxItems * vertsPerQuad));
                this.shaderPair = this.shaderManager.requestShader(gl, this._shaderPairName);
            }
            /**
            * Enables the renderer ready for drawing
            * @method enable
            * @param gl {WebGLRenderingContext}
            * @param [params=null] {object}
            * @public
            */
            TextureAtlasRenderer.prototype.enable = function (gl, params) {
                if (params === void 0) { params = null; }
                //this.shaderPair = <Kiwi.Shaders.TextureAtlasShader>this.shaderManager.requestShader(gl, "TextureAtlasShader", true);
                this.shaderPair = this.shaderManager.requestShader(gl, this._shaderPairName, true);
                //Texture
                gl.uniform1i(this.shaderPair.uniforms.uSampler.location, 0);
                //Other uniforms
                gl.uniform2fv(this.shaderPair.uniforms.uResolution.location, params.stageResolution);
                gl.uniformMatrix3fv(this.shaderPair.uniforms.uCamMatrix.location, false, params.camMatrix);
            };
            /**
            * Disables the renderer
            * @method disable
            * @param gl {WebGLRenderingContext}
            * @public
            */
            TextureAtlasRenderer.prototype.disable = function (gl) {
                gl.disableVertexAttribArray(this.shaderPair.attributes.aXYUV);
                gl.disableVertexAttribArray(this.shaderPair.attributes.aAlpha);
            };
            /**
            * Clears the vertex buffer.
            * @method clear
            * @param gl {WebGLRenderingContext}
            * @public
            */
            TextureAtlasRenderer.prototype.clear = function (gl, params) {
                this._vertexBuffer.clear();
                gl.uniformMatrix3fv(this.shaderPair.uniforms.uCamMatrix.location, false, params.camMatrix);
            };
            /**
            * Makes a draw call, this is where things actually get rendered to the draw buffer (or a framebuffer).
            * @method draw
            * @param gl {WebGLRenderingContext}
            * @public
            */
            TextureAtlasRenderer.prototype.draw = function (gl) {
                this._vertexBuffer.uploadBuffer(gl, this._vertexBuffer.items);
                gl.enableVertexAttribArray(this.shaderPair.attributes.aXYUV);
                gl.vertexAttribPointer(this.shaderPair.attributes.aXYUV, 4, gl.FLOAT, false, 20, 0);
                gl.enableVertexAttribArray(this.shaderPair.attributes.aAlpha);
                gl.vertexAttribPointer(this.shaderPair.attributes.aAlpha, 1, gl.FLOAT, false, 20, 16);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer.buffer);
                gl.drawElements(gl.TRIANGLES, (this._vertexBuffer.items.length / 20) * 6, gl.UNSIGNED_SHORT, 0);
            };
            /**
            * Generates quad indices
            * @method _generateIndices
            * @param numQuads {number}
            * @private
            */
            TextureAtlasRenderer.prototype._generateIndices = function (numQuads) {
                var quads = new Array();
                for (var i = 0; i < numQuads; i++) {
                    quads.push(i * 4 + 0, i * 4 + 1, i * 4 + 2, i * 4 + 0, i * 4 + 2, i * 4 + 3);
                }
                return quads;
            };
            /**
            * Updates the stage resolution uniforms
            * @method updateStageResolution
            * @param gl {WebGLRenderingContext}
            * @param res {Float32Array}
            * @public
            */
            TextureAtlasRenderer.prototype.updateStageResolution = function (gl, res) {
                gl.uniform2fv(this.shaderPair.uniforms.uResolution.location, res);
            };
            /**
            * Updates the texture size uniforms
            * @method updateTextureSize
            * @param gl {WebGLRenderingContext}
            * @param size {Float32Array}
            * @public
            */
            TextureAtlasRenderer.prototype.updateTextureSize = function (gl, size) {
                gl.uniform2fv(this.shaderPair.uniforms.uTextureSize.location, size);
            };
            /**
            * Sets shader pair by name
            * @method setShaderPair
            * @param shaderPair {String}
            * @public
            * @since 1.1.0
            */
            TextureAtlasRenderer.prototype.setShaderPair = function (shaderPair) {
                if (typeof shaderPair == "string")
                    this._shaderPairName = shaderPair;
            };
            /**
            * Collates all xy and uv coordinates into a buffer ready for upload to video memory
            * @method addToBatch
            * @param gl {WebGLRenderingContext}
            * @param entity {Kiwi.Entity}
            * @param camera {Camera}
            * @public
            */
            TextureAtlasRenderer.prototype.addToBatch = function (gl, entity, camera) {
                // Skip if it's invisible due to zero alpha
                if (entity.alpha <= 0) {
                    return;
                }
                var t = entity.transform;
                var m = t.getConcatenatedMatrix();
                var cell = entity.atlas.cells[entity.cellIndex];
                this._pt1.setTo(0 - t.rotPointX, 0 - t.rotPointY);
                this._pt2.setTo(cell.w - t.rotPointX, 0 - t.rotPointY);
                this._pt3.setTo(cell.w - t.rotPointX, cell.h - t.rotPointY);
                this._pt4.setTo(0 - t.rotPointX, cell.h - t.rotPointY);
                m.transformPoint(this._pt1);
                m.transformPoint(this._pt2);
                m.transformPoint(this._pt3);
                m.transformPoint(this._pt4);
                this._vertexBuffer.items.push(this._pt1.x, this._pt1.y, cell.x, cell.y, entity.alpha, this._pt2.x, this._pt2.y, cell.x + cell.w, cell.y, entity.alpha, this._pt3.x, this._pt3.y, cell.x + cell.w, cell.y + cell.h, entity.alpha, this._pt4.x, this._pt4.y, cell.x, cell.y + cell.h, entity.alpha);
            };
            /**
            * Adds an array of precalculated xyuv values to the item array
            * @method concatBatch
            * @param vertexItems {array}
            * @public
            */
            TextureAtlasRenderer.prototype.concatBatch = function (vertexItems) {
                this._vertexBuffer.items = this._vertexBuffer.items.concat(vertexItems);
            };
            /**
            * The identifier for this renderer.
            * @property RENDERER_ID
            * @type Array
            * @public
            * @static
            */
            TextureAtlasRenderer.RENDERER_ID = "TextureAtlasRenderer";
            return TextureAtlasRenderer;
        })(Renderers.Renderer);
        Renderers.TextureAtlasRenderer = TextureAtlasRenderer;
    })(Renderers = Kiwi.Renderers || (Kiwi.Renderers = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Shaders
* @namespace Kiwi.Shaders
*
*/
var Kiwi;
(function (Kiwi) {
    var Shaders;
    (function (Shaders) {
        /**
        * Base class for shader pairs which encapsulate a GLSL vertex and fragment shader
        * @class ShaderPair
        * @constructor
        * @namespace Kiwi.Shaders
        * @return {Kiwi.Shaders.ShaderPair}
        */
        var ShaderPair = (function () {
            function ShaderPair() {
                /**
                * Returns whether the shader pair has been loaded and compiled.
                * @property loaded
                * @type boolean
                * @public
                */
                this.loaded = false;
            }
            /**
            * Initialise the shader pair.
            * @method init
            * @param gl {WebGLRenderingCotext}
            * @public
            */
            ShaderPair.prototype.init = function (gl) {
                this.vertShader = this.compile(gl, this.vertSource.join("\n"), gl.VERTEX_SHADER);
                this.fragShader = this.compile(gl, this.fragSource.join("\n"), gl.FRAGMENT_SHADER);
                this.shaderProgram = this.attach(gl, this.vertShader, this.fragShader);
                this.loaded = true;
            };
            /**
            * Attaches the shaders to the program and links them
            * @method attach
            * @param gl {WebGLRenderingContext}
            * @param vertShader {WebGLShader}
            * @param fragShader {WebGLShader}
            * @return {WebGLProgram}
            * @public
            */
            ShaderPair.prototype.attach = function (gl, vertShader, fragShader) {
                var shaderProgram = gl.createProgram();
                gl.attachShader(shaderProgram, fragShader);
                gl.attachShader(shaderProgram, vertShader);
                gl.linkProgram(shaderProgram);
                return shaderProgram;
            };
            /**
            * Compiles the shaders
            * @method compile
            * @param gl {WebGLRenderingContext}
            * @param src {string}
            * @param shaderType {number}
            * @return {WebGLShader}
            * @public
            */
            ShaderPair.prototype.compile = function (gl, src, shaderType) {
                var shader = gl.createShader(shaderType);
                gl.shaderSource(shader, src);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    return null;
                }
                return shader;
            };
            /**
            * Sets a single uniform value and marks it as dirty.
            * @method setParam
            * @param uniformName {string}
            * @param value {*}
            * @public
            */
            ShaderPair.prototype.setParam = function (uniformName, value) {
                this.uniforms[uniformName].value = value;
                this.uniforms[uniformName].dirty = true;
            };
            /**
            * Applies all uniforms to the uploaded program
            * @method applyUniforms
            * @param gl {WebGLRenderingCotext}
            * @public
            */
            ShaderPair.prototype.applyUniforms = function (gl) {
                for (var u in this.uniforms) {
                    this.applyUniform(gl, u);
                }
            };
            /**
            * Applies a single uniforms to the uploaded program
            * @method applyUniform
            * @param gl {WebGLRenderingCotext}
            * @param name {string}
            * @public
            */
            ShaderPair.prototype.applyUniform = function (gl, name) {
                var u = this.uniforms[name];
                if (this.uniforms[name].dirty) {
                    gl["uniform" + u.type](u.location, u.value);
                    this.uniforms[name].dirty = false;
                }
            };
            /**
            * Initialises all uniforms
            * @method initUniforms
            * @param gl {WebGLRenderingCotext}
            * @public
            */
            ShaderPair.prototype.initUniforms = function (gl) {
                for (var uniformName in this.uniforms) {
                    var uniform = this.uniforms[uniformName];
                    uniform.location = gl.getUniformLocation(this.shaderProgram, uniformName);
                    uniform.dirty = true;
                    uniform.value = null;
                }
            };
            /**
            *
            * @property RENDERER_ID
            * @type string
            * @public
            * @static
            */
            ShaderPair.RENDERER_ID = "ShaderPair";
            return ShaderPair;
        })();
        Shaders.ShaderPair = ShaderPair;
    })(Shaders = Kiwi.Shaders || (Kiwi.Shaders = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Shaders
* @namespace Kiwi.Shaders
*/
var Kiwi;
(function (Kiwi) {
    var Shaders;
    (function (Shaders) {
        /**
        * Shader wrapper for rendering Texture Atlases
        * @class TextureAtlasShader
        * @extends Kiwi.Shaders.ShaderPair
        * @constructor
        * @namespace Kiwi.Shaders
        * @return {Kiwi.Shaders.TextureAtlasShader}
        */
        var TextureAtlasShader = (function (_super) {
            __extends(TextureAtlasShader, _super);
            function TextureAtlasShader() {
                _super.call(this);
                /**
                * Shader attribute references
                * @property attributes
                * @type object
                * @public
                */
                this.attributes = {
                    aXYUV: null,
                    aAlpha: null,
                };
                /**
                * Shader uniform descriptors
                * @property uniforms
                * @type object
                * @public
                */
                this.uniforms = {
                    uCamMatrix: {
                        type: "mat3",
                    },
                    uResolution: {
                        type: "2fv",
                    },
                    uTextureSize: {
                        type: "2fv",
                    },
                    uSampler: {
                        type: "1i",
                    }
                };
                /**
                * The source for the GLSL fragment shader
                * @property fragSource
                * @type Array
                * @public
                */
                this.fragSource = [
                    "precision mediump float;",
                    "varying vec2 vTextureCoord;",
                    "varying float vAlpha;",
                    "uniform sampler2D uSampler;",
                    "void main(void) {",
                    "gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y));",
                    "gl_FragColor.a *= vAlpha;",
                    "}"
                ];
                /**
                * The source for the GLSL vertex shader
                * @property vertSource
                * @type Array
                * @public
                */
                this.vertSource = [
                    "attribute vec4 aXYUV;",
                    "attribute float aAlpha;",
                    "uniform mat3 uCamMatrix;",
                    "uniform vec2 uResolution;",
                    "uniform vec2 uTextureSize;",
                    "varying vec2 vTextureCoord;",
                    "varying float vAlpha;",
                    "void main(void) {",
                    "   vec2 pos = (uCamMatrix * vec3(aXYUV.xy,1)).xy; ",
                    "   gl_Position = vec4((pos / uResolution * 2.0 - 1.0) * vec2(1, -1), 0, 1);",
                    "   vTextureCoord = aXYUV.zw / uTextureSize;",
                    "   vAlpha = aAlpha;",
                    "}"
                ];
            }
            /**
            * Initialise the shaderPair
            * @method init
            * @param gl {WebGLRenderingCotext}
            * @return {WebGLBuffer}
            * @public
            */
            TextureAtlasShader.prototype.init = function (gl) {
                _super.prototype.init.call(this, gl);
                this.attributes.aXYUV = gl.getAttribLocation(this.shaderProgram, "aXYUV");
                this.attributes.aAlpha = gl.getAttribLocation(this.shaderProgram, "aAlpha");
                this.initUniforms(gl);
            };
            return TextureAtlasShader;
        })(Shaders.ShaderPair);
        Shaders.TextureAtlasShader = TextureAtlasShader;
    })(Shaders = Kiwi.Shaders || (Kiwi.Shaders = {}));
})(Kiwi || (Kiwi = {}));
/**
* Is the namespace in which all code that is used to create/provide an animation of various sorts are stored. These could range from animations that change the cell of a SpriteSheet that is displayed every few seconds (Animation/Sequence), to animations that change a numeric value on a object over a period time (Tweens).
*
* @module Kiwi
* @submodule Animations
* @main Animations
*/
var Kiwi;
(function (Kiwi) {
    var Animations;
    (function (Animations) {
        /**
        * An Animation contains information about a single animation that is held on a AnimationManager.
        * The information that is held is unique to this individual animation and will initially be the same as a Sequence,
        * but if you do ever modify the information held in this Animation the corresponding Sequence will not be updated.
        *
        * @class Animation
        * @namespace Kiwi.Animations
        * @constructor
        * @param name {string} The name of this anim.
        * @param sequences {Kiwi.Animations.Sequences} The sequence that this anim will be using to animate.
        * @param clock {Kiwi.Time.Clock} A game clock that this anim will be using to keep record of the time between frames. (Deprecated in v1.2.0, because there is no way to control it.)
        * @param parent {Kiwi.Components.AnimationManager} The animation manager that this animation belongs to.
        * @return {Kiwi.Animations.Animation}
        *
        */
        var Animation = (function () {
            function Animation(name, sequence, clock, parent) {
                /**
                * The current frame index that the animation is currently upto.
                * Note: A frame index is the index of a particular cell in the Sequence.
                * @property _frameIndex
                * @type number
                * @private
                */
                this._frameIndex = 0;
                /**
                * The starting time of the animation from when it was played. Internal use only.
                * @property _startTime
                * @type number
                * @private
                */
                this._startTime = null;
                /**
                * Indicates whether the animation is playing in reverse or not.
                * @property _reverse
                * @type boolean
                * @private
                */
                this._reverse = false;
                /**
                * Whether the animation is currently playing or not.
                * @property _isPlaying
                * @type boolean
                * @default false
                * @private
                */
                this._isPlaying = false;
                /**
                * A Kiwi.Signal that dispatches an event when the animation has stopped playing.
                * @property _onStop
                * @type Signal
                * @private
                */
                this._onStop = null;
                /**
                * A Kiwi.Signal that dispatches an event when the animation has started playing.
                * @property _onPlay
                * @type Kiwi.Signal
                * @private
                */
                this._onPlay = null;
                /**
                * A Kiwi.Signal that dispatches an event when the animation has updated/changed frameIndexs.
                * @property _onUpdate
                * @type Kiwi.Signal
                * @private
                */
                this._onUpdate = null;
                /**
                * A Kiwi.Signal that dispatches an event when the animation has come to the end of the animation and is going to play again.
                * @property _onLoop
                * @type Kiwi.Signal
                * @private
                */
                this._onLoop = null;
                /**
                * A Kiwi.Signal that dispatches an event when the animation has come to
                * the end of the animation but is not going to play again.
                * @property _onComplete
                * @type Kiwi.Signal
                * @private
                * @since 1.2.0
                */
                this._onComplete = null;
                this.name = name;
                this._sequence = sequence;
                this._speed = sequence.speed;
                this._loop = sequence.loop;
                this._parent = parent;
                this._clock = clock;
                this._lastFrameElapsed = this.clock.elapsed();
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String} "Animation"
            * @public
            */
            Animation.prototype.objType = function () {
                return "Animation";
            };
            Object.defineProperty(Animation.prototype, "loop", {
                /**
                * If once the animation reaches the end, it should start again from the first cell in the sequence or not.
                * @property loop
                * @type boolean
                * @public
                */
                get: function () {
                    return this._loop;
                },
                set: function (value) {
                    this._loop = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Animation.prototype, "frameIndex", {
                /**
                * The current frame index that the animation is currently upto.
                * Note: A frame index is the index of a particular cell in the Sequence.
                *
                * As of v1.3.0, this property will work properly with floating-point
                * values. They will be rounded down and stored as integers.
                * @property frameIndex
                * @type number
                * @public
                */
                get: function () {
                    return this._frameIndex;
                },
                set: function (val) {
                    val = Math.floor(val);
                    if (this._validateFrame(val)) {
                        this._frameIndex = val;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Animation.prototype, "currentCell", {
                /**
                * Returns the current cell that the animation is up to. This is READ ONLY.
                * @property currentCell
                * @type number
                * @public
                */
                get: function () {
                    return this._sequence.cells[this.frameIndex];
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Animation.prototype, "speed", {
                /**
                * How long the each cell should stay on screen for. In seconds.
                * @property speed
                * @type number
                * @public
                */
                get: function () {
                    return this._speed;
                },
                set: function (value) {
                    this._speed = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Animation.prototype, "clock", {
                /**
                * Clock used by this Animation. If it was not set on creation,
                * the Animation will use its parent's entity's clock.
                * @property clock
                * @type Kiwi.Time.Clock
                * @public
                * @since 1.2.0
                */
                get: function () {
                    if (this._clock) {
                        return this._clock;
                    }
                    return this._parent.entity.clock;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Animation.prototype, "reverse", {
                get: function () {
                    return this._reverse;
                },
                /**
                * Whether the animation is to be played in reverse.
                * @property reverse
                * @type boolean
                * @public
                */
                set: function (value) {
                    this._reverse = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Animation.prototype, "isPlaying", {
                /**
                * Whether the animation is currently playing or not. Read-only.
                * @property isPlaying
                * @type boolean
                * @public
                */
                get: function () {
                    return this._isPlaying;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Animation.prototype, "onStop", {
                /**
                * A Kiwi.Signal that dispatches an event when the animation has stopped playing.
                * @property onStop
                * @type Signal
                * @public
                */
                get: function () {
                    if (this._onStop == null)
                        this._onStop = new Kiwi.Signal;
                    return this._onStop;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Animation.prototype, "onPlay", {
                /**
                * A Kiwi.Signal that dispatches an event when the animation has started playing.
                * @property onPlay
                * @type Kiwi.Signal
                * @public
                */
                get: function () {
                    if (this._onPlay == null)
                        this._onPlay = new Kiwi.Signal;
                    return this._onPlay;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Animation.prototype, "onUpdate", {
                /**
                * A Kiwi.Signal that dispatches an event when the animation has updated/changed frameIndexs.
                * @property onUpdate
                * @type Kiwi.Signal
                * @public
                */
                get: function () {
                    if (this._onUpdate == null)
                        this._onUpdate = new Kiwi.Signal;
                    return this._onUpdate;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Animation.prototype, "onLoop", {
                /**
                * A Kiwi.Signal that dispatches an event when the animation has come to the end of the animation and is going to play again.
                * @property onLoop
                * @type Kiwi.Signal
                * @public
                */
                get: function () {
                    if (this._onLoop == null)
                        this._onLoop = new Kiwi.Signal;
                    return this._onLoop;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Animation.prototype, "onComplete", {
                /**
                * A Kiwi.Signal that dispatches an event when the animation has come to
                * the end of the animation but is not going to play again.
                * @property onComplete
                * @type Kiwi.Signal
                * @public
                * @since 1.2.0
                */
                get: function () {
                    if (this._onComplete == null)
                        this._onComplete = new Kiwi.Signal;
                    return this._onComplete;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Start the animation.
            * @method _start
            * @param [index=null] {number} Index of the frame in the sequence that
            *	is to play. If left as null it just starts from where it left off.
            * @private
            */
            Animation.prototype._start = function (index) {
                if (index === void 0) { index = null; }
                if (index !== null) {
                    this.frameIndex = index;
                }
                // If the animation is out of range then start it at the beginning
                if (this.frameIndex >= this.length - 1 || this.frameIndex < 0) {
                    this.frameIndex = 0;
                }
                this._isPlaying = true;
                this._startTime = this.clock.elapsed();
                this._lastFrameElapsed = this.clock.elapsed();
                if (this._onPlay !== null) {
                    this._onPlay.dispatch();
                }
            };
            /**
            * Plays the animation.
            * @method play
            * @public
            */
            Animation.prototype.play = function () {
                this.playAt(this._frameIndex);
            };
            /**
            * Plays the animation at a particular frame.
            * @method playAt
            * @param index {number} Index of the cell in the sequence that the
            *	animation is to start at.
            * @public
            */
            Animation.prototype.playAt = function (index) {
                this._start(index);
            };
            /**
            * Pauses the current animation.
            * @method pause
            * @public
            */
            Animation.prototype.pause = function () {
                this.stop();
            };
            /**
            * Resumes the current animation after stopping.
            * @method resume
            * @public
            */
            Animation.prototype.resume = function () {
                if (this._startTime !== null) {
                    this._isPlaying = true;
                }
            };
            /**
            * Stops the current animation from playing.
            * @method stop
            * @public
            */
            Animation.prototype.stop = function () {
                if (this._isPlaying) {
                    this._isPlaying = false;
                    if (this._onStop !== null)
                        this._onStop.dispatch();
                }
            };
            /**
            * Makes the animation go to the next frame. If the animation is at the end it goes back to the start.
            * @method nextFrame
            * @public
            */
            Animation.prototype.nextFrame = function () {
                this._frameIndex++;
                if (this._frameIndex >= this.length)
                    this.frameIndex = 0;
            };
            /**
            * Makes the animation go to the previous frame. If the animation is at the first frame it goes to the end.
            * @method prevFrame
            * @public
            */
            Animation.prototype.prevFrame = function () {
                this._frameIndex--;
                if (this._frameIndex < 0)
                    this.frameIndex = this.length - 1;
            };
            /**
            * The update loop.
            *
            * @method update
            * @public
            */
            Animation.prototype.update = function () {
                var frameDelta, i, repeats;
                if (this._isPlaying) {
                    // How many frames do we move, ahead or behind?
                    frameDelta = ((this.clock.elapsed() -
                        this._lastFrameElapsed) / this._speed) % (this.length + 1);
                    if (this._reverse) {
                        frameDelta *= -1;
                    }
                    // Round delta, towards zero
                    if (frameDelta > 0) {
                        frameDelta = Math.floor(frameDelta);
                    }
                    else {
                        frameDelta = Math.ceil(frameDelta);
                    }
                    if (frameDelta !== 0) {
                        this._frameIndex += frameDelta;
                        this._lastFrameElapsed = this.clock.elapsed();
                        // Loop check
                        if (this._loop) {
                            if (this._frameIndex >= this.length) {
                                repeats = Math.floor(this._frameIndex / this.length);
                                this._frameIndex = this._frameIndex % this.length;
                                if (this._onLoop != null) {
                                    for (i = 0; i < repeats; i++) {
                                        this._onLoop.dispatch();
                                    }
                                }
                            }
                            else if (this._frameIndex < 0) {
                                repeats = Math.ceil(Math.abs(this._frameIndex) / this.length);
                                this._frameIndex = (this.length +
                                    this._frameIndex % this.length) % this.length;
                                if (this._onLoop != null) {
                                    for (i = 0; i < repeats; i++) {
                                        this._onLoop.dispatch();
                                    }
                                }
                            }
                        }
                        else if (this._frameIndex < 0) {
                            this._frameIndex = (this.length +
                                this._frameIndex % this.length) % this.length;
                            // Execute the stop on the parent 
                            // to allow the isPlaying boolean to remain consistent
                            this._parent.stop();
                            return;
                        }
                        else if (this._frameIndex >= this.length) {
                            this._frameIndex = this._frameIndex % this.length;
                            // Execute the stop on the parent 
                            // to allow the isPlaying boolean to remain consistent
                            this._parent.stop();
                            if (this._onComplete != null) {
                                this._onComplete.dispatch();
                            }
                            return;
                        }
                        this._parent.updateCellIndex();
                        if (this._onUpdate !== null) {
                            this._onUpdate.dispatch();
                        }
                    }
                }
            };
            /**
            * An internal method used to check to see if frame passed is valid or not
            * @method _validateFrame
            * @param frame {Number} The index of the frame that is to be validated.
            * @private
            */
            Animation.prototype._validateFrame = function (frame) {
                return (frame < this.length && frame >= 0);
            };
            Object.defineProperty(Animation.prototype, "length", {
                /**
                * Returns the number of frames that in the animation. Thus the animations 'length'. Note this is READ ONLY.
                * @property length
                * @type number
                * @public
                */
                get: function () {
                    return this._sequence.cells.length;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Destroys the anim and all of the properties that exist on it.
            * @method destroy
            * @public
            */
            Animation.prototype.destroy = function () {
                this._isPlaying = false;
                delete this._clock;
                delete this._sequence;
                delete this._parent;
                if (this._onLoop)
                    this._onLoop.dispose();
                if (this._onStop)
                    this._onStop.dispose();
                if (this._onPlay)
                    this._onPlay.dispose();
                if (this._onUpdate)
                    this._onUpdate.dispose();
                delete this._onLoop;
                delete this._onStop;
                delete this._onPlay;
                delete this._onUpdate;
                delete this.frameIndex;
                delete this.loop;
                delete this._reverse;
                delete this._tick;
            };
            return Animation;
        })();
        Animations.Animation = Animation;
    })(Animations = Kiwi.Animations || (Kiwi.Animations = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Animations
*
*/
var Kiwi;
(function (Kiwi) {
    var Animations;
    (function (Animations) {
        /**
        * A Sequence is a series of cells that are held on a SpriteSheet/TextureAtlas.
        * Sequences are generally used with the AnimationManager/Animation sections as a way to initially create Animations on GameObjects that use the same TextureAtlas.
        *
        * @class Sequence
        * @namespace Kiwi.Animations
        * @constructor
        * @param name {String} The name of this sequence. This is not unique.
        * @param cells {Number[]} The cells that are in this animation.
        * @param [speed=0.1] {Number} The time an animation should spend on each frame.
        * @param [loop=true] {boolean} If the sequence should play again if it was animating and the animation reaches the last frame.
        * @return {Kiwi.Animations.Sequence}
        *
        */
        var Sequence = (function () {
            function Sequence(name, cells, speed, loop) {
                if (speed === void 0) { speed = 0.1; }
                if (loop === void 0) { loop = true; }
                this.name = name;
                this.cells = cells;
                this.speed = speed;
                this.loop = loop;
            }
            return Sequence;
        })();
        Animations.Sequence = Sequence;
    })(Animations = Kiwi.Animations || (Kiwi.Animations = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Input
*
*/
var Kiwi;
(function (Kiwi) {
    var Input;
    (function (Input) {
        /**
        * A compact object that holds the most important details about a Keyboard Event response.
        *
        * @class Key
        * @constructor
        * @namespace Kiwi.Input
        * @param manager {Kiwi.Input.Keyboard} The keyboard manager that this key belongs to.
        * @param keycode {Number} The keycode that this key is.
        * @param [event] {KeyboardEvent} The keyboard event (if there was one) when this was created.
        * @return {Kiwi.Input.Key} This object.
        *
        */
        var Key = (function () {
            function Key(manager, keycode, event) {
                /**
                * If the default action for this Key should be prevented or not.
                * For example. If your game use's the spacebar you would want its default action (which is to make the website scrolldown) prevented,
                * So you can set this to true.
                * @property preventDefault
                * @type Boolean
                * @default false
                * @public
                */
                this.preventDefault = false;
                /**
                * Indicated whether or not the key is currently down.
                * @property isDown
                * @type boolean
                * @default false
                * @public
                */
                this.isDown = false;
                /**
                * Indicates whether or not the key is currently up.
                * @property isUp
                * @type boolean
                * @default true
                * @public
                */
                this.isUp = true;
                /**
                * If the alt key was held at the time of the event happening.
                * @property altKey
                * @type boolean
                * @default false
                * @public
                */
                this.altKey = false;
                /**
                * If the ctrl key was held at the time of the event happening.
                * @property ctrlKey
                * @type boolean
                * @default false
                * @public
                */
                this.ctrlKey = false;
                /**
                * If the shift key was held at the time of the event happening.
                * @property shiftKey
                * @type boolean
                * @default false
                * @public
                */
                this.shiftKey = false;
                /**
                * The time that the key was pressed initially.
                * @property timeDown
                * @type Number
                * @default 0
                * @public
                */
                this.timeDown = 0;
                /**
                * The time at which the key was released.
                * @property timeUp
                * @type Number
                * @default 0
                * @public
                */
                this.timeUp = 0;
                /**
                * If this key is being 'held' down, this property will indicate the amount of times the 'onkeydown' event has fired.
                * This is reset each time the key is pressed.
                * @property repeats
                * @type Number
                * @default 0
                * @public
                */
                this.repeats = 0;
                this._manager = manager;
                this.game = this._manager.game;
                this.keyCode = keycode;
                if (event) {
                    this.update(event);
                }
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String} "Key"
            * @public
            */
            Key.prototype.objType = function () {
                return "Key";
            };
            Object.defineProperty(Key.prototype, "duration", {
                /**
                * The duration (in milliseconds) that the key has been down for.
                * This is property is READ ONLY.
                * @property duration
                * @type Number
                * @default 0
                * @public
                */
                get: function () {
                    //If the key is down when the dev is getting the duration, then update the duration.
                    if (this.isDown) {
                        this.timeDown = this.game.time.now();
                    }
                    return (this.timeDown < this.timeUp) ? 0 : this.timeDown - this.timeUp;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * The 'update' method fires when an event occur's. Updates the keys properties
            * @method update
            * @param event {KeyboardEvent}
            * @public
            */
            Key.prototype.update = function (event) {
                this.keyCode = event.keyCode;
                //Are we needing to prevent the default action?
                if (this.preventDefault)
                    event.preventDefault();
                if (event.type === 'keydown') {
                    this.altKey = event.altKey;
                    this.ctrlKey = event.ctrlKey;
                    this.shiftKey = event.shiftKey;
                    if (this.isDown === true) {
                        // Key was already held down, this must be a repeat rate based event
                        this.repeats++;
                        this.timeDown = this.game.time.now();
                    }
                    else {
                        this.isDown = true;
                        this.isUp = false;
                        this.timeDown = this.game.time.now();
                        this.repeats = 0;
                    }
                }
                else if (event.type === 'keyup') {
                    this.isDown = false;
                    this.isUp = true;
                    this.timeUp = this.game.time.now();
                }
            };
            /**
            * Returns a boolean indicating whether or not this key was just pressed.
            * @method justPressed
            * @param [duration] {Number} The duration at which determines if a key was just pressed. Defaults to the managers just pressed rate.
            * @return {boolean}
            * @public
            */
            Key.prototype.justPressed = function (duration) {
                if (duration === void 0) { duration = this._manager.justPressedRate; }
                if (this.isDown === true && (this.timeDown + duration) > this.game.time.now()) {
                    return true;
                }
                else {
                    return false;
                }
            };
            /**
            * Returns a boolean indicating whether or not this key was just released.
            * @method justReleased
            * @param [duration] {Number} The duration at which determines if a key was just released. Defaults to the managers just pressed rate.
            * @return {boolean}
            * @public
            */
            Key.prototype.justReleased = function (duration) {
                if (duration === void 0) { duration = this._manager.justReleasedRate; }
                if (this.isUp === true && (this.timeUp + duration) > this.game.time.now()) {
                    return true;
                }
                else {
                    return false;
                }
            };
            /**
            * Resets all of the properties on the Key to their default values.
            * @method reset
            * @public
            */
            Key.prototype.reset = function () {
                this.isDown = false;
                this.isUp = true;
                this.timeUp = 0;
                this.timeDown = 0;
                this.repeats = 0;
                this.altKey = false;
                this.shiftKey = false;
                this.ctrlKey = false;
            };
            return Key;
        })();
        Input.Key = Key;
    })(Input = Kiwi.Input || (Kiwi.Input = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Input
*
*/
var Kiwi;
(function (Kiwi) {
    var Input;
    (function (Input) {
        /**
        * Handles and manages the dispatching of keyboard events.
        * When the user presses a button a new `Key` object is created.
        *
        * @class Keyboard
        * @constructor
        * @namespace Kiwi.Input
        * @param game {Kiwi.Game}
        * @return {Kiwi.Input.Keyboard} This object
        */
        var Keyboard = (function () {
            function Keyboard(game) {
                /**
                * Contains a reference to each `Key` object when they are either
                * added to this `Keyboard` manager (by the developer),
                * or when an event fires with that keycode.
                * @property _keys
                * @type Key[]
                * @private
                */
                this._keys = [];
                /**
                * The time in milliseconds which determines if a key was just pressed
                * or not.
                * @property justPressedRate
                * @type Number
                * @default 200
                * @public
                */
                this.justPressedRate = 200;
                /**
                * The time in milliseconds which determines if a key was just released
                * or not.
                * @property justReleasedRate
                * @type Number
                * @default 200
                * @public
                */
                this.justReleasedRate = 200;
                this.game = game;
            }
            /**
            * Type of object that this is
            * @method objType
            * @return {String} "Keyboard"
            * @public
            */
            Keyboard.prototype.objType = function () {
                return "Keyboard";
            };
            Object.defineProperty(Keyboard.prototype, "keys", {
                /**
                * Returns all of the `Key` objects that currently exist.
                * This is READ ONLY.
                * @property keys
                * @type Keys[]
                * @public
                */
                get: function () {
                    return this._keys;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Is executed when the DOMElements that are need to get the game going
            * are loaded and thus the game can 'boot'
            * @method boot
            * @public
            */
            Keyboard.prototype.boot = function () {
                this.onKeyUp = new Kiwi.Signal;
                this.onKeyDown = new Kiwi.Signal;
                this.onKeyDownOnce = new Kiwi.Signal;
                this.start();
            };
            /**
            * The update loop that is executed every frame.
            * @method update
            * @public
            */
            Keyboard.prototype.update = function () {
            };
            /**
            * Adds the event listeners to the browser to listen for key events.
            * @method start
            * @public
            */
            Keyboard.prototype.start = function () {
                var _this = this;
                if (this.game.deviceTargetOption === Kiwi.TARGET_BROWSER) {
                    //this._domElement.addEventListener('keydown', (event:KeyboardEvent) => this.onKeyDown(event), false);
                    //this._domElement.addEventListener('keyup', (event:KeyboardEvent) => this.onKeyUp(event), false);
                    document.body.addEventListener('keydown', function (event) { return _this._keyPressed(event); }, false);
                    document.body.addEventListener('keyup', function (event) { return _this._keyReleased(event); }, false);
                }
            };
            /**
            * Removes the event listeners and so effectively stops
            * all keyboard events.
            * @method stop
            * @public
            */
            Keyboard.prototype.stop = function () {
                var _this = this;
                if (this.game.deviceTargetOption === Kiwi.TARGET_BROWSER) {
                    //this._domElement.removeEventListener('keydown', (event:KeyboardEvent) => this.onKeyDown(event), false);
                    //this._domElement.removeEventListener('keyup', (event:KeyboardEvent) => this.onKeyUp(event), false);
                    document.body.removeEventListener('keydown', function (event) { return _this._keyPressed(event); }, false);
                    document.body.removeEventListener('keyup', function (event) { return _this._keyReleased(event); }, false);
                }
            };
            /**
            * Is executed when a key is pressed/is down. This then either creates
            * a new `Key` (if one does not currently exist) for that keycode,
            * or it updates the key that was pressed (if one does exist).
            * @method _keyPressed
            * @param {KeyboardEvent} event.
            * @private
            */
            Keyboard.prototype._keyPressed = function (event) {
                if (this._keys[event.keyCode]) {
                    this._keys[event.keyCode].update(event);
                }
                else {
                    this._keys[event.keyCode] = new Kiwi.Input.Key(this, event.keyCode, event);
                }
                if (this._keys[event.keyCode].repeats == 0)
                    this.onKeyDownOnce.dispatch(event.keyCode, this._keys[event.keyCode]);
                this.onKeyDown.dispatch(event.keyCode, this._keys[event.keyCode]);
            };
            /**
            * Is executed when a key is release/is now up. This then either
            * creates a new Key (if one does not currently exist) for that
            * keycode, or it updates the key that was released (if one does exist).
            * @method _keyReleased
            * @param {KeyboardEvent} event.
            * @private
            */
            Keyboard.prototype._keyReleased = function (event) {
                if (this._keys[event.keyCode]) {
                    this._keys[event.keyCode].update(event);
                }
                else {
                    this._keys[event.keyCode] = new Kiwi.Input.Key(this, event.keyCode, event);
                }
                this.onKeyUp.dispatch(event.keyCode, this._keys[event.keyCode]);
            };
            /**
            * Creates a new Key object for a keycode that is specified.
            * Not strictly needed (as one will be created once an event occurs
            * on that keycode) but can be good for setting the game up
            * and choosing whether to prevent default action on that key.
            *
            * @method addKey
            * @param keycode {Number} The keycode of the key that you want to add.
            * @param [preventDefault=false] {Boolean} If the default action for that key should be prevented or not when an event fires.
            * @return {Kiwi.Input.Key}
            * @public
            */
            Keyboard.prototype.addKey = function (keycode, preventDefault) {
                if (preventDefault === void 0) { preventDefault = false; }
                var key = new Kiwi.Input.Key(this, keycode);
                key.preventDefault = preventDefault;
                return this._keys[keycode] = key;
            };
            /**
            * Returns a boolean indicating if a key (that you pass via a keycode)
            * was just pressed or not.
            * @method justPressed
            * @param keycode {Number} The keycode of the key
            *	that you would like to check against.
            * @param [duration=this.justPressedRate] {Number} The duration
            *	which determines if a key was 'just' pressed or not.
            *	If not specified defaults to the `justPressedRate`
            * @public
            */
            Keyboard.prototype.justPressed = function (keycode, duration) {
                if (duration === void 0) { duration = this.justPressedRate; }
                if (this._keys[keycode]) {
                    return this._keys[keycode].justPressed(duration);
                }
                return false;
            };
            /**
            * Returns a boolean indicating if a key (that you pass via a keycode)
            * was just released or not.
            * @method justReleased
            * @param keycode {Number} The keycode of the key
            *	that you would like to check against.
            * @param [duration=this.justReleasedRate] {Number} The duration which
            *	determines if a key was 'just' released or not.
            *	If not specified defaults to the `justReleasedRate`
            * @public
            */
            Keyboard.prototype.justReleased = function (keycode, duration) {
                if (duration === void 0) { duration = this.justReleasedRate; }
                if (this._keys[keycode]) {
                    return this._keys[keycode].justReleased(duration);
                }
                return false;
            };
            /**
            * Returns a boolean indicating whether a key (that you pass via its
            * keycode) is down or not.
            * @method isDown
            * @param keycode {Number} The keycode of the key that you are checking.
            * @return {boolean}
            * @public
            */
            Keyboard.prototype.isDown = function (keycode) {
                if (this._keys[keycode]) {
                    return this._keys[keycode].isDown;
                }
                else {
                    return false;
                }
            };
            /**
            * Returns a boolean indicating whether a key (that you pass via its
            * keycode) is up or not.
            * @method isUp
            * @param keycode {Number} The keycode of the key that you are checking.
            * @return {boolean}
            * @public
            */
            Keyboard.prototype.isUp = function (keycode) {
                if (this._keys[keycode]) {
                    return this._keys[keycode].isUp;
                }
                else {
                    return false;
                }
            };
            /**
            * Executes the reset method on every Key that currently exists.
            * @method reset
            * @public
            */
            Keyboard.prototype.reset = function () {
                for (var index in this._keys) {
                    this._keys[index].reset();
                }
            };
            return Keyboard;
        })();
        Input.Keyboard = Keyboard;
    })(Input = Kiwi.Input || (Kiwi.Input = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Input
*
*/
var Kiwi;
(function (Kiwi) {
    var Input;
    (function (Input) {
        /**
        * A Static class which has a property associated with all all of the character codes on a typical keyboard. While you don't need this class for your game to work, it is quite handy to use as it can speed up the development process.
        *
        * @class Keycodes
        * @namespace Kiwi.Input
        * @static
        */
        var Keycodes = (function () {
            function Keycodes() {
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {string} "Keycodes"
            * @public
            */
            Keycodes.prototype.objType = function () {
                return "Keycodes";
            };
            /**
            * A Static property that holds the keycode for the character A
            * @property A
            * @static
            * @final
            * @public
            */
            Keycodes.A = "A".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character B
            * @property B
            * @static
            * @final
            * @public
            */
            Keycodes.B = "B".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character C
            * @property C
            * @static
            * @final
            * @public
            */
            Keycodes.C = "C".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character D
            * @property D
            * @static
            * @final
            * @public
            */
            Keycodes.D = "D".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character E
            * @property E
            * @static
            * @final
            * @public
            */
            Keycodes.E = "E".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character F
            * @property F
            * @static
            * @final
            * @public
            */
            Keycodes.F = "F".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character G
            * @property G
            * @static
            * @final
            * @public
            */
            Keycodes.G = "G".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character H
            * @property H
            * @static
            * @final
            * @public
            */
            Keycodes.H = "H".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character I
            * @property I
            * @static
            * @final
            * @public
            */
            Keycodes.I = "I".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character J
            * @property J
            * @static
            * @final
            * @public
            */
            Keycodes.J = "J".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character K
            * @property K
            * @static
            * @final
            * @public
            */
            Keycodes.K = "K".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character L
            * @property L
            * @static
            * @final
            * @public
            */
            Keycodes.L = "L".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character M
            * @property M
            * @static
            * @final
            * @public
            */
            Keycodes.M = "M".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character N
            * @property N
            * @static
            * @final
            * @public
            */
            Keycodes.N = "N".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character O
            * @property O
            * @static
            * @final
            * @public
            */
            Keycodes.O = "O".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character P
            * @property P
            * @static
            * @final
            * @public
            */
            Keycodes.P = "P".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character Q
            * @property Q
            * @static
            * @final
            * @public
            */
            Keycodes.Q = "Q".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character R
            * @property R
            * @static
            * @final
            * @public
            */
            Keycodes.R = "R".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character S
            * @property S
            * @static
            * @final
            * @public
            */
            Keycodes.S = "S".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character T
            * @property T
            * @static
            * @final
            * @public
            */
            Keycodes.T = "T".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character U
            * @property U
            * @static
            * @final
            * @public
            */
            Keycodes.U = "U".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character V
            * @property V
            * @static
            * @final
            * @public
            */
            Keycodes.V = "V".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character W
            * @property W
            * @static
            * @final
            * @public
            */
            Keycodes.W = "W".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character X
            * @property X
            * @static
            * @final
            * @public
            */
            Keycodes.X = "X".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character Y
            * @property Y
            * @static
            * @final
            * @public
            */
            Keycodes.Y = "Y".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character Z
            * @property Z
            * @static
            * @final
            * @public
            */
            Keycodes.Z = "Z".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character 0
            * @property ZERO
            * @static
            * @final
            * @public
            */
            Keycodes.ZERO = "0".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character 1
            * @property ONE
            * @static
            * @final
            * @public
            */
            Keycodes.ONE = "1".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character 2
            * @property TWO
            * @static
            * @final
            * @public
            */
            Keycodes.TWO = "2".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character 3
            * @property THREE
            * @static
            * @final
            * @public
            */
            Keycodes.THREE = "3".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character 4
            * @property FOUR
            * @static
            * @final
            * @public
            */
            Keycodes.FOUR = "4".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character 5
            * @property FIVE
            * @static
            * @final
            * @public
            */
            Keycodes.FIVE = "5".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character 6
            * @property SIX
            * @static
            * @final
            * @public
            */
            Keycodes.SIX = "6".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character 7
            * @property SEVEN
            * @static
            * @final
            * @public
            */
            Keycodes.SEVEN = "7".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character 8
            * @property EIGHT
            * @static
            * @final
            * @public
            */
            Keycodes.EIGHT = "8".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character 9
            * @property NINE
            * @static
            * @final
            * @public
            */
            Keycodes.NINE = "9".charCodeAt(0);
            /**
            * A Static property that holds the keycode for the character number pad 0
            * @property NUMPAD_0
            * @static
            * @final
            * @public
            */
            Keycodes.NUMPAD_0 = 96;
            /**
            * A Static property that holds the keycode for the character number pad 1
            * @property NUMPAD_1
            * @static
            * @final
            * @public
            */
            Keycodes.NUMPAD_1 = 97;
            /**
            * A Static property that holds the keycode for the character number pad 2
            * @property NUMPAD_2
            * @static
            * @final
            * @public
            */
            Keycodes.NUMPAD_2 = 98;
            /**
            * A Static property that holds the keycode for the character number pad 3
            * @property NUMPAD_3
            * @static
            * @final
            * @public
            */
            Keycodes.NUMPAD_3 = 99;
            /**
            * A Static property that holds the keycode for the character number pad 4
            * @property NUMPAD_4
            * @static
            * @final
            * @public
            */
            Keycodes.NUMPAD_4 = 100;
            /**
            * A Static property that holds the keycode for the character number pad 5
            * @property NUMPAD_5
            * @static
            * @final
            * @public
            */
            Keycodes.NUMPAD_5 = 101;
            /**
            * A Static property that holds the keycode for the character number pad 6
            * @property NUMPAD_6
            * @static
            * @final
            * @public
            */
            Keycodes.NUMPAD_6 = 102;
            /**
            * A Static property that holds the keycode for the character number pad 7
            * @property NUMPAD_7
            * @static
            * @final
            * @public
            */
            Keycodes.NUMPAD_7 = 103;
            /**
            * A Static property that holds the keycode for the character number pad 8
            * @property NUMPAD_8
            * @static
            * @final
            * @public
            */
            Keycodes.NUMPAD_8 = 104;
            /**
            * A Static property that holds the keycode for the character number pad 9
            * @property NUMPAD_9
            * @static
            * @final
            * @public
            */
            Keycodes.NUMPAD_9 = 105;
            /**
            * A Static property that holds the keycode for the character number pad *
            * @property NUMPAD_MULTIPLY
            * @static
            * @final
            * @public
            */
            Keycodes.NUMPAD_MULTIPLY = 106;
            /**
            * A Static property that holds the keycode for the character number pad +
            * @property NUMPAD_ADD
            * @static
            * @final
            * @public
            */
            Keycodes.NUMPAD_ADD = 107;
            /**
            * A Static property that holds the keycode for the character on the number pad enter
            * @property NUMPAD_ENTER
            * @static
            * @final
            * @public
            */
            Keycodes.NUMPAD_ENTER = 108;
            /**
            * A Static property that holds the keycode for the character number pad -
            * @property NUMPAD_SUBTRACT
            * @static
            * @final
            * @public
            */
            Keycodes.NUMPAD_SUBTRACT = 109;
            /**
            * A Static property that holds the keycode for the character number pad .
            * @property NUMPAD_DECIMAL
            * @static
            * @final
            * @public
            */
            Keycodes.NUMPAD_DECIMAL = 110;
            /**
            * A Static property that holds the keycode for the character /
            * @property NUMPAD_DIVIDE
            * @static
            * @final
            * @public
            */
            Keycodes.NUMPAD_DIVIDE = 111;
            /**
            * A Static property that holds the keycode for the character F1
            * @property F1
            * @static
            * @final
            * @public
            */
            Keycodes.F1 = 112;
            /**
            * A Static property that holds the keycode for the character F2
            * @property F2
            * @static
            * @final
            * @public
            */
            Keycodes.F2 = 113;
            /**
            * A Static property that holds the keycode for the character F3
            * @property F3
            * @static
            * @final
            * @public
            */
            Keycodes.F3 = 114;
            /**
            * A Static property that holds the keycode for the character F4
            * @property F4
            * @static
            * @final
            * @public
            */
            Keycodes.F4 = 115;
            /**
            * A Static property that holds the keycode for the character F5
            * @property F5
            * @static
            * @final
            * @public
            */
            Keycodes.F5 = 116;
            /**
            * A Static property that holds the keycode for the character F6
            * @property F6
            * @static
            * @final
            * @public
            */
            Keycodes.F6 = 117;
            /**
            * A Static property that holds the keycode for the character F7
            * @property F7
            * @static
            * @final
            * @public
            */
            Keycodes.F7 = 118;
            /**
            * A Static property that holds the keycode for the character F8
            * @property F8
            * @static
            * @final
            * @public
            */
            Keycodes.F8 = 119;
            /**
            * A Static property that holds the keycode for the character F9
            * @property F9
            * @static
            * @final
            * @public
            */
            Keycodes.F9 = 120;
            /**
            * A Static property that holds the keycode for the character F10
            * @property F10
            * @static
            * @final
            * @public
            */
            Keycodes.F10 = 121;
            /**
            * A Static property that holds the keycode for the character F11
            * @property F11
            * @static
            * @final
            * @public
            */
            Keycodes.F11 = 122;
            /**
            * A Static property that holds the keycode for the character F12
            * @property F12
            * @static
            * @final
            * @public
            */
            Keycodes.F12 = 123;
            /**
            * A Static property that holds the keycode for the character F13
            * @property F13
            * @static
            * @final
            * @public
            */
            Keycodes.F13 = 124;
            /**
            * A Static property that holds the keycode for the character F14
            * @property F14
            * @static
            * @final
            * @public
            */
            Keycodes.F14 = 125;
            /**
            * A Static property that holds the keycode for the character F15
            * @property F15
            * @static
            * @final
            * @public
            */
            Keycodes.F15 = 126;
            /**
            * A Static property that holds the keycode for the character COLON
            * @property COLON
            * @static
            * @final
            * @public
            */
            Keycodes.COLON = 186;
            /**
            * A Static property that holds the keycode for the character =
            * @property EQUALS
            * @static
            * @final
            * @public
            */
            Keycodes.EQUALS = 187;
            /**
            * A Static property that holds the keycode for the character UNDERSCORE
            * @property UNDERSCORE
            * @static
            * @final
            * @public
            */
            Keycodes.UNDERSCORE = 189;
            /**
            * A Static property that holds the keycode for the character QUESTION_MARK
            * @property QUESTION_MARK
            * @static
            * @final
            * @public
            */
            Keycodes.QUESTION_MARK = 191;
            /**
            * A Static property that holds the keycode for the character TILDE
            * @property TILDE
            * @static
            * @final
            * @public
            */
            Keycodes.TILDE = 192;
            /**
            * A Static property that holds the keycode for the character OPEN_BRAKET
            * @property OPEN_BRACKET
            * @static
            * @final
            * @public
            */
            Keycodes.OPEN_BRACKET = 219;
            /**
            * A Static property that holds the keycode for the character BACKWARD_SLASH
            * @property BACKWARD_SLASH
            * @static
            * @final
            * @public
            */
            Keycodes.BACKWARD_SLASH = 220;
            /**
            * A Static property that holds the keycode for the character CLOSED_BRACKET
            * @property CLOSED_BRACKET
            * @static
            * @final
            * @public
            */
            Keycodes.CLOSED_BRACKET = 221;
            /**
            * A Static property that holds the keycode for the character QUOTES
            * @property QUOTES
            * @static
            * @final
            * @public
            */
            Keycodes.QUOTES = 222;
            /**
            * A Static property that holds the keycode for the character BACKSPACE
            * @property BACKSPACE
            * @static
            * @final
            * @public
            */
            Keycodes.BACKSPACE = 8;
            /**
            * A Static property that holds the keycode for the character TAB
            * @property TAB
            * @static
            * @final
            * @public
            */
            Keycodes.TAB = 9;
            /**
            * A Static property that holds the keycode for the character CLEAR
            * @property CLEAR
            * @static
            * @final
            * @public
            */
            Keycodes.CLEAR = 12;
            /**
            * A Static property that holds the keycode for the character ENTER
            * @property ENTER
            * @static
            * @final
            * @public
            */
            Keycodes.ENTER = 13;
            /**
            * A Static property that holds the keycode for the character SHIFT
            * @property SHIFT
            * @static
            * @final
            * @public
            */
            Keycodes.SHIFT = 16;
            /**
            * A Static property that holds the keycode for the character CONTROL
            * @property CONTROL
            * @static
            * @final
            * @public
            */
            Keycodes.CONTROL = 17;
            /**
            * A Static property that holds the keycode for the character ALT
            * @property ALT
            * @static
            * @final
            * @public
            */
            Keycodes.ALT = 18;
            /**
            * A Static property that holds the keycode for the character CAPS_LOCK
            * @property CAPS_LOCK
            * @static
            * @final
            * @public
            */
            Keycodes.CAPS_LOCK = 20;
            /**
            * A Static property that holds the keycode for the character ESC
            * @property ESC
            * @static
            * @final
            * @public
            */
            Keycodes.ESC = 27;
            /**
            * A Static property that holds the keycode for the character SPACEBAR
            * @property SPACEBAR
            * @static
            * @final
            * @public
            */
            Keycodes.SPACEBAR = 32;
            /**
            * A Static property that holds the keycode for the character PAGE_UP
            * @property PAGE_UP
            * @static
            * @final
            * @public
            */
            Keycodes.PAGE_UP = 33;
            /**
            * A Static property that holds the keycode for the character PAGE_DOWN
            * @property PAGE_DOWN
            * @static
            * @final
            * @public
            */
            Keycodes.PAGE_DOWN = 34;
            /**
            * A Static property that holds the keycode for the character END
            * @property END
            * @static
            * @final
            * @public
            */
            Keycodes.END = 35;
            /**
            * A Static property that holds the keycode for the character HOME
            * @property HOME
            * @static
            * @final
            * @public
            */
            Keycodes.HOME = 36;
            /**
            * A Static property that holds the keycode for the character LEFT
            * @property LEFT
            * @static
            * @final
            * @public
            */
            Keycodes.LEFT = 37;
            /**
            * A Static property that holds the keycode for the character UP
            * @property UP
            * @static
            * @final
            * @public
            */
            Keycodes.UP = 38;
            /**
            * A Static property that holds the keycode for the character RIGHT
            * @property RIGHT
            * @static
            * @final
            * @public
            */
            Keycodes.RIGHT = 39;
            /**
            * A Static property that holds the keycode for the character DOWN
            * @property DOWN
            * @static
            * @final
            * @public
            */
            Keycodes.DOWN = 40;
            /**
            * A Static property that holds the keycode for the character INSERT
            * @property INSERT
            * @static
            * @final
            * @public
            */
            Keycodes.INSERT = 45;
            /**
            * A Static property that holds the keycode for the character DELETE
            * @property DELETE
            * @static
            * @final
            * @public
            */
            Keycodes.DELETE = 46;
            /**
            * A Static property that holds the keycode for the character HELP
            * @property HELP
            * @static
            * @final
            * @public
            */
            Keycodes.HELP = 47;
            /**
            * A Static property that holds the keycode for the character NUM_LOCK
            * @property NUM_LOCK
            * @static
            * @final
            * @public
            */
            Keycodes.NUM_LOCK = 144;
            return Keycodes;
        })();
        Input.Keycodes = Keycodes;
    })(Input = Kiwi.Input || (Kiwi.Input = {}));
})(Kiwi || (Kiwi = {}));
/**
* Section that contains the code related to handling user interaction with a game.
*
* @module Kiwi
* @submodule Input
* @main Input
*/
var Kiwi;
(function (Kiwi) {
    var Input;
    (function (Input) {
        /**
        * Handles the initialization and management of the various ways a user can interact with the device/game,
        * whether this is through a Keyboard and Mouse or by a Touch. Also contains some of the general callbacks that are 'global' between both Desktop and Mobile based devices.
        *
        * @class InputManager
        * @constructor
        * @namespace Kiwi.Input
        * @param game {Kiwi.Game} The game that this object belongs to.
        * @return {Kiwi.Input.InputManager} This object.
        *
        */
        var InputManager = (function () {
            function InputManager(game) {
                this.game = game;
            }
            /**
            * The type of object this is.
            * @method objType
            * @return {String} "InputManager"
            * @public
            */
            InputManager.prototype.objType = function () {
                return "InputManager";
            };
            Object.defineProperty(InputManager.prototype, "pointers", {
                /**
                * Returns all of the pointers that can be used on the Input Manager. This is READ only.
                * @property pointers
                * @type Array
                * @public
                */
                get: function () {
                    return this._pointers;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * This method is executed when the DOM has loaded and the manager is ready to load.
            * @method boot
            * @public
            */
            InputManager.prototype.boot = function () {
                this._pointers = [];
                this.mouse = new Kiwi.Input.Mouse(this.game);
                this.mouse.boot();
                this.keyboard = new Kiwi.Input.Keyboard(this.game);
                this.keyboard.boot();
                this.touch = new Kiwi.Input.Touch(this.game);
                this.touch.boot();
                this.mouse.onDown.add(this._onDownEvent, this);
                this.mouse.onUp.add(this._onUpEvent, this);
                this.touch.touchDown.add(this._onDownEvent, this);
                this.touch.touchUp.add(this._onUpEvent, this);
                /*
                * Add the fingers/cursors to the list of 'pointers'
                */
                this._pointers = this.touch.fingers.slice();
                this._pointers.push(this.mouse.cursor);
                this.isDown = false;
                this.position = new Kiwi.Geom.Point();
                this.onDown = new Kiwi.Signal();
                this.onUp = new Kiwi.Signal();
            };
            /**
            * A private method that gets dispatched when either the mouse or touch manager dispatches a down event
            * @method _onDownEvent
            * @param x {Number} The x coordinate of the pointer
            * @param y {Number} The y coordinate of the pointer
            * @param timeDown {Number} The time that the pointer has been down for.
            * @param timeUp {Number} The Time that the pointer has been up form
            * @param duration {Number}
            * @param pointer {Kiwi.Input.Pointer} The pointer that was used.
            * @private
            */
            InputManager.prototype._onDownEvent = function (x, y, timeDown, timeUp, duration, pointer) {
                this.onDown.dispatch(x, y, timeDown, timeUp, duration, pointer);
            };
            /**
            * A private method that gets dispatched when either the mouse or touch manager dispatches a up event
            * @method _onUpEvent
            * @param x {Number} The x coordinate of the pointer
            * @param y {Number} The y coordinate of the pointer
            * @param timeDown {Number} The time that the pointer has been down for.
            * @param timeUp {Number} The Time that the pointer has been up form
            * @param duration {Number}
            * @param pointer {Kiwi.Input.Pointer} The pointer that was used.
            * @private
            */
            InputManager.prototype._onUpEvent = function (x, y, timeDown, timeUp, duration, pointer) {
                this.onUp.dispatch(x, y, timeDown, timeUp, duration, pointer);
            };
            Object.defineProperty(InputManager.prototype, "onPressed", {
                /*
                * An alias for the onPress signal that goes straight to the onDown.
                * @property onPressed
                * @type Signal
                * @public
                */
                get: function () {
                    return this.onDown;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(InputManager.prototype, "onReleased", {
                /**
                * An alias for the onRelease signal that goes straight to the onUp
                * @property onReleased
                * @type Signal
                * @public
                */
                get: function () {
                    return this.onUp;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * The update loop that gets executed every frame.
            * @method update
            * @public
            */
            InputManager.prototype.update = function () {
                this.mouse.update();
                this.keyboard.update();
                this.touch.update();
                if (this.touch.touchEnabled) {
                    this.position.setTo(this.touch.x, this.touch.y);
                }
                else {
                    this.position.setTo(this.mouse.x, this.mouse.y);
                }
                this.isDown = this.mouse.isDown || this.touch.isDown;
            };
            /**
            * Runs the reset method on the managers.
            * @method reset
            */
            InputManager.prototype.reset = function () {
                this.mouse.reset();
                this.keyboard.reset();
                this.touch.reset();
            };
            Object.defineProperty(InputManager.prototype, "x", {
                /**
                * Populated x coordinate based on the most recent click/touch event
                * @property x
                * @type Number
                * @public
                */
                get: function () {
                    return this.position.x;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(InputManager.prototype, "y", {
                /**
                * Populated y coordinate based on the most recent click/touch event
                * @property y
                * @type Number
                * @public
                */
                get: function () {
                    return this.position.y;
                },
                enumerable: true,
                configurable: true
            });
            return InputManager;
        })();
        Input.InputManager = InputManager;
    })(Input = Kiwi.Input || (Kiwi.Input = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Input
*
*/
var Kiwi;
(function (Kiwi) {
    var Input;
    (function (Input) {
        /**
        * Handles the dispatching/management of Mouse Events on a game. When this class is instantiated a MouseCursor object is also created (on this object) which holds the information that is unique to the mouse cursor, although majority of that information is still accessible inside this object.
        *
        * @class Mouse
        * @constructor
        * @namespace Kiwi.Input
        * @param game {Kiwi.Game} The game that this mouse manager belongs to.
        * @return {Kiwi.Input.Mouse}
        *
        */
        var Mouse = (function () {
            function Mouse(game) {
                /**
                * The HTMLElement that is being used to apply the mouse events to.
                * @property _domElement
                * @type HTMLDivElement
                * @private
                */
                this._domElement = null;
                /**
                * Determines whether or not the context menu should appear
                * when the user 'right clicks' on the stage.
                *
                * Only has an effect on games targetting browsers.
                *
                * @property preventContextMenu
                * @type Boolean
                * @default false
                * @since 1.3.0
                * @public
                */
                this.preventContextMenu = false;
                this._game = game;
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String} "Mouse"
            * @public
            */
            Mouse.prototype.objType = function () {
                return "Mouse";
            };
            Object.defineProperty(Mouse.prototype, "cursor", {
                /**
                * Returns the MouseCursor that is being used on the stage. This is READ ONLY.
                * @property cursor
                * @type Kiwi.Input.MouseCursor
                * @private
                */
                get: function () {
                    return this._cursor;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * This method is executed when the DOM has finished loading and thus the MouseManager can start listening for events.
            * @method boot
            * @public
            */
            Mouse.prototype.boot = function () {
                this._domElement = this._game.stage.container;
                this._cursor = new Kiwi.Input.MouseCursor(this._game);
                this._cursor.active = true;
                this._cursor.id = 1;
                this.onDown = new Kiwi.Signal();
                this.onUp = new Kiwi.Signal();
                this.onWheel = new Kiwi.Signal();
                this.onContext = new Kiwi.Signal();
                this.start();
            };
            Object.defineProperty(Mouse.prototype, "isDown", {
                /**
                * Indicates whether or not the cursor is currently down. This is READ ONLY.
                * @property isDown
                * @type boolean
                * @default false
                * @public
                */
                get: function () {
                    return this._cursor.isDown;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Mouse.prototype, "isUp", {
                /**
                * Indicates whether or not the cursor is currently up. This is READ ONLY.
                * @property isUp
                * @type boolean
                * @default true
                * @public
                */
                get: function () {
                    return this._cursor.isUp;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Mouse.prototype, "duration", {
                /**
                * Gets the duration in Milliseconds that the mouse cursor has either been up or down for.
                * @property duration
                * @type number
                * @public
                */
                get: function () {
                    return this._cursor.duration;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Mouse.prototype, "x", {
                /**
                * Gets the x coordinate of the mouse cursor.
                * @property x
                * @type number
                * @public
                */
                get: function () {
                    return this._cursor.x;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Mouse.prototype, "y", {
                /**
                * Gets the y coordinate of the mouse cursor.
                * @property y
                * @type number
                * @public
                */
                get: function () {
                    return this._cursor.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Mouse.prototype, "wheelDeltaX", {
                /**
                * Gets the wheelDeltaX coordinate of the mouse cursors wheel.
                * @property wheelDeltaX
                * @type number
                * @public
                */
                get: function () {
                    return this._cursor.wheelDeltaX;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Mouse.prototype, "wheelDeltaY", {
                /**
                * Gets the wheelDeltaY coordinate of the mouse cursors wheel.
                * @property wheelDeltaY
                * @type number
                * @public
                */
                get: function () {
                    return this._cursor.wheelDeltaY;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Mouse.prototype, "ctrlKey", {
                /**
                * Indicates if the ctrl key is down.
                * @property ctrlKey
                * @type boolean
                * @default false
                * @public
                */
                get: function () {
                    return this._cursor.ctrlKey;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Mouse.prototype, "shiftKey", {
                /**
                * Indicates if the shift key is down.
                * @property shiftKey
                * @type boolean
                * @default false
                * @public
                */
                get: function () {
                    return this._cursor.shiftKey;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Mouse.prototype, "altKey", {
                /**
                * Indicates if the alt key is down.
                * @property altKey
                * @type boolean
                * @default false
                * @public
                */
                get: function () {
                    return this._cursor.altKey;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Mouse.prototype, "button", {
                /**
                * Returns a number indicating the button that was used. This can be used with the STATIC button properties.
                * @property button
                * @type number
                * @public
                */
                get: function () {
                    return this._cursor.button;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * The update loop for the cursor.
            * @method update
            * @public
            */
            Mouse.prototype.update = function () {
                this._cursor.update();
            };
            /**
            * Start the mouse event listeners on the game. Automatically called by the boot.
            * @method start
            * @public
            */
            Mouse.prototype.start = function () {
                this._onMouseDownBind = this.onMouseDown.bind(this);
                this._onMouseMoveBind = this.onMouseMove.bind(this);
                this._onMouseUpBind = this.onMouseUp.bind(this);
                this._onMouseWheelBind = this.onMouseWheel.bind(this);
                this._onContextMenuBind = this.onContextMenu.bind(this);
                if (this._game.deviceTargetOption === Kiwi.TARGET_BROWSER) {
                    this._domElement.addEventListener('mousedown', this._onMouseDownBind, true);
                    this._domElement.addEventListener('mousemove', this._onMouseMoveBind, true);
                    this._domElement.addEventListener('mouseup', this._onMouseUpBind, true);
                    this._domElement.addEventListener('mousewheel', this._onMouseWheelBind, true);
                    this._domElement.addEventListener('DOMMouseScroll', this._onMouseWheelBind, true);
                    this._domElement.addEventListener('contextmenu', this._onContextMenuBind, true);
                }
                else if (this._game.deviceTargetOption === Kiwi.TARGET_COCOON) {
                    this._game.stage.canvas.addEventListener('mousedown', this._onMouseDownBind, true);
                    this._game.stage.canvas.addEventListener('mousemove', this._onMouseMoveBind, true);
                    this._game.stage.canvas.addEventListener('mouseup', this._onMouseUpBind, true);
                    this._game.stage.canvas.addEventListener('mousewheel', this._onMouseWheelBind, true);
                    this._game.stage.canvas.addEventListener('DOMMouseScroll', this._onMouseWheelBind, true);
                }
            };
            /**
            * Stops the mouse event listeners from working. Useful if you no longer want the mouse to 'work'/be listened to.
            * @method stop
            * @public
            */
            Mouse.prototype.stop = function () {
                if (this._game.deviceTargetOption === Kiwi.TARGET_BROWSER) {
                    this._domElement.removeEventListener('mousedown', this._onMouseDownBind, true);
                    this._domElement.removeEventListener('mousemove', this._onMouseMoveBind, true);
                    this._domElement.removeEventListener('mouseup', this._onMouseUpBind, true);
                    this._domElement.removeEventListener('mousewheel', this._onMouseWheelBind, true);
                    this._domElement.removeEventListener('DOMMouseScroll', this._onMouseWheelBind, true);
                    this._domElement.removeEventListener('contextmenu', this._onContextMenuBind, true);
                }
                else if (this._game.deviceTargetOption === Kiwi.TARGET_COCOON) {
                    this._game.stage.canvas.removeEventListener('mousedown', this._onMouseDownBind, true);
                    this._game.stage.canvas.removeEventListener('mousemove', this._onMouseMoveBind, true);
                    this._game.stage.canvas.removeEventListener('mouseup', this._onMouseUpBind, true);
                    this._game.stage.canvas.removeEventListener('mousewheel', this._onMouseWheelBind, true);
                    this._game.stage.canvas.removeEventListener('DOMMouseScroll', this._onMouseWheelBind, true);
                }
                delete this._onMouseDownBind;
                delete this._onMouseMoveBind;
                delete this._onMouseUpBind;
                delete this._onMouseWheelBind;
                delete this._onContextMenuBind;
            };
            /**
            * Method that gets fired when the mouse is pressed on the stage.
            * @method onMouseDown
            * @param {MouseEvent} event.
            * @private
            */
            Mouse.prototype.onMouseDown = function (event) {
                this._cursor.start(event);
                this.onDown.dispatch(this._cursor.x, this._cursor.y, this._cursor.timeDown, this._cursor.timeUp, this.duration, this._cursor);
            };
            /**
            * Method that gets fired when the mouse moves anywhere on the stage.
            * @method onMouseMove
            * @param {MouseEvent} event.
            * @private
            */
            Mouse.prototype.onMouseMove = function (event) {
                event.preventDefault();
                this._cursor.move(event);
            };
            /**
            * Method that gets fired when the mouse is released on the stage.
            * @method onMouseUp
            * @param {MouseEvent} event.
            * @private
            */
            Mouse.prototype.onMouseUp = function (event) {
                this._cursor.stop(event);
                this.onUp.dispatch(this._cursor.x, this._cursor.y, this._cursor.timeDown, this._cursor.timeUp, this.duration, this._cursor);
            };
            /**
            * Method that gets fired when the mousewheel is moved.
            * @method onMouseWheel
            * @param {MouseEvent} event.
            * @private
            */
            Mouse.prototype.onMouseWheel = function (event) {
                this._cursor.wheel(event);
                this.onWheel.dispatch(this._cursor.wheelDeltaX, this._cursor.wheelDeltaY, this._cursor);
            };
            /**
            * Returns a boolean indicating if the mouse was 'justPressed' within a certain timeframe. The default timeframe is 200 milliseconds.
            * @method justPressed
            * @param [duration=200] {Number} The timeframe that it could have occured in.
            * @return {boolean}
            * @public
            */
            Mouse.prototype.justPressed = function (duration) {
                if (duration === void 0) { duration = this._cursor.justPressedRate; }
                return this._cursor.justPressed(duration);
            };
            /**
            * Returns a boolean indicating if the mouse was 'justReleased' within a certain timeframe. The default timeframe is 200 milliseconds.
            * @method justReleased
            * @param [duration=200] {Number} The timeframe that it could have occured in..
            * @return {boolean}
            * @public
            */
            Mouse.prototype.justReleased = function (duration) {
                if (duration === void 0) { duration = this._cursor.justReleasedRate; }
                return this._cursor.justReleased(duration);
            };
            /**
            * Runs the Reset method on the MouseCursor.
            * @method reset
            * @public
            */
            Mouse.prototype.reset = function () {
                this._cursor.reset();
            };
            /**
            * Fired when the context menu event is fired.
            * Used to prevent the context menu from appearing when the
            * 'preventContextMenu' property is set to true.
            *
            * This event is currently only used when targetting browsers and will not fire for CocoonJS.
            *
            * @method onContextMenu
            * @param event
            * @since 1.3.0
            * @private
            */
            Mouse.prototype.onContextMenu = function (event) {
                if (this.preventContextMenu) {
                    event.preventDefault();
                }
                this.onContext.dispatch(event);
            };
            /**
            * The numeric value for the LEFT button.
            * @property LEFT_BUTTON
            * @type Number
            * @static
            * @public
            * @final
            * @default 0
            */
            Mouse.LEFT_BUTTON = 0;
            /**
            * The numeric value for the MIDDLE button.
            * @property MIDDLE_BUTTON
            * @type Number
            * @static
            * @public
            * @final
            * @default 1
            */
            Mouse.MIDDLE_BUTTON = 1;
            /**
            * The numeric value for the RIGHT button.
            * @property RIGHT_BUTTON
            * @type Number
            * @static
            * @public
            * @final
            * @default 2
            */
            Mouse.RIGHT_BUTTON = 2;
            return Mouse;
        })();
        Input.Mouse = Mouse;
    })(Input = Kiwi.Input || (Kiwi.Input = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Input
*
*/
var Kiwi;
(function (Kiwi) {
    var Input;
    (function (Input) {
        /**
        * Handles the dispatching and management of touch based events for the game. When the Touch manager is created TEN finger objects are created and used when the user interacts with the screen. Those finger are what you can use to create games that make the most out of multitouch events.
        *
        * @class Touch
        * @constructor
        * @namespace Kiwi.Input
        * @param game {Game} the game that this touch manager belongs to.
        * @return {Touch} This object.
        *
        */
        var Touch = (function () {
            function Touch(game) {
                /**
                * The dom element that these touch events are to take place on. This is usally set to be the stage/game container.
                * @property _domElement
                * @type HTMLElement
                * @default null
                * @private
                **/
                this._domElement = null;
                /**
                * A boolean that will roughly indicate if any finger is currently down.
                * @property isDown
                * @type boolean
                * @default false
                * @public
                */
                this.isDown = false;
                /**
                * If all the fingers are up.
                * @property isUp
                * @type boolean
                * @default true
                * @public
                */
                this.isUp = true;
                /**
                * The developer defined maximum number of touch events.
                * By default this is set to 10 but this can be set to be lower.
                * @property _maxPointers
                * @type number
                * @default 10
                * @private
                */
                this._maxPointers = 10;
                this._game = game;
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String} "TouchManager"
            * @public
            */
            Touch.prototype.objType = function () {
                return "TouchManager";
            };
            Object.defineProperty(Touch.prototype, "fingers", {
                /**
                * Get the fingers that are being used.
                * @type Finger[]
                * @public
                */
                get: function () {
                    return this._fingers;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Touch.prototype, "onDown", {
                /**
                * A Kiwi Signal that dispatches an event when a user presses down on the stage.
                * @property onDown
                * @type Signal
                * @public
                */
                get: function () {
                    return this.touchDown;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Touch.prototype, "onUp", {
                /**
                * A Kiwi Signal that dispatches an event when a user releases a finger off of the stage.
                * @property onUp
                * @type Signal
                * @public
                */
                get: function () {
                    return this.touchUp;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Touch.prototype, "onCancel", {
                /**
                * A Kiwi Signal that dispatches an event when a touch event is cancelled for the some reason.
                * @property onCancel
                * @type Signal
                * @public
                */
                get: function () {
                    return this.touchCancel;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * An internal Kiwi method that runs when the DOM is loaded and the touch manager can now 'boot' up.
            * @method boot
            * @public
            */
            Touch.prototype.boot = function () {
                this._domElement = this._game.stage.container;
                this.finger1 = new Kiwi.Input.Finger(this._game);
                this.finger2 = new Kiwi.Input.Finger(this._game);
                this.finger3 = new Kiwi.Input.Finger(this._game);
                this.finger4 = new Kiwi.Input.Finger(this._game);
                this.finger5 = new Kiwi.Input.Finger(this._game);
                this.finger6 = new Kiwi.Input.Finger(this._game);
                this.finger7 = new Kiwi.Input.Finger(this._game);
                this.finger8 = new Kiwi.Input.Finger(this._game);
                this.finger9 = new Kiwi.Input.Finger(this._game);
                this.finger10 = new Kiwi.Input.Finger(this._game);
                this._fingers = [this.finger1, this.finger2, this.finger3, this.finger4, this.finger5, this.finger6, this.finger7, this.finger8, this.finger9, this.finger10];
                this.latestFinger = this.finger1;
                this.touchDown = new Kiwi.Signal();
                this.touchUp = new Kiwi.Signal();
                this.touchCancel = new Kiwi.Signal();
                this.start();
            };
            /**
            * Starts up the event listeners that are being used on the touch manager.
            * @method start
            * @public
            */
            Touch.prototype.start = function () {
                var _this = this;
                if (Kiwi.DEVICE.touch) {
                    this.touchEnabled = true;
                    this._onTouchStartBind = this.onTouchStart.bind(this);
                    this._onTouchMoveBind = this.onTouchMove.bind(this);
                    this._onTouchEndBind = this.onTouchEnd.bind(this);
                    this._onTouchEnterBind = this.onTouchEnter.bind(this);
                    this._onTouchLeaveBind = this.onTouchLeave.bind(this);
                    this._onTouchCancelBind = this.onTouchCancel.bind(this);
                    if (this._game.deviceTargetOption === Kiwi.TARGET_BROWSER) {
                        //Uses the concept of pointers?
                        if (Kiwi.DEVICE.pointerEnabled) {
                            var pointerUp = 'pointerup', pointerDown = 'pointerdown', pointerEnter = 'pointerenter', pointerLeave = 'pointerleave', pointerCancel = 'pointercancel', pointerMove = 'pointermove';
                            //Is it IE 10?
                            if (window["PointerEvent"]) {
                            }
                            else if ((window["MSPointerEvent"])) {
                                // IE10 compatibility
                                var pointerUp = 'MSPointerUp', pointerDown = 'MSPointerDown', pointerEnter = 'MSPointerEnter', pointerLeave = 'MSPointerLeave', pointerCancel = 'MSPointerCancel', pointerMove = 'MSPointerMove';
                            }
                            this._onTouchStartBind = this.onPointerStart.bind(this);
                            this._onTouchMoveBind = this.onPointerMove.bind(this);
                            this._onTouchEndBind = this.onPointerEnd.bind(this);
                            this._onTouchEnterBind = this.onPointerEnter.bind(this);
                            this._onTouchLeaveBind = this.onPointerLeave.bind(this);
                            this._onTouchCancelBind = this.onPointerCancel.bind(this);
                            this._domElement.addEventListener(pointerUp, this._onTouchStartBind, false);
                            this._domElement.addEventListener(pointerMove, this._onTouchMoveBind, false);
                            this._domElement.addEventListener(pointerDown, this._onTouchEndBind, false);
                            this._domElement.addEventListener(pointerEnter, this._onTouchEnterBind, false);
                            this._domElement.addEventListener(pointerLeave, this._onTouchLeaveBind, false);
                            this._domElement.addEventListener(pointerCancel, this._onTouchCancelBind, false);
                        }
                        else {
                            //Regular touch events
                            this._domElement.addEventListener('touchstart', this._onTouchStartBind, false);
                            this._domElement.addEventListener('touchmove', this._onTouchMoveBind, false);
                            this._domElement.addEventListener('touchend', this._onTouchEndBind, false);
                            this._domElement.addEventListener('touchenter', this._onTouchEnterBind, false);
                            this._domElement.addEventListener('touchleave', this._onTouchLeaveBind, false);
                            this._domElement.addEventListener('touchcancel', this._onTouchCancelBind, false);
                            document.addEventListener('touchmove', function (event) { return _this.consumeTouchMove(event); }, false);
                        }
                    }
                    else if (this._game.deviceTargetOption === Kiwi.TARGET_COCOON) {
                        this._game.stage.canvas.addEventListener('touchstart', this._onTouchStartBind, false);
                        this._game.stage.canvas.addEventListener('touchmove', this._onTouchMoveBind, false);
                        this._game.stage.canvas.addEventListener('touchend', this._onTouchEndBind, false);
                        this._game.stage.canvas.addEventListener('touchenter', this._onTouchEnterBind, false);
                        this._game.stage.canvas.addEventListener('touchleave', this._onTouchLeaveBind, false);
                        this._game.stage.canvas.addEventListener('touchcancel', this._onTouchCancelBind, false);
                    }
                }
                else {
                    this.touchEnabled = false;
                }
            };
            /**
            * Prevent iOS bounce-back (doesn't work?)
            * @method consumeTouchMove
            * @param {Any} event
            * @public
            */
            Touch.prototype.consumeTouchMove = function (event) {
                event.preventDefault();
            };
            Object.defineProperty(Touch.prototype, "x", {
                /**
                * Gets the position of the latest finger on the x axis.
                * @property x
                * @type number
                * @public
                */
                get: function () {
                    return this.latestFinger.x;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Touch.prototype, "y", {
                /**
                * Gets the position of the latest finger on the y axis.
                * @property y
                * @type number
                * @public
                */
                get: function () {
                    return this.latestFinger.y;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Touch.prototype, "maximumPointers", {
                /**
                * Gets the maximum number of points of contact that are allowed on the game stage at one point.
                * @type number
                * @public
                */
                get: function () {
                    return this._maxPointers;
                },
                /**
                * Sets the maximum number of point of contact that are allowed on the game stage at one point.
                * The maximum number of points that are allowed is 10, and the minimum is 0.
                * @property maximumPointers
                * @type number
                * @public
                */
                set: function (val) {
                    if (val < 0)
                        val = 1;
                    if (val > this._fingers.length)
                        val = this._fingers.length;
                    this._maxPointers = val;
                },
                enumerable: true,
                configurable: true
            });
            /**
            *-------------------------
            * Generic Methods for Dealing with Pointers
            *-------------------------
            */
            /**
            * This method is in charge of registering a "finger"  (either from a Touch/Pointer start method) and assigning it a Finger,
            * You have to pass this method a id which is used to idenfied when released/cancelled.
            * @method _registerFinger
            * @param event {Any}
            * @param id {Number}
            * @private
            */
            Touch.prototype._registerFinger = function (event, id) {
                for (var f = 0; f < this._maxPointers; f++) {
                    if (this._fingers[f].active === false) {
                        this._fingers[f].id = id;
                        this._fingers[f].start(event);
                        this.latestFinger = this._fingers[f];
                        this.touchDown.dispatch(this._fingers[f].x, this._fingers[f].y, this._fingers[f].timeDown, this._fingers[f].timeUp, this._fingers[f].duration, this._fingers[f]);
                        this.isDown = true;
                        this.isUp = false;
                        break;
                    }
                }
            };
            /**
            * This method is in charge of deregistering (removing) a "finger" when it has been released,
            * You have to pass this method a id which is used to identfy the finger to deregister.
            * @method _deregisterFinger
            * @param event {Any}
            * @param id {Number}
            * @private
            */
            Touch.prototype._deregisterFinger = function (event, id) {
                var finger = null;
                for (var f = 0; f < this._fingers.length; f++) {
                    if (this._fingers[f].active && this._fingers[f].id === id) {
                        this._fingers[f].stop(event);
                        this.latestFinger = this._fingers[f];
                        finger = this._fingers[f];
                        this.isDown = false;
                        this.isUp = true;
                        break;
                    }
                }
                //Loop through the fingers and check to see that none of them are down.
                for (var i = 0; i < this._fingers.length; i++) {
                    if (this._fingers[i].active === true) {
                        this.isDown = true;
                        this.isUp = false;
                    }
                }
                if (finger !== null) {
                    this.touchUp.dispatch(finger.x, finger.y, finger.timeDown, finger.timeUp, finger.duration, finger);
                }
            };
            /**
            * This method is in charge of cancelling (removing) a "finger".
            * You have to pass this method a id which is used to idenfied the finger that was cancelled.
            * @method _cancelFinger
            * @param event {Any}
            * @param id {Number}
            * @private
            */
            Touch.prototype._cancelFinger = function (event, id) {
                for (var f = 0; f < this._fingers.length; f++) {
                    if (this._fingers[f].active && this._fingers[f].id === id) {
                        this._fingers[f].stop(event);
                        this.touchCancel.dispatch(this._fingers[f].x, this._fingers[f].y, this._fingers[f].timeDown, this._fingers[f].timeUp, this._fingers[f].duration, this._fingers[f]);
                        break;
                    }
                }
                //loop through the fingers and check to see that none of them are down.
                for (var i = 0; i < this._fingers.length; i++) {
                    if (this._fingers[i].active) {
                        this.isDown = true;
                        this.isUp = false;
                    }
                }
            };
            /**
            * This method is in charge of creating and assigning (removing) a "finger" when it has entered the dom element.
            * You have to pass this method a id which is used to idenfied the finger that was cancelled.
            * @method _enterFinger
            * @param event {Any}
            * @param id {Number}
            * @private
            */
            Touch.prototype._enterFinger = function (event, id) {
                for (var f = 0; f < this._maxPointers; f++) {
                    if (this._fingers[f].active === false) {
                        this._fingers[f].id = id;
                        this._fingers[f].start(event);
                        this.latestFinger = this._fingers[f];
                        this.isDown = true;
                        this.isUp = false;
                        break;
                    }
                }
            };
            /**
            * This method is in charge of removing an assigned "finger" when it has left the DOM Elemetn.
            * You have to pass this method a id which is used to idenfied the finger that left.
            * @method _leaveFinger
            * @param event {Any}
            * @param id {Number}
            * @private
            */
            Touch.prototype._leaveFinger = function (event, id) {
                for (var f = 0; f < this._fingers.length; f++) {
                    if (this._fingers[f].active && this._fingers[f].id === id) {
                        this._fingers[f].leave(event);
                        break;
                    }
                }
            };
            /**
            * This method is in charge of updating the coordinates of a "finger" when it has moved..
            * You have to pass this method a id which is used to idenfied the finger that moved.
            * @method _moveFinger
            * @param event {Any}
            * @param id {Number}
            * @private
            */
            Touch.prototype._moveFinger = function (event, id) {
                for (var f = 0; f < this._fingers.length; f++) {
                    if (this._fingers[f].active && this._fingers[f].id === id) {
                        this._fingers[f].move(event);
                        this.latestFinger = this._fingers[f];
                        break;
                    }
                }
            };
            /**
            *-------------------
            * Touch Events
            *-------------------
            **/
            /**
            * This method runs when the a touch start event is fired by the browser and then assigns the event to a pointer that is currently not active.
            * https://developer.mozilla.org/en-US/docs/DOM/TouchList
            * @method onTouchStart
            * @param {Any} event
            * @private
            */
            Touch.prototype.onTouchStart = function (event) {
                //Stop corresponding mouse events from firing.
                event.preventDefault();
                for (var i = 0; i < event.changedTouches.length; i++) {
                    this._registerFinger(event.changedTouches[i], event.changedTouches[i].identifier);
                }
            };
            /**
            * Doesn't appear to be supported by most browsers yet but if it was it would fire events when a touch is canceled.
            * http://www.w3.org/TR/touch-events/#dfn-touchcancel
            * @method onTouchCancel
            * @param {Any} event
            * @private
            */
            Touch.prototype.onTouchCancel = function (event) {
                event.preventDefault();
                for (var i = 0; i < event.changedTouches.length; i++) {
                    this._cancelFinger(event.changedTouches[i], event.changedTouches[i].identifier);
                }
            };
            /**
            * Doesn't appear to be supported by most browsers yet. But if it was would fire events when touch events enter an element.
            * @method onTouchEnter
            * @param {Any} event
            * @private
            */
            Touch.prototype.onTouchEnter = function (event) {
                //Stop corresponding mouse events from firing.
                event.preventDefault();
                // For touch enter and leave its a list of the touch points that have entered or left the target
                for (var i = 0; i < event.changedTouches.length; i++) {
                    this._enterFinger(event.changedTouches[i], event.changedTouches[i].identifier);
                }
            };
            /**
            * Doesn't appear to be supported by most browsers yet. Would fire events when a 'finger' leaves an element.
            * Would be handly for when an finger 'leaves' the stage.
            * @method onTouchLeave
            * @param {Any} event
            * @private
            */
            Touch.prototype.onTouchLeave = function (event) {
                //Stops corresponding mouse events from firing
                event.preventDefault();
                // For touch enter and leave its a list of the touch points that have entered or left the target 
                for (var i = 0; i < event.changedTouches.length; i++) {
                    this._leaveFinger(event.changedTouches[i], event.changedTouches[i].identifier);
                }
            };
            /**
            * When a touch pointer moves. This method updates the appropriate pointer.
            * @method onTouchMove
            * @param {Any} event
            * @private
            */
            Touch.prototype.onTouchMove = function (event) {
                //Stop cooresponding mouse events from firing
                event.preventDefault();
                for (var i = 0; i < event.changedTouches.length; i++) {
                    this._moveFinger(event.changedTouches[i], event.changedTouches[i].identifier);
                }
            };
            /**
            * When a touch event gets released.
            * https://developer.mozilla.org/en-US/docs/DOM/TouchList
            * @method onTouchEnd
            * @param {Any} event
            * @private
            */
            Touch.prototype.onTouchEnd = function (event) {
                //Stop cooresponding mouse events from firing
                event.preventDefault();
                for (var i = 0; i < event.changedTouches.length; i++) {
                    this._deregisterFinger(event.changedTouches[i], event.changedTouches[i].identifier);
                }
            };
            /**
            *-------------------
            * Pointer Events
            *-------------------
            **/
            /**
            * Event that is fired when a pointer is initially pressed.
            * @method onPointerStart
            * @param event {PointerEvent}
            * @private
            */
            Touch.prototype.onPointerStart = function (event) {
                if (event.type === 'touch' || event.type === "pointerdown") {
                    this._registerFinger(event, event.pointerId);
                }
            };
            /**
            * Event that is fired by a pointer event listener upon a pointer canceling for some reason.
            * @method onPointerCancel
            * @param event {PointerEvent}
            * @private
            */
            Touch.prototype.onPointerCancel = function (event) {
                if (event.type === 'touch' || event.type === "pointercancel") {
                    this._cancelFinger(event, event.pointerId);
                }
            };
            /**
            * Event that is fired by a pointer event listener upon a pointer entering the DOM Element the event listener is attached to.
            * @method onPointerEnter
            * @param event {PointerEvent}
            * @private
            */
            Touch.prototype.onPointerEnter = function (event) {
                if (event.type === 'touch' || event.type === "pointerenter") {
                    this._enterFinger(event, event.pointerId);
                }
            };
            /**
            * Event that is fired by a pointer event listener upon a pointer being leaving the DOM Element the event listener is attached to.
            * @method onPointerLeave
            * @param event {PointerEvent}
            * @private
            */
            Touch.prototype.onPointerLeave = function (event) {
                if (event.type === 'touch' || event.type === "pointerleave") {
                    this._leaveFinger(event, event.pointerId);
                }
            };
            /**
            * Event that is fired by a pointer event listener upon a pointer moving.
            * @method onPointerMove
            * @param event {PointerEvent}
            */
            Touch.prototype.onPointerMove = function (event) {
                if (event.type === 'touch' || event.type === "pointermove") {
                    this._moveFinger(event, event.pointerId);
                }
            };
            /**
            * Event that is fired by a pointer event listener upon a pointer being released.
            * @method onPointerEnd
            * @param event {PointerEvent}
            * @private
            */
            Touch.prototype.onPointerEnd = function (event) {
                if (event.type === 'touch' || event.type === "pointerup") {
                    this._deregisterFinger(event, event.pointerId);
                }
            };
            /**
            *-----------------
            * Normal Methods
            *-----------------
            **/
            /**
            * The update loop fro the touch manager.
            * @method update
            * @public
            */
            Touch.prototype.update = function () {
                if (this.touchEnabled && this.isDown) {
                    for (var i = 0; i < this._fingers.length; i++) {
                        if (this._fingers[i].active) {
                            this._fingers[i].update();
                        }
                    }
                }
            };
            /**
            * This method removes all of the event listeners and thus 'stops' the touch manager.
            * @method stop
            * @public
            */
            Touch.prototype.stop = function () {
                if (!this.touchEnabled)
                    return;
                if (this._game.deviceTargetOption === Kiwi.TARGET_BROWSER) {
                    //Uses the concept of pointers?
                    if (Kiwi.DEVICE.pointerEnabled) {
                        var pointerUp = 'pointerup', pointerDown = 'pointerdown', pointerEnter = 'pointerenter', pointerLeave = 'pointerleave', pointerCancel = 'pointercancel', pointerMove = 'pointermove';
                        //Is it IE 10?
                        if (window["PointerEvent"]) {
                        }
                        else if ((window["MSPointerEvent"])) {
                            // IE10 compatibility
                            var pointerUp = 'MSPointerUp', pointerDown = 'MSPointerDown', pointerEnter = 'MSPointerEnter', pointerLeave = 'MSPointerLeave', pointerCancel = 'MSPointerCancel', pointerMove = 'MSPointerMove';
                        }
                        this._domElement.removeEventListener(pointerUp, this._onTouchStartBind, false);
                        this._domElement.removeEventListener(pointerMove, this._onTouchMoveBind, false);
                        this._domElement.removeEventListener(pointerDown, this._onTouchEndBind, false);
                        this._domElement.removeEventListener(pointerEnter, this._onTouchEnterBind, false);
                        this._domElement.removeEventListener(pointerLeave, this._onTouchLeaveBind, false);
                        this._domElement.removeEventListener(pointerCancel, this._onTouchCancelBind, false);
                    }
                    else {
                        //Regular touch events
                        this._domElement.removeEventListener('touchstart', this._onTouchStartBind, false);
                        this._domElement.removeEventListener('touchmove', this._onTouchMoveBind, false);
                        this._domElement.removeEventListener('touchend', this._onTouchEndBind, false);
                        this._domElement.removeEventListener('touchenter', this._onTouchEnterBind, false);
                        this._domElement.removeEventListener('touchleave', this._onTouchLeaveBind, false);
                        this._domElement.removeEventListener('touchcancel', this._onTouchCancelBind, false);
                    }
                }
                else if (this._game.deviceTargetOption === Kiwi.TARGET_COCOON) {
                    this._game.stage.canvas.removeEventListener('touchstart', this._onTouchStartBind, false);
                    this._game.stage.canvas.removeEventListener('touchmove', this._onTouchMoveBind, false);
                    this._game.stage.canvas.removeEventListener('touchend', this._onTouchEndBind, false);
                    this._game.stage.canvas.removeEventListener('touchenter', this._onTouchEnterBind, false);
                    this._game.stage.canvas.removeEventListener('touchleave', this._onTouchLeaveBind, false);
                    this._game.stage.canvas.removeEventListener('touchcancel', this._onTouchCancelBind, false);
                }
                delete this._onTouchStartBind;
                delete this._onTouchMoveBind;
                delete this._onTouchEndBind;
                delete this._onTouchEnterBind;
                delete this._onTouchLeaveBind;
                delete this._onTouchCancelBind;
            };
            /**
            * Resets all of the fingers/pointers to their default states.
            * @method reset
            * @public
            */
            Touch.prototype.reset = function () {
                for (var i = 0; i < this._fingers.length; i++) {
                    this._fingers[i].reset();
                }
            };
            return Touch;
        })();
        Input.Touch = Touch;
    })(Input = Kiwi.Input || (Kiwi.Input = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Input
*
*/
var Kiwi;
(function (Kiwi) {
    var Input;
    (function (Input) {
        /**
        * Is a generic class that holds the properties/methods that are common across various different methods of inputs from the user, mainly between Touch and Mouse based events. This abstract class and such it is suppose to be extended from for individual implementations.
        *
        * @class Pointer
        * @constructor
        * @namespace Kiwi.Input
        * @param {Kiwi.Game} game
        * @return {Kiwi.Input.Pointer}
        *
        */
        var Pointer = (function () {
            function Pointer(game) {
                /**
                * The horizontal coordinate of point relative to the game element
                * @property x
                * @type Number
                * @default -1
                * @public
                */
                this.x = -1;
                /**
                * The vertical coordinate of point relative to the game element
                * @property y
                * @type Number
                * @default -1
                * @public
                */
                this.y = -1;
                /**
                * The horizontal coordinate of point relative to the viewport in pixels, excluding any scroll offset
                * @property clientX
                * @type Number
                * @default -1
                * @public
                */
                this.clientX = -1;
                /**
                * The vertical coordinate of point relative to the viewport in pixels, excluding any scroll offset
                * @property clientY
                * @type Number
                * @default -1
                * @public
                */
                this.clientY = -1;
                /**
                * The horizontal coordinate of point relative to the viewport in pixels, including any scroll offset
                * @property pageX
                * @type Number
                * @default -1
                * @public
                */
                this.pageX = -1;
                /**
                * The vertical coordinate of point relative to the viewport in pixels, including any scroll offset
                * @property pageY
                * @type Number
                * @default -1
                * @public
                */
                this.pageY = -1;
                /**
                * The horizontal coordinate of point relative to the screen in pixels
                * @property screenX
                * @type Number
                * @default -1
                * @public
                */
                this.screenX = -1;
                /**
                * The vertical coordinate of point relative to the screen in pixels
                * @property screenY
                * @type Number
                * @default -1
                * @public
                */
                this.screenY = -1;
                /**
                * Indicates if this pointer is currently down.
                * @property isDown
                * @type boolean
                * @default false
                * @public
                */
                this.isDown = false;
                /**
                * Indicates if this pointer is currently up.
                * @property isUp
                * @default true
                * @type boolean
                * @public
                */
                this.isUp = true;
                /**
                * Indicates if this pointer is currently within the game.
                * @property withinGame
                * @type boolean
                * @default false
                * @public
                */
                this.withinGame = false;
                /**
                * Indicates if this pointer is active. Note a mouse is always 'active' where as a finger is only active when it is down.
                * @property active
                * @type boolean
                * @default false
                * @public
                */
                this.active = false;
                /**
                * Indicates the time that the pointer was pressed initially.
                * @property timeDown
                * @type number
                * @default 0
                * @public
                */
                this.timeDown = 0;
                /**
                * Indicates the time that the pointer was released initially.
                * @property timeUp
                * @type number
                * @default 0
                * @public
                */
                this.timeUp = 0;
                /**
                * The duration that the pointer has been down for in milliseconds.
                * @property duration
                * @type number
                * @default 0
                * @public
                */
                this.duration = 0;
                /**
                * The duration that the pointer has been down for in frames.
                * @property frameDuration
                * @type number
                * @default 0
                * @public
                */
                this.frameDuration = 0;
                /**
                * A time that is used to calculate if someone justPressed the pointer.
                * @property justPressedRate
                * @type number
                * @defeault 200
                * @public
                */
                this.justPressedRate = 200;
                /**
                * A time that is used to calculate if someone justReleased the pointer.
                * @property justReleasedRate
                * @type number
                * @default 200
                * @public
                */
                this.justReleasedRate = 200;
                this._game = game;
                this.point = new Kiwi.Geom.Point();
                this.circle = new Kiwi.Geom.Circle(0, 0, 1);
                this.startPoint = new Kiwi.Geom.Point();
                this.endPoint = new Kiwi.Geom.Point();
            }
            /**
            * The type of object this class is.
            * @method objType
            * @return {string} "Pointer"
            * @public
            */
            Pointer.prototype.objType = function () {
                return "Pointer";
            };
            Object.defineProperty(Pointer.prototype, "game", {
                /**
                * Get the game that this pointer belongs to.
                * @type Game
                * @public
                */
                get: function () {
                    return this._game;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * The method that gets executed when the pointer presses/initially goes down on the screen.
            * From the event passed the coordinates are calculated.
            * @method start
            * @param {event} event
            * @public
            */
            Pointer.prototype.start = function (event) {
                this.move(event);
                this.startPoint.setTo(this.x, this.y);
                this.frameDuration = 0;
                this.withinGame = true;
                this.isDown = true;
                this.isUp = false;
                this.timeDown = this.game.time.now();
            };
            /**
            * The stop method is to be called when the pointer gets released initially.
            * @method stop
            * @param {event} event
            * @public
            */
            Pointer.prototype.stop = function (event) {
                this.withinGame = false;
                this.endPoint.setTo(this.x, this.y);
                this.isDown = false;
                this.isUp = true;
                this.timeUp = this.game.time.now();
                this.duration = this.timeUp - this.timeDown;
            };
            /**
            * Used to get the cooridnates of a pointer and inputs them to the correct properties.
            * @method move
            * @param {event} event
            * @public
            */
            Pointer.prototype.move = function (event) {
                this.clientX = event.clientX;
                this.clientY = event.clientY;
                this.pageX = event.pageX;
                this.pageY = event.pageY;
                this.screenX = event.screenX;
                this.screenY = event.screenY;
                this.x = (this.pageX - this.game.stage.offset.x) * this.game.stage.scaleX;
                this.y = (this.pageY - this.game.stage.offset.y) * this.game.stage.scaleY;
                this.point.setTo(this.x, this.y);
                this.circle.x = this.x;
                this.circle.y = this.y;
                this.duration = this.game.time.now() - this.timeDown;
            };
            /**
            * Indicates if the pointer was just pressed. This is based of the justPressedRate unless otherwise specifieds.
            * @method justPressed
            * @param {Number} duration
            * @return boolean
            * @public
            */
            Pointer.prototype.justPressed = function (duration) {
                if (duration === void 0) { duration = this.justPressedRate; }
                if (this.isDown === true && (this.timeDown + duration) > this._game.time.now()) {
                    return true;
                }
                else {
                    return false;
                }
            };
            /**
            * Indicates if the pointer was just released. This is based of the justReleasedRate unless otherwise specified.
            * @method justReleased
            * @param {Number} duration
            * @return boolean
            * @public
            */
            Pointer.prototype.justReleased = function (duration) {
                if (duration === void 0) { duration = this.justReleasedRate; }
                if (this.isUp === true && (this.timeUp + duration) > this._game.time.now()) {
                    return true;
                }
                else {
                    return false;
                }
            };
            Object.defineProperty(Pointer.prototype, "pressed", {
                /**
                * READ ONLY: Indicates if this pointer was pressed on the last frame or not.
                * This is only true on the frame that the point was 'justPressed' and is not a constant like 'isDown'
                *
                * @property pressed
                * @type boolean
                * @readOnly
                * @public
                */
                get: function () {
                    return (this.timeDown >= this._game.time.now() - this._game.time.delta());
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Pointer.prototype, "released", {
                /**
                * READ ONLY: Indicates if this pointer was released on the last frame or not.
                * This is only true on the frame that the point was 'justReleased' and is not a constant like 'isUp'
                *
                * @property released
                * @type boolean
                * @readOnly
                * @public
                */
                get: function () {
                    return (this.timeUp >= this._game.time.now() - this._game.time.delta());
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Resets the pointer properties to the default ones. Assumes that the pointer is no longer down.
            * @method reset
            * @public
            */
            Pointer.prototype.reset = function () {
                this.isDown = false;
                this.isUp = true;
                this.timeDown = 0;
                this.timeUp = 0;
                this.duration = 0;
                this.frameDuration = 0;
            };
            /**
            * The update loop for the pointer. Used only if down to update the duration.
            * @method update
            * @public
            */
            Pointer.prototype.update = function () {
                if (this.isDown === true) {
                    this.frameDuration++;
                    this.duration = this._game.time.now() - this.timeDown;
                }
            };
            return Pointer;
        })();
        Input.Pointer = Pointer;
    })(Input = Kiwi.Input || (Kiwi.Input = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Input
*
*/
var Kiwi;
(function (Kiwi) {
    var Input;
    (function (Input) {
        /**
        * Holds the information about a Mouse Cursor, such as the position of the
        * cursor, the mouse wheel's delta, the button that was used, e.t.c.
        * Note: A mouse cursor is always active.
        *
        * @class MouseCursor
        * @namespace Kiwi.Input
        * @extends Pointer
        */
        var MouseCursor = (function (_super) {
            __extends(MouseCursor, _super);
            function MouseCursor() {
                _super.apply(this, arguments);
                /**
                * The offset of the mouse wheel on the X axis.
                * @property wheelDeltaX
                * @type number
                * @default 0
                * @public
                */
                this.wheelDeltaX = 0;
                /**
                * The offset of the mouse wheel on the Y axis.
                * @property wheelDeltaY
                * @type number
                * @default 0
                * @public
                */
                this.wheelDeltaY = 0;
                /**
                * Indicates if the "preventDefault" method should be executed whenever a 'down' mouse event occurs.
                * @property preventDown
                * @type boolean
                * @public
                */
                this.preventDown = true;
                /**
                * Indicates if the "preventDefault" method should be executed whenever a 'up' mouse event occurs.
                * @property preventUp
                * @type boolean
                * @public
                */
                this.preventUp = true;
                /**
                * Indicates if the "preventDefault" method should be executed whenever a 'wheel' mouse event occurs.
                * @property preventWheel
                * @type boolean
                * @public
                */
                this.preventWheel = true;
            }
            /**
            * The type of object this class is.
            * @method objType
            * @return {string} "MouseCursor"
            * @public
            */
            MouseCursor.prototype.objType = function () {
                return "MouseCursor";
            };
            /**
            * Gets executed when the mouse cursor gets initally pressed.
            * @method start
            * @param {event} event
            * @public
            */
            MouseCursor.prototype.start = function (event) {
                if (this.preventDown)
                    event.preventDefault();
                this.ctrlKey = event.ctrlKey;
                this.shiftKey = event.shiftKey;
                this.altKey = event.altKey;
                this.button = event.button;
                _super.prototype.start.call(this, event);
            };
            /**
            * Gets executed when the mouse cursor gets initally released.
            * @method stop
            * @param {event} event
            * @public
            */
            MouseCursor.prototype.stop = function (event) {
                if (this.preventUp)
                    event.preventDefault();
                this.move(event);
                _super.prototype.stop.call(this, event);
            };
            /**
            * When the mouse wheel event fires and the mouse's delta changes.
            * @method wheel
            * @param {event} event
            * @public
            */
            MouseCursor.prototype.wheel = function (event) {
                if (this.preventWheel)
                    event.preventDefault();
                if (event['wheelDeltaX']) {
                    this.wheelDeltaX = event['wheelDeltaX'];
                }
                else {
                    this.wheelDeltaX = event.deltaX;
                }
                if (event['wheelDeltaY']) {
                    this.wheelDeltaY = event['wheelDeltaY'];
                }
                else {
                    this.wheelDeltaY = event.deltaY;
                }
            };
            return MouseCursor;
        })(Input.Pointer);
        Input.MouseCursor = MouseCursor;
    })(Input = Kiwi.Input || (Kiwi.Input = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Input
*
*/
var Kiwi;
(function (Kiwi) {
    var Input;
    (function (Input) {
        /**
        * Used with the Touch manager class, this object holds information about a
        * single touch point/location (or, you know, a finger). By default a Finger
        * has a diameter of 44 pixels (random average size of a finger) which can
        * be used for collision/overlap detection. That value can be modified.
        * Note: A Finger is only active whilst the user is 'pressing' down on stage.
        *
        * @class Finger
        * @extends Pointer
        * @namespace Kiwi.Input
        * @constructor
        * @param game {Kiwi.Game} The game that this finger belongs to.
        * @return Finger
        */
        var Finger = (function (_super) {
            __extends(Finger, _super);
            function Finger(game) {
                _super.call(this, game);
                this.circle.diameter = 44; //The diameter of your average finger!
            }
            /**
            * The type of object this is.
            * @method objType
            * @return {string} "Finger"
            * @public
            */
            Finger.prototype.objType = function () {
                return "Finger";
            };
            /**
            * @method start
            * @param {Any} event
            * @public
            */
            Finger.prototype.start = function (event) {
                this.active = true;
                _super.prototype.start.call(this, event);
            };
            /**
            * @method stop
            * @param event {Any}
            * @public
            */
            Finger.prototype.stop = function (event) {
                this.active = false;
                _super.prototype.stop.call(this, event);
            };
            /**
            * @method leave
            * @param event {Any}
            * @public
            */
            Finger.prototype.leave = function (event) {
                this.withinGame = false;
                this.move(event);
            };
            /**
            * @method reset
            * @public
            */
            Finger.prototype.reset = function () {
                this.active = false;
                _super.prototype.reset.call(this);
            };
            return Finger;
        })(Input.Pointer);
        Input.Finger = Finger;
    })(Input = Kiwi.Input || (Kiwi.Input = {}));
})(Kiwi || (Kiwi = {}));
/**
* Contains common classes whose applications deal with geometry or the collision of geometric shapes.
*
* @module Kiwi
* @submodule Geom
* @main
*/
var Kiwi;
(function (Kiwi) {
    var Geom;
    (function (Geom) {
        /**
        * An object representation of an axis-aligned bounding box.
        *
        * @class AABB
        * @namespace Kiwi.Geom
        * @constructor
        * @param cx {Number} The centeral position on the x-axis.
        * @param cy {Number} The centeral position on the y-axis.
        * @param width {Number} The width of the box.
        * @param height {Number} The height of the box.
        * @return {Kiwi.Geom.AABB}
        */
        var AABB = (function () {
            function AABB(cx, cy, width, height) {
                /**
                * The centeral location of the box on the x-axis.
                * @property cx
                * @type Number
                * @public
                */
                this.cx = 0;
                /**
                * The centeral location of the box on the y-axis.
                * @property cy
                * @type Number
                * @public
                */
                this.cy = 0;
                /**
                * Half of the width.
                * @property halfWidth
                * @type Number
                * @public
                */
                this.halfWidth = 0;
                /**
                * Half of the height.
                * @property halfHeight
                * @type Number
                * @public
                */
                this.halfHeight = 0;
                this.cx = cx || 0;
                this.cy = cy || 0;
                this.halfWidth = width / 2 || 0;
                this.halfHeight = height / 2 || 0;
            }
            /**
            * Returns the type of this object
            * @method objType
            * @return {String} "AABB"
            * @public
            */
            AABB.prototype.objType = function () {
                return "AABB";
            };
            Object.defineProperty(AABB.prototype, "height", {
                /**
                * Returns the full height. This is read only.
                * @property height
                * @type number
                * @readOnly
                * @public
                */
                get: function () {
                    return this.halfHeight * 2;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(AABB.prototype, "width", {
                /**
                * Returns the full width. This is read only.
                * @property width
                * @type number
                * @readOnly
                * @public
                */
                get: function () {
                    return this.halfWidth * 2;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Draws the object to a canvas context passed.
            * @method draw
            * @param ctx {CanvasRenderingContext2D} The context you want this drawn to.
            * @return {Kiwi.Geom.AABB}
            * @public
            */
            AABB.prototype.draw = function (ctx) {
                ctx.beginPath();
                ctx.moveTo(this.cx - this.halfWidth, this.cy);
                ctx.lineTo(this.cx + this.halfWidth, this.cy);
                ctx.moveTo(this.cx, this.cy - this.halfHeight);
                ctx.lineTo(this.cx, this.cy + this.halfHeight);
                ctx.stroke();
                return this;
            };
            /**
            * Sets the position of the object.
            * @method setPosition
            * @param cx {Number} Its new x-axis location.
            * @param cy {Number} Its new y-axis location.
            * @return {Kiwi.Geom.AABB}
            * @public
            */
            AABB.prototype.setPosition = function (cx, cy) {
                this.cx = cx;
                this.cy = cy;
                return this;
            };
            /**
            * Sets the position of the object by a point that you pass.
            *
            * @method setPositionPoint
            * @param pos {Kiwi.Geom.Point}
            * @return {Kiwi.Geom.AABB}
            * @public
            */
            AABB.prototype.setPositionPoint = function (pos) {
                this.cx = pos.x;
                this.cy = pos.y;
                return this;
            };
            /**
            * Returns this object but as a new Rectangle.
            *
            * @method toRect
            * @return {Kiwi.Geom.Rectangle}
            * @public
            */
            AABB.prototype.toRect = function () {
                return new Geom.Rectangle(this.cx - this.halfWidth, this.cy - this.halfHeight, this.halfWidth * 2, this.halfHeight * 2);
            };
            /**
            * Gives the dimension of this AABB from a rectangle's.
            * @method fromRect
            * @param {Kiwi.Geom.Rectangle} rect
            * @return {Kiwi.Geom.AABB}
            * @public
            */
            AABB.prototype.fromRect = function (rect) {
                this.halfWidth = rect.width / 2;
                this.halfHeight = rect.height / 2;
                this.cx = rect.x + this.halfWidth;
                this.cy = rect.y + this.halfHeight;
                return this;
            };
            return AABB;
        })();
        Geom.AABB = AABB;
    })(Geom = Kiwi.Geom || (Kiwi.Geom = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Geom
*/
var Kiwi;
(function (Kiwi) {
    var Geom;
    (function (Geom) {
        /**
        * A Circle object is an area defined by its position,
        * as indicated by its center point (x,y) and diameter.
        *
        * @class Circle
        * @namespace Kiwi.Geom
        * @constructor
        * @param [x=0] {Number} The x coordinate of the center of the circle.
        * @param [y=0] {Number} The y coordinate of the center of the circle.
        * @param [diameter=0] {number} The diameter of the circle.
        * @return {Kiwi.Geom.Circle} This circle object
        *
        */
        var Circle = (function () {
            function Circle(x, y, diameter) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (diameter === void 0) { diameter = 0; }
                /**
                * The diameter of the circle
                * @property _diameter
                * @type Number
                * @default 0
                * @private
                */
                this._diameter = 0;
                /**
                * The radius of the circle
                * @property _radius
                * @type Number
                * @default 0
                * @private
                */
                this._radius = 0;
                /**
                * The x coordinate of the center of the circle
                * @property x
                * @type Number
                * @default 0
                * @public
                */
                this.x = 0;
                /**
                * The y coordinate of the center of the circle
                * @property y
                * @type Number
                * @default 0
                * @public
                */
                this.y = 0;
                this.setTo(x, y, diameter);
            }
            /**
            * The type of this object.
            * @method objType
            * @return {String} "Circle"
            * @public
            */
            Circle.prototype.objType = function () {
                return "Circle";
            };
            Object.defineProperty(Circle.prototype, "diameter", {
                get: function () {
                    return this._diameter;
                },
                /**
                * The diameter of the circle.
                * The largest distance between any two points on the circle.
                * The same as the radius * 2.
                *
                * @property diameter
                * @type number
                * @public
                */
                set: function (value) {
                    if (value > 0) {
                        this._diameter = value;
                        this._radius = value * 0.5;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Circle.prototype, "radius", {
                get: function () {
                    return this._radius;
                },
                /**
                * The radius of the circle.
                * The length of a line extending from the center of the circle to any point on the circle itself.
                * The same as half the diameter.
                *
                * @property radius
                * @type number
                * @public
                */
                set: function (value) {
                    if (value > 0) {
                        this._radius = value;
                        this._diameter = value * 2;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Circle.prototype, "circumference", {
                /**
                * The circumference of the circle. This is READ ONLY.
                * @property circumference
                * @type number
                * @readOnly
                * @public
                */
                get: function () {
                    return 2 * (Math.PI * this._radius);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Circle.prototype, "bottom", {
                get: function () {
                    return this.y + this._radius;
                },
                /**
                * The sum of the y and radius properties.
                * Changing the bottom property of a Circle object has no effect on the x and y properties,
                * but does change the diameter.
                * @property bottom
                * @type number
                * @public
                */
                set: function (value) {
                    if (!isNaN(value)) {
                        if (value < this.y) {
                            this._radius = 0;
                            this._diameter = 0;
                        }
                        else {
                            this.radius = value - this.y;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Circle.prototype, "left", {
                get: function () {
                    return this.x - this._radius;
                },
                /**
                * The x coordinate of the leftmost point of the circle.
                * Changing the left property of a Circle object has no effect on the x and y properties.
                * However it does affect the diameter, whereas changing the x value does not affect the diameter property.
                *
                * @property left
                * @type number
                * @public
                */
                set: function (value) {
                    if (!isNaN(value)) {
                        if (value < this.x) {
                            this.radius = this.x - value;
                        }
                        else {
                            this._radius = 0;
                            this._diameter = 0;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Circle.prototype, "right", {
                get: function () {
                    return this.x + this._radius;
                },
                /**
                * The x coordinate of the rightmost point of the circle.
                * Changing the right property of a Circle object has no effect on the x and y properties.
                * However it does affect the diameter, whereas changing the x value does not affect the diameter property.
                *
                * @property right
                * @type number
                * @public
                */
                set: function (value) {
                    if (value && !isNaN(value)) {
                        if (value > this.x) {
                            this.radius = value - this.x;
                        }
                        else {
                            this._radius = 0;
                            this._diameter = 0;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Circle.prototype, "top", {
                get: function () {
                    return this.y - this._radius;
                },
                /**
                * The sum of the y minus the radius property.
                * Changing the top property of a Circle object has no effect on the x and y properties,
                * but does change the diameter.
                *
                * @property top
                * @type number
                * @public
                */
                set: function (value) {
                    if (value && !isNaN(value)) {
                        if (value > this.y) {
                            this._radius = 0;
                            this._diameter = 0;
                        }
                        else {
                            this.radius = this.y - value;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Circle.prototype, "area", {
                /**
                * Gets the area of this Circle. Note this is READ ONLY.
                * @property area
                * @type number
                * @readOnly
                * @public
                */
                get: function () {
                    if (this._radius > 0) {
                        return Math.PI * this._radius * this._radius;
                    }
                    else {
                        return 0;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Circle.prototype, "isEmpty", {
                /**
                * Determines whether or not this Circle object is empty.
                * @method isEmpty
                * @return {boolean} A value of true if the Circle objects diameter is less than or equal to 0; otherwise false.
                * @public
                */
                get: function () {
                    if (this._diameter <= 0) {
                        return true;
                    }
                    return false;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Returns a new Circle object with the same values for the x, y, diameter, and radius properties as the original Circle object.
            * @method clone
            * @param [output=Circle] {Kiwi.Geom.Circle} If given the values will be set into the object, otherwise a brand new Circle object will be created and returned.
            * @return {Kiwi.Geom.Circle}
            * @public
            */
            Circle.prototype.clone = function (output) {
                if (output === void 0) { output = new Circle; }
                return output.setTo(this.x, this.y, this._diameter);
            };
            /**
            * Copies all of circle data from a Circle object passed (the source) into this Circle object.
            * @method copyFrom
            * @param source {Kiwi.Geom.Circle} The source circle object to copy from
            * @return {Kiwi.Geom.Circle} This circle object
            * @public
            */
            Circle.prototype.copyFrom = function (source) {
                return this.setTo(source.x, source.y, source.diameter);
            };
            /**
            * Copies all of circle data from this Circle object into a passed Circle object (destination).
            * @method copyTo
            * @param circle {Kiwi.Geom.Circle} The destination circle object to copy in to
            * @return {Kiwi.Geom.Circle} The destination circle object
            * @public
            */
            Circle.prototype.copyTo = function (target) {
                return target.copyFrom(this);
            };
            /**
            * Returns the distance from the center of this Circle object to the passed object.
            * The passed object can be a Circle, Point, or anything with x/y values.
            *
            * @method distanceTo
            * @param target {Any} The destination Point object.
            * @param [round=false] {boolean} Round the distance to the nearest integer (default false)
            * @return {Number} The distance between this Point object and the destination Point object.
            * @public
            */
            Circle.prototype.distanceTo = function (target, round) {
                if (round === void 0) { round = false; }
                var dx = this.x - target.x;
                var dy = this.y - target.y;
                if (round === true) {
                    return Math.round(Math.sqrt(dx * dx + dy * dy));
                }
                else {
                    return Math.sqrt(dx * dx + dy * dy);
                }
            };
            /**
            * Determines whether a Circle passed is equal to this Circle.
            * They are considered 'equal' if both circles have the same values for x, y, and diameter properties.
            *
            * @method equals
            * @param toCompare {Kiwi.Geom.Circle} The circle to compare to this Circle object.
            * @return {boolean} A value of true if the object has exactly the same values for the x, y and diameter properties as this Circle object; otherwise false.
            * @public
            */
            Circle.prototype.equals = function (toCompare) {
                if (this.x === toCompare.x && this.y === toCompare.y && this.diameter === toCompare.diameter) {
                    return true;
                }
                return false;
            };
            /**
            * Determines whether a Circle passed intersects with this Circle.
            * Returns a boolean indicating if the two circles intersect.
            *
            * @method intersects
            * @param toIntersect {Kiwi.Geom.Circle} The Circle object to compare against to see if it intersects with this Circle object.
            * @return {boolean} A value of true if the specified object intersects with this Circle object; otherwise false.
            * @public
            */
            Circle.prototype.intersects = function (toIntersect) {
                if (this.distanceTo(toIntersect, false) < (this._radius + toIntersect._radius)) {
                    return true;
                }
                return false;
            };
            /**
            * Returns a Point object containing the coordinates of a point on the circumference of this Circle based on the given angle.
            *
            * @method circumferencePoint
            * @param angle {Number} The angle in radians (unless asDegrees is true) to return the point from.
            * @param [asDegress=false] {boolean} Is the given angle in radians (false) or degrees (true)?
            * @param [output] {Kiwi.Geom.Point} A Point object to put the result in to. If none specified a new Point object will be created.
            * @return {Kiwi.Geom.Point} The Point object holding the result.
            * @public
            */
            Circle.prototype.circumferencePoint = function (angle, asDegrees, output) {
                if (asDegrees === void 0) { asDegrees = false; }
                if (output === void 0) { output = new Geom.Point; }
                if (asDegrees === true) {
                    angle = angle * (Math.PI / 180); // Radians to Degrees
                }
                output.x = this.x + this._radius * Math.cos(angle);
                output.y = this.y + this._radius * Math.sin(angle);
                return output;
            };
            /**
            * Adjusts the location of the Circle object, as determined by its center coordinate, by the specified amounts.
            * @method offset
            * @param dx {Number} Moves the x value of the Circle object by this amount.
            * @param dy {Number} Moves the y value of the Circle object by this amount.
            * @return {Kiwi.Geom.Circle} This Circle object.
            * @public
            */
            Circle.prototype.offset = function (dx, dy) {
                if (!isNaN(dx) && !isNaN(dy)) {
                    this.x += dx;
                    this.y += dy;
                }
                return this;
            };
            /**
            * Adjusts the location of the Circle object using a Point object as a parameter.
            * This method is similar to the 'offset' method, except that it takes a Point object as a parameter.
            *
            * @method offsetPoint
            * @param {Kiwi.Geom.Point} point A Point object to use to offset this Circle object.
            * @return {Kiwi.Geom.Circle} This Circle object.
            * @public
            */
            Circle.prototype.offsetPoint = function (point) {
                return this.offset(point.x, point.y);
            };
            /**
            * Sets the members of Circle to the specified values.
            *
            * @method setTo
            * @param x {Number} The x coordinate of the center of the circle.
            * @param y {Number} The y coordinate of the center of the circle.
            * @param diameter {Number} The diameter of the circle in pixels.
            * @return {Kiwi.Geom.Circle} This circle object
            * @public
            */
            Circle.prototype.setTo = function (x, y, diameter) {
                this.x = x;
                this.y = y;
                this._diameter = diameter;
                this._radius = diameter * 0.5;
                return this;
            };
            /**
            * Returns a string representation of this object.
            * @method toString
            * @return {string} a string representation of the instance.
            * @public
            */
            Circle.prototype.toString = function () {
                return "[{Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]";
            };
            return Circle;
        })();
        Geom.Circle = Circle;
    })(Geom = Kiwi.Geom || (Kiwi.Geom = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Geom
*/
var Kiwi;
(function (Kiwi) {
    var Geom;
    (function (Geom) {
        /**
        * A Line object has two meanings depending on the situation you need.
        * Either an infinte line through space (this is the usual meaning of a Line)
        * OR it can be a Line Segment which just exists between the TWO points you specify.
        *
        * @class Line
        * @namespace Kiwi.Geom
        * @constructor
        * @param [x1=0] {Number} Starting location of the line on the x-axis.
        * @param [y1=0] {Number} Starting location of the line on the y-axis.
        * @param [x2=0] {Number} End location of the line on the x-axis.
        * @param [y2=0] {Number} End location of the line on the y-axis.
        * @return {Kiwi.Geom.Line} This Object
        *
        */
        var Line = (function () {
            function Line(x1, y1, x2, y2) {
                if (x1 === void 0) { x1 = 0; }
                if (y1 === void 0) { y1 = 0; }
                if (x2 === void 0) { x2 = 0; }
                if (y2 === void 0) { y2 = 0; }
                /**
                * X position of first point on the line.
                * @property x1
                * @type Number
                * @public
                */
                this.x1 = 0;
                /**
                * Y position of first point on the line.
                * @property y1
                * @type Number
                * @public
                */
                this.y1 = 0;
                /**
                * X position of second point.
                * @property x2
                * @type Number
                * @public
                */
                this.x2 = 0;
                /**
                * Y position of second point.
                * @property y2
                * @type Number
                * @public
                */
                this.y2 = 0;
                this.setTo(x1, y1, x2, y2);
            }
            /**
            * Returns the type of this object
            * @method objType
            * @return {string} "Line"
            * @public
            */
            Line.prototype.objType = function () {
                return "Line";
            };
            /**
            * Makes a clone of this Line.
            * The clone can either be a new Line Object,
            * Otherwise you can pass a existing Line Object that you want to be a clone of this one.
            *
            * @method clone
            * @param [output=Line] {Kiwi.Geom.Line}
            * @return {Kiwi.Geom.Line}
            * @public
            */
            Line.prototype.clone = function (output) {
                if (output === void 0) { output = new Line; }
                return output.setTo(this.x1, this.y1, this.x2, this.y2);
            };
            /**
            * Make this Line a copy of another passed Line.
            * @method copyFrom
            * @param source {Kiwi.Geom.Line} source
            * @return {Kiwi.Geom.Line}
            * @public
            */
            Line.prototype.copyFrom = function (source) {
                return this.setTo(source.x1, source.y1, source.x2, source.y2);
            };
            /**
            * Make another passed Line a copy of this one.
            * @method copyTo
            * @param target {Kiwi.Geom.Line} target
            * @return {Kiwi.Geom.Line}
            * @public
            */
            Line.prototype.copyTo = function (target) {
                return target.copyFrom(this);
            };
            /**
            * Used to set all components on the line.
            * @method setTo
            * @param [x1=0]{Number} X component of first point.
            * @param [y1=0]{Number} Y component of first point.
            * @param [x2=0]{Number} X component of second point.
            * @param [y2=0]{Number} Y component of second point.
            * @return {Kiwi.Geom.Line}
            * @public
            */
            Line.prototype.setTo = function (x1, y1, x2, y2) {
                if (x1 === void 0) { x1 = 0; }
                if (y1 === void 0) { y1 = 0; }
                if (x2 === void 0) { x2 = 0; }
                if (y2 === void 0) { y2 = 0; }
                this.x1 = x1;
                this.y1 = y1;
                this.x2 = x2;
                this.y2 = y2;
                return this;
            };
            Object.defineProperty(Line.prototype, "length", {
                /**
                * Get the length of the Line as a Line Segment.
                * @property length
                * @type number
                * @readOnly
                * @public
                */
                get: function () {
                    return Math.sqrt((this.x2 - this.x1) * (this.x2 - this.x1) + (this.y2 - this.y1) * (this.y2 - this.y1));
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Get the y of a point on the line for a given x.
            * @method getY
            * @param x {Number}
            * @return {Number}
            * @public
            */
            Line.prototype.getY = function (x) {
                if (this.x1 == this.x2)
                    return null;
                else
                    return this.slope * x + this.yIntercept;
            };
            Object.defineProperty(Line.prototype, "angle", {
                /**
                * Get the angle of the line.
                * @property angle
                * @type Number
                * @readOnly
                * @public
                */
                get: function () {
                    return Math.atan2(this.y2 - this.y1, this.x2 - this.x1);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Line.prototype, "slope", {
                /**
                * Get the slope of the line (y/x).
                * @property slope
                * @type Number
                * @readOnly
                * @public
                */
                get: function () {
                    return (this.y2 - this.y1) / (this.x2 - this.x1);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Line.prototype, "perpSlope", {
                /**
                * Get the perpendicular slope of the line (x/y).
                * @propery perpSlope
                * @type Number
                * @readOnly
                * @public
                */
                get: function () {
                    return -((this.x2 - this.x1) / (this.y2 - this.y1));
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Line.prototype, "yIntercept", {
                /**
                * Get the y intercept for the line.
                * @property yIntercept
                * @type Number
                * @readOnly
                * @public
                */
                get: function () {
                    return (this.y1 - this.slope * this.x1);
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Check if a point is on the line.
            * @method isPointOnLine
            * @param x {Number}
            * @param y {Number}
            * @return {boolean}
            * @public
            */
            Line.prototype.isPointOnLine = function (x, y) {
                if ((x - this.x1) * (this.y2 - this.y1) === (this.x2 - this.x1) * (y - this.y1)) {
                    return true;
                }
                else {
                    return false;
                }
            };
            /**
            * Check if the point is both on the line and within the line segment.
            * @method isPointOnLineSegment
            * @param x {Number}
            * @param y {Number}
            * @return {boolean}
            * @public
            */
            Line.prototype.isPointOnLineSegment = function (x, y) {
                var xMin = Math.min(this.x1, this.x2);
                var xMax = Math.max(this.x1, this.x2);
                var yMin = Math.min(this.y1, this.y2);
                var yMax = Math.max(this.y1, this.y2);
                if (this.isPointOnLine(x, y) && (x >= xMin && x <= xMax) && (y >= yMin && y <= yMax)) {
                    return true;
                }
                else {
                    return false;
                }
            };
            /**
            * Check to see if this Line object intersects at any point with a passed Line.
            * Note: Both are treated as extending infinately through space.
            * Functions as an alias for the 'Kiwi.Geom.Intersect.lineToLine' method.
            *
            * @method intersectLineLine
            * @param line {Kiwi.Geom.Line} The line you want to check for a Intersection with.
            * @return {Kiwi.Geom.IntersectResult} The Intersect Result containing the collision information.
            * @public
            */
            Line.prototype.intersectLineLine = function (line) {
                return Kiwi.Geom.Intersect.lineToLine(this, line);
            };
            /**
            * Get a line perpendicular to the line passing through a given point.
            *
            * @method perp
            * @param x {Number}
            * @param y {Number}
            * @param [output] {Kiwi.Geom.Line} The line object that the result should be output to. Creates a new Line if one is not passed.
            * @return {Kiwi.Geom.Line}
            * @public
            */
            Line.prototype.perp = function (x, y, output) {
                if (output === void 0) { output = new Line; }
                var pt;
                // For a horizontal line, the output is a vertical line.
                if (this.y1 === this.y2) {
                    output.setTo(x, y, x, this.y1);
                    return output;
                }
                // For a vertical line, the output is a horizontal line.
                if (this.x1 === this.x2) {
                    output.setTo(x, y, this.x1, y);
                    return output;
                }
                var yInt = (y - this.perpSlope * x);
                if (x !== 0) {
                    pt = this.intersectLineLine({ x1: x, y1: y, x2: 0, y2: yInt });
                }
                else {
                    pt = this.intersectLineLine({ x1: x, y1: y, x2: 1, y2: yInt + this.perpSlope });
                }
                output.setTo(x, y, pt.x, pt.y);
                return output;
            };
            /**
            * Get a string representation of the line.
            * @method toString
            * @return {String}
            * @public
            */
            Line.prototype.toString = function () {
                return "[{Line (x1=" + this.x1 + " y1=" + this.y1 + " x2=" + this.x2 + " y2=" + this.y2 + ")}]";
            };
            return Line;
        })();
        Geom.Line = Line;
    })(Geom = Kiwi.Geom || (Kiwi.Geom = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Geom
*/
var Kiwi;
(function (Kiwi) {
    var Geom;
    (function (Geom) {
        /**
        * Represents a halfline. The ray starts at the first point
        * and extends infinitely in the direction of the second.
        *
        * @class Ray
        * @namespace Kiwi.Geom
        * @extends Kiwi.Geom.Line
        * @constructor
        * @param [x1=0] {Number} Starting location of the ray on the x-axis
        * @param [y1=0] {Number} Starting location of the ray on the y-axis
        * @param [x2=0] {Number} End location of the ray on the x-axis.
        *	Used to calculate direction so it isn't really the 'end' location.
        * @param [y2=0] {Number} End location of the ray on the y-axis.
        *	Used to calculate direction so it isn't really the 'end' location.
        * @return {Kiwi.Geom.Ray} This object
        */
        var Ray = (function (_super) {
            __extends(Ray, _super);
            function Ray(x1, y1, x2, y2) {
                if (x1 === void 0) { x1 = 0; }
                if (y1 === void 0) { y1 = 0; }
                if (x2 === void 0) { x2 = 0; }
                if (y2 === void 0) { y2 = 0; }
                _super.call(this, x1, y1, x2, y2);
            }
            /**
            * The type of this object.
            * @method objType
            * @return {String} "Ray"
            * @public
            */
            Ray.prototype.objType = function () {
                return "Ray";
            };
            /**
            * Makes a copy of this Ray, either as a new Ray object, or
            * makes a passed Ray a copy of this one.
            *
            * @method clone
            * @param [output] {Kiwi.Geom.Ray}
            * @return {Kiwi.Geom.Ray}
            * @public
            */
            Ray.prototype.clone = function (output) {
                if (output === void 0) { output = new Ray; }
                return output.setTo(this.x1, this.y1, this.x2, this.y2);
            };
            /**
            * Check if the Ray passes through a point.
            * @method isPointOnRay
            * @param x {Number}
            * @param y {Number}
            * @return {boolean}
            * @public
            */
            Ray.prototype.isPointOnRay = function (x, y) {
                if ((x - this.x1) * (this.y2 - this.y1) === (this.x2 - this.x1) * (y - this.y1)) {
                    if (Math.atan2(y - this.y1, x - this.x1) == Math.atan2(this.y2 - this.y1, this.x2 - this.x1)) {
                        return true;
                    }
                }
                return false;
            };
            /**
            * Get a string representation of the ray.
            * @method toString
            * @return {String}
            * @public
            */
            Ray.prototype.toString = function () {
                return "[{Ray (x1=" + this.x1 + " y1=" + this.y1 + " x2=" + this.x2 + " y2=" + this.y2 + ")}]";
            };
            return Ray;
        })(Geom.Line);
        Geom.Ray = Ray;
    })(Geom = Kiwi.Geom || (Kiwi.Geom = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Geom
*/
var Kiwi;
(function (Kiwi) {
    var Geom;
    (function (Geom) {
        /**
        * Contains a collection of STATIC methods for determining intersections between geometric objects.
        *
        * May methods contained here store the results of the intersections in a 'IntersectResult' Object,
        * which is either created for you (by the methods which require it) OR you can pass one to use instead.
        *
        * If you are using the Intersect methods a lot, you may want to consider
        * creating a IntersectResult class a reusing it (by passing it to the methods on the Intersect class)
        * instead of having new IntersectResults created.
        *
        * @class Intersect
        * @namespace Kiwi.Geom
        * @static
        */
        var Intersect = (function () {
            function Intersect() {
            }
            /**
            * The type of this object.
            * @method objType
            * @return {String} "Intersect"
            * @public
            */
            Intersect.prototype.objType = function () {
                return "Intersect";
            };
            /**
            * -------------------------------------------------------------------------------------------
            * Distance
            * -------------------------------------------------------------------------------------------
            **/
            /**
            * Returns the distance between two sets of coordinates that you specify.
            * @method distance
            * @param x1 {Number} The x position of the first coordinate.
            * @param y1 {Number} The y position of the first coordinate.
            * @param x2 {Number} The x position of the second coordinate.
            * @param y2 {Number} The y position of the second coordinate.
            * @return {Number} The distance between the two points.
            * @public
            * @static
            */
            Intersect.distance = function (x1, y1, x2, y2) {
                return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
            };
            /**
            * Returns the distance squared between two sets of coordinates that you specify.
            *
            * @method distanceSquared
            * @param x1 {Number} The x position of the first coordinate.
            * @param y1 {Number} The y position of the first coordinate.
            * @param x2 {Number} The x position of the second coordinate.
            * @param y2 {Number} The y position of the second coordinate.
            * @return {Number} The distance between the two points squared.
            * @public
            * @static
            */
            Intersect.distanceSquared = function (x1, y1, x2, y2) {
                return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
            };
            /**
            * ---------------------------------------------------------------------
            * Lines
            * ---------------------------------------------------------------------
            **/
            /**
            * Check to see if any two Lines intersect at any point.
            * Both lines are treated as if they extend infintely through space.
            *
            * @method lineToLine
            * @param line1 {Kiwi.Geom.Line} The first line object to check.
            * @param line2 {Kiwi.Geom.Line} The second line object to check.
            * @param [output] {Kiwi.Geom.IntersectResult} An optional
                IntersectResult object to store the intersection values in. One is
                created if none given.
            * @return {Kiwi.Geom.IntersectResult} An IntersectResult object
                containing the results of this intersection in x/y
            * @public
            * @static
            */
            Intersect.lineToLine = function (line1, line2, output) {
                if (output === void 0) { output = new Geom.IntersectResult; }
                output.result = false;
                var denom = (line1.x1 - line1.x2) * (line2.y1 - line2.y2) -
                    (line1.y1 - line1.y2) * (line2.x1 - line2.x2);
                if (denom !== 0) {
                    output.result = true;
                    output.x = ((line1.x1 * line1.y2 - line1.y1 * line1.x2) *
                        (line2.x1 - line2.x2) - (line1.x1 - line1.x2) *
                        (line2.x1 * line2.y2 - line2.y1 * line2.x2)) / denom;
                    output.y = ((line1.x1 * line1.y2 - line1.y1 * line1.x2) *
                        (line2.y1 - line2.y2) - (line1.y1 - line1.y2) *
                        (line2.x1 * line2.y2 - line2.y1 * line2.x2)) / denom;
                }
                return output;
            };
            /**
            * Check to see if a Line and a Line Segment intersect at any point.
            * Note: The first line passed is treated as if it extends infinitely
            * though space. The second is treated as if it only exists between
            * its two points.
            *
            * @method lineToLineSegment
            * @param line1 {Kiwi.Geom.Line} The first line to check.
                This is the one that will extend through space infinately.
            * @param seg {Kiwi.Geom.Line} The second line to check.
                This is the one that will only exist between its two coordinates.
            * @param [output] {Kiwi.Geom.IntersectResult} An optional
                IntersectResult object to store the intersection values in. One is
                created if none given.
            * @return {Kiwi.Geom.IntersectResult} An IntersectResult object
                containing the results of this intersection.
            * @public
            * @static
            */
            Intersect.lineToLineSegment = function (line1, seg, output) {
                if (output === void 0) { output = new Geom.IntersectResult; }
                output.result = false;
                var denom = (line1.x1 - line1.x2) * (seg.y1 - seg.y2) -
                    (line1.y1 - line1.y2) * (seg.x1 - seg.x2);
                if (denom !== 0) {
                    output.x = ((line1.x1 * line1.y2 - line1.y1 * line1.x2) *
                        (seg.x1 - seg.x2) - (line1.x1 - line1.x2) *
                        (seg.x1 * seg.y2 - seg.y1 * seg.x2)) / denom;
                    output.y = ((line1.x1 * line1.y2 - line1.y1 * line1.x2) *
                        (seg.y1 - seg.y2) - (line1.y1 - line1.y2) *
                        (seg.x1 * seg.y2 - seg.y1 * seg.x2)) / denom;
                    var maxX = Math.max(seg.x1, seg.x2);
                    var minX = Math.min(seg.x1, seg.x2);
                    var maxY = Math.max(seg.y1, seg.y2);
                    var minY = Math.min(seg.y1, seg.y2);
                    if ((output.x <= maxX && output.x >= minX) === true &&
                        (output.y <= maxY && output.y >= minY) === true) {
                        output.result = true;
                    }
                }
                return output;
            };
            /**
            * Checks to see if a Line that is passed, intersects at any point with a Line that is made by passing a set of coordinates to this method.
            * Note: The first line will extend infinately through space.
            * And the second line will only exist between the two points passed.
            *
            * @method lineToRawSegment
            * @param line {Kiwi.Geom.Line} The line object that extends infinitely through space.
            * @param x1 {number} The x coordinate of the first point in the second line.
            * @param y1 {number} The y coordinate of the first point in the second line.
            * @param x2 {number} The x coordinate of the second point in the second line.
            * @param y2 {number} The y coordinate of the second point in the second line.
            * @param [output] {Kiwi.Geom.IntersectResult} An optional IntersectResult object to store the intersection values in. One is created if none given.
            * @return {Kiwi.Geom.IntersectResult} An IntersectResult object containing the results of this intersection in x/y
            * @static
            * @public
            */
            Intersect.lineToRawSegment = function (line, x1, y1, x2, y2, output) {
                if (output === void 0) { output = new Geom.IntersectResult; }
                output.result = false;
                var denom = (line.x1 - line.x2) * (y1 - y2) - (line.y1 - line.y2) * (x1 - x2);
                if (denom !== 0) {
                    output.x = ((line.x1 * line.y2 - line.y1 * line.x2) * (x1 - x2) - (line.x1 - line.x2) * (x1 * y2 - y1 * x2)) / denom;
                    output.y = ((line.x1 * line.y2 - line.y1 * line.x2) * (y1 - y2) - (line.y1 - line.y2) * (x1 * y2 - y1 * x2)) / denom;
                    var maxX = Math.max(x1, x2);
                    var minX = Math.min(x1, x2);
                    var maxY = Math.max(y1, y2);
                    var minY = Math.min(y1, y2);
                    if (output.x <= maxX && output.x >= minX &&
                        output.y <= maxY && output.y >= minY) {
                        output.result = true;
                    }
                }
                return output;
            };
            /**
            * Checks to see if a Line that is passed intersects with a Line that is made by passing a set of coordinates to this method.
            * Note: The lines will only exist between the two points passed.
            *
            * @method lineSegmentToRawSegment
            * @param line {Kiwi.Geom.Line} The line object that extends infinitely through space.
            * @param x1 {number} The x coordinate of the first point in the second line.
            * @param y1 {number} The y coordinate of the first point in the second line.
            * @param x2 {number} The x coordinate of the second point in the second line.
            * @param y2 {number} The y coordinate of the second point in the second line.
            * @param [output] {Kiwi.Geom.IntersectResult} An optional IntersectResult object to store the intersection values in. One is created if none given.
            * @return {Kiwi.Geom.IntersectResult} An IntersectResult object containing the results of this intersection in x/y
            * @static
            * @public
            */
            Intersect.lineSegmentToRawSegment = function (line, x1, y1, x2, y2, output) {
                if (output === void 0) { output = new Geom.IntersectResult; }
                // Determine whether the line intersects the raw segment
                output = Intersect.lineToRawSegment(line, x1, y1, x2, y2, output);
                // Determine whether the intersection point is within the line segment
                var maxX = Math.max(line.x1, line.x2);
                var minX = Math.min(line.x1, line.x2);
                var maxY = Math.max(line.y1, line.y2);
                var minY = Math.min(line.y1, line.y2);
                if (output.x <= maxX && output.x >= minX && output.y <= maxY && output.y >= minY) {
                    return output;
                }
                // Intersection point isn't within the line segment
                output.result = false;
                return output;
            };
            /**
            * Checks to see if a Line and Ray object intersects at any point.
            * Note: The line in this case extends infinately through space.
            *
            * @method lineToRay
            * @param line1 {Kiwi.Geom.Line} The Line object that extends infinatly through space.
            * @param ray {Kiwi.Geom.Ray} The Ray object that you want to check it against.
            * @param [output] {Kiwi.Geom.IntersectResult} An optional IntersectResult object to store the intersection values in. One is created if none given.
            * @return {Kiwi.Geom.IntersectResult} An IntersectResult object containing the results of this intersection in x/y
            * @public
            * @static
            */
            Intersect.lineToRay = function (line1, ray, output) {
                if (output === void 0) { output = new Geom.IntersectResult; }
                output.result = false;
                var denom = (line1.x1 - line1.x2) * (ray.y1 - ray.y2) - (line1.y1 - line1.y2) * (ray.x1 - ray.x2);
                if (denom !== 0) {
                    output.x = ((line1.x1 * line1.y2 - line1.y1 * line1.x2) * (ray.x1 - ray.x2) - (line1.x1 - line1.x2) * (ray.x1 * ray.y2 - ray.y1 * ray.x2)) / denom;
                    output.y = ((line1.x1 * line1.y2 - line1.y1 * line1.x2) * (ray.y1 - ray.y2) - (line1.y1 - line1.y2) * (ray.x1 * ray.y2 - ray.y1 * ray.x2)) / denom;
                    output.result = true; // true unless either of the 2 following conditions are met
                    if (!(ray.x1 >= ray.x2) && output.x < ray.x1) {
                        output.result = false;
                    }
                    if (!(ray.y1 >= ray.y2) && output.y < ray.y1) {
                        output.result = false;
                    }
                }
                return output;
            };
            /**
            * Checks to see if a Line and a Circle intersect at any point.
            * Note: The line passed is assumed to extend infinately through space.
            *
            * @method lineToCircle
            * @param line {Kiwi.Geom.Line} The Line object that you want to check it against.
            * @param circle {Kiwi.Geom.Circle} The Circle object to check.
            * @param [output] {IntersectResult} An optional IntersectResult object to store the intersection values in. One is created if none given.
            * @return {Kiwi.Geom.IntersectResult} An IntersectResult object containing the results of this intersection
            * @public
            * @static
            */
            Intersect.lineToCircle = function (line, circle, output) {
                if (output === void 0) { output = new Geom.IntersectResult; }
                output.result = false;
                //  Get a perpendicular line running to the center of the circle
                if (line.perp(circle.x, circle.y).length <= circle.radius) {
                    output.result = true;
                }
                return output;
            };
            /**
            * Check if the Line intersects with each side of a Rectangle.
            * Note: The Line is assumned to extend infinately through space.
            *
            * @method lineToRectangle
            * @param line {Kiwi.Geom.Line} The Line object to check
            * @param rectangle {Kiwi.Geom.Rectangle} The Rectangle object to check
            * @param [output] {Kiwi.Geom.IntersectResult} An optional IntersectResult object to store the intersection values in. One is created if none given.
            * @return {Kiwi.Geom.IntersectResult} An IntersectResult object containing the results of this intersection
            * @public
            * @static
            */
            Intersect.lineToRectangle = function (line, rect, output) {
                if (output === void 0) { output = new Geom.IntersectResult; }
                output.result = false;
                //  Top of the Rectangle vs the Line
                Intersect.lineToRawSegment(line, rect.x, rect.y, rect.right, rect.y, output);
                if (output.result === true) {
                    return output;
                }
                //  Left of the Rectangle vs the Line
                Intersect.lineToRawSegment(line, rect.x, rect.y, rect.x, rect.bottom, output);
                if (output.result === true) {
                    return output;
                }
                //  Bottom of the Rectangle vs the Line
                Intersect.lineToRawSegment(line, rect.x, rect.bottom, rect.right, rect.bottom, output);
                if (output.result === true) {
                    return output;
                }
                //  Right of the Rectangle vs the Line
                Intersect.lineToRawSegment(line, rect.right, rect.y, rect.right, rect.bottom, output);
                return output;
            };
            /**
            * ---------------------------------------------------------------------
            * Line Segment
            * ---------------------------------------------------------------------
            **/
            /**
            * Checks to see if two Line Segments intersect at any point in space.
            * Note: Both lines are treated as if they only exist between their two
            * line coordinates.
            *
            * @method lineSegmentToLineSegment
            * @param line1 {Kiwi.Geom.Line} The first line object to check.
            * @param line2 {Kiwi.Geom.Line} The second line object to check.
            * @param [output]{Kiwi.Geom.IntersectResult} An optional
                IntersectResult object to store the intersection values in.
                One is created if none given.
            * @return {Kiwi.Geom.IntersectResult} An IntersectResult object
                containing the results of this intersection in x/y.
            * @public
            * @static
            */
            Intersect.lineSegmentToLineSegment = function (line1, line2, output) {
                if (output === void 0) { output = new Geom.IntersectResult; }
                output.result = false;
                Intersect.lineToLineSegment(line1, line2, output);
                if (output.result === true) {
                    if (!(output.x >= Math.min(line1.x1, line1.x2) &&
                        output.x <= Math.max(line1.x1, line1.x2) &&
                        output.y >= Math.min(line1.y1, line1.y2) &&
                        output.y <= Math.max(line1.y1, line1.y2))) {
                        output.result = false;
                    }
                }
                return output;
            };
            /**
            * Check if the Line Segment intersects with the Ray.
            * Note: The Line only exists between its two points.
            *
            * @method lineSegmentToRay
            * @param line1 {Kiwi.Geom.Line} The Line object to check.
            * @param ray {Kiwi.Geom.Line} The Ray object to check.
            * @param [output] {Kiwi.Geom.IntersectResult} An optional IntersectResult object to store the intersection values in. One is created if none given.
            * @return {Kiwi.Geom.IntersectResult} An IntersectResult object containing the results of this intersection in x/y
            * @public
            * @static
            */
            Intersect.lineSegmentToRay = function (line1, ray, output) {
                if (output === void 0) { output = new Geom.IntersectResult; }
                output.result = false;
                Intersect.lineToRay(line1, ray, output);
                if (output.result === true) {
                    if (!(output.x >= Math.min(line1.x1, line1.x2) && output.x <= Math.max(line1.x1, line1.x2)
                        && output.y >= Math.min(line1.y1, line1.y2) && output.y <= Math.max(line1.y1, line1.y2))) {
                        output.result = false;
                    }
                }
                return output;
            };
            /**
            * Check if the Line Segment intersects with the Circle.
            * Note the Line only exists between its point points.
            *
            * @method lineSegmentToCircle
            * @param seg {Kiwi.Geom.Line} The Line object to check
            * @param circle {Kiwi.Geom.Circle} The Circle object to check
            * @param [ouput] {Kiwi.Geom.IntersectResult} An optional IntersectResult object to store the intersection values in. One is created if none given.
            * @return {Kiwi.Geom.IntersectResult} An IntersectResult object containing the results of this intersection in x/y
            * @public
            * @static
            */
            Intersect.lineSegmentToCircle = function (seg, circle, output) {
                if (output === void 0) { output = new Geom.IntersectResult; }
                output.result = false;
                var perp = seg.perp(circle.x, circle.y);
                if (perp.length <= circle.radius) {
                    //  Line intersects circle - check if segment does
                    var maxX = Math.max(seg.x1, seg.x2);
                    var minX = Math.min(seg.x1, seg.x2);
                    var maxY = Math.max(seg.y1, seg.y2);
                    var minY = Math.min(seg.y1, seg.y2);
                    if ((perp.x2 <= maxX && perp.x2 >= minX) && (perp.y2 <= maxY && perp.y2 >= minY)) {
                        output.result = true;
                    }
                    else {
                        //  Worst case - segment doesn't traverse center, so no perpendicular connection.
                        if (Intersect.circleContainsPoint(circle, { x: seg.x1, y: seg.y1 }).result ||
                            Intersect.circleContainsPoint(circle, { x: seg.x2, y: seg.y2 }).result) {
                            output.result = true;
                        }
                    }
                }
                return output;
            };
            /**
            * Check if the Line Segment intersects with any side of a Rectangle,
            * or is entirely within the Rectangle.
            * Note: The Line only exists between its two points.
            *
            * @method lineSegmentToRectangle
            * @param seg {Kiwi.Geom.Line} The Line object to check.
            * @param rect {Kiwi.Geom.Rectangle} The Rectangle object to check.
            * @param [output] {Kiwi.Geom.IntersectResult} An optional IntersectResult object to store the intersection values in. One is created if none given.
            * @return {Kiwi.Geom.IntersectResult} An IntersectResult object containing the results of this intersection in x/y.
            * @public
            * @static
            */
            Intersect.lineSegmentToRectangle = function (seg, rect, output) {
                if (output === void 0) { output = new Geom.IntersectResult; }
                output.result = false;
                if (rect.contains(seg.x1, seg.y1) && rect.contains(seg.x2, seg.y2)) {
                    // Rectangle completely encloses Line; report back line centroid
                    output.x = (seg.x1 + seg.x2) / 2;
                    output.y = (seg.y1 + seg.y2) / 2;
                    output.result = true;
                }
                else {
                    //  Top of the Rectangle vs the Line
                    Intersect.lineSegmentToRawSegment(seg, rect.x, rect.y, rect.right, rect.y, output);
                    if (output.result === true) {
                        return output;
                    }
                    //  Left of the Rectangle vs the Line
                    Intersect.lineSegmentToRawSegment(seg, rect.x, rect.y, rect.x, rect.bottom, output);
                    if (output.result === true) {
                        return output;
                    }
                    //  Bottom of the Rectangle vs the Line
                    Intersect.lineSegmentToRawSegment(seg, rect.x, rect.bottom, rect.right, rect.bottom, output);
                    if (output.result === true) {
                        return output;
                    }
                    //  Right of the Rectangle vs the Line
                    Intersect.lineSegmentToRawSegment(seg, rect.right, rect.y, rect.right, rect.bottom, output);
                }
                return output;
            };
            /**
            * -------------------------------------------------------------------------------------------
            * Ray
            * -------------------------------------------------------------------------------------------
            **/
            /**
            * Check to see if a Ray intersects at any point with a Circle.
            *
            * @method rayToCircle
            * @param ray {Kiwi.Geom.Ray} Ray object to check
            * @param circle {Kiwi.Geom.Circle} Circle object to check
            * @param [output] {Kiwi.Geom.IntersectResult} Optional object
            *	to store the intersection values. Created if not supplied.
            * @return {Kiwi.Geom.IntersectResult} Results of this intersection
            * @public
            * @static
            */
            Intersect.rayToCircle = function (ray, circle, output) {
                if (output === void 0) { output = new Geom.IntersectResult; }
                var dx = circle.x - ray.x1, dy = circle.y - ray.y1;
                output.result = false;
                // Does the Ray begin within the Circle?
                if (Math.sqrt(dx * dx + dy * dy) <= circle.radius) {
                    output.result = true;
                    return output;
                }
                // Is the Ray aiming towards the Circle?
                if (Math.abs(Kiwi.Utils.GameMath.nearestAngleBetween(ray.angle, Math.atan2(dy, dx))) >= Math.PI / 2) {
                    return output;
                }
                // Inefficient, but the quickest way to get Line functions on a Ray
                Intersect.lineToCircle(ray, circle, output);
                return output;
            };
            /**
            * Check to see if a Ray intersects at any point with a Rectangle.
            *
            * @method rayToRectangle
            * @param ray {Kiwi.Geom.Ray} The Ray object to check.
            * @param rect {Kiwi.Geom.Rectangle} The Rectangle to check.
            * @param [output] {Kiwi.Geom.IntersectResult} An optional IntersectResult object to store the intersection values in. One is created if none given.
            * @return {Kiwi.Geom.IntersectResult} An IntersectResult object containing the results of this intersection
            * @public
            * @static
            */
            Intersect.rayToRectangle = function (ray, rect, output) {
                if (output === void 0) { output = new Geom.IntersectResult; }
                output.result = false;
                //  Currently just finds first intersection - might not be closest to ray pt1
                Intersect.lineToRectangle(ray, rect, output);
                return output;
            };
            /**
            * Check whether a Ray intersects a Line segment, returns the parametric value where the intersection occurs.
            * Note: The Line only exists between its two points.
            *
            * @method rayToLineSegment
            * @static
            * @param rayx1 {Number} The origin point of the ray on the x axis.
            * @param rayy1 {Number} The origin point of the ray on the y axis.
            * @param rayx2 {Number} The direction of the ray on the x axis.
            * @param rayy2 {Number} The direction of the ray on the y axis.
            * @param linex1 {Number} The x of the first point of the line segment.
            * @param liney1 {Number} The y of the first point of the line segment.
            * @param linex2 {Number} The x of the second point of the line segment.
            * @param liney2 {Number} The y of the second point of the line segment.
            * @param [output] {Kiwi.Geom.IntersectResult} An optional IntersectResult object to store the intersection values in. One is created if none given.
            * @return {Kiwi.Geom.IntersectResult} An IntersectResult object containing the results of this intersection stored in x
            * @public
            */
            Intersect.rayToLineSegment = function (rayx1, rayy1, rayx2, rayy2, linex1, liney1, linex2, liney2, output) {
                if (output === void 0) { output = new Geom.IntersectResult; }
                output.result = false;
                var r, s, d;
                // Check lines are not parallel
                if ((rayy2 - rayy1) / (rayx2 - rayx1) != (liney2 - liney1) / (linex2 - linex1)) {
                    d = (((rayx2 - rayx1) * (liney2 - liney1)) - (rayy2 - rayy1) * (linex2 - linex1));
                    if (d != 0) {
                        r = (((rayy1 - liney1) * (linex2 - linex1)) - (rayx1 - linex1) * (liney2 - liney1)) / d;
                        s = (((rayy1 - liney1) * (rayx2 - rayx1)) - (rayx1 - linex1) * (rayy2 - rayy1)) / d;
                        if (r >= 0) {
                            if (s >= 0 && s <= 1) {
                                output.result = true;
                                output.x = rayx1 + r * (rayx2 - rayx1), rayy1 + r * (rayy2 - rayy1);
                            }
                        }
                    }
                }
                return output;
            };
            /**
            * -------------------------------------------------------------------------------------------
            * Circle
            * -------------------------------------------------------------------------------------------
            **/
            /**
            * Check if the two given Circle objects intersect at any point.
            *
            * @method circleToCircle
            * @param circle1 {Kiwi.Geom.Circle} The first circle object to check.
            * @param circle2 {Kiwi.Geom.Circle} The second circle object to check.
            * @param [output] {Kiwi.Geom.IntersectResult} An optional IntersectResult object to store the intersection values in. One is created if none given.
            * @return {Kiwi.Geom.IntersectResult} An IntersectResult object containing the results of this intersection
            * @public
            * @static
            */
            Intersect.circleToCircle = function (circle1, circle2, output) {
                if (output === void 0) { output = new Geom.IntersectResult; }
                output.result = false;
                output.result = ((circle1.radius + circle2.radius) * (circle1.radius + circle2.radius)) >= Intersect.distanceSquared(circle1.x, circle1.y, circle2.x, circle2.y);
                return output;
            };
            /**
            * Check if a Circle and a Rectangle intersect with each other at any point.
            *
            * @method circleToRectangle
            * @param circle {Kiwi.Geom.Circle} The circle object to check.
            * @param rect {Kiwi.Geom.Rectangle} The Rectangle object to check.
            * @param [output] {Kiwi.Geom.IntersectResult} An optional IntersectResult object to store the intersection values in. One is created if none given.
            * @return {Kiwi.Geom.IntersectResult} An IntersectResult object containing the results of this intersection
            * @public
            * @static
            */
            Intersect.circleToRectangle = function (circle, rect, output) {
                if (output === void 0) { output = new Geom.IntersectResult; }
                output.result = false;
                var cornerDistX, cornerDistY, circleRelativeX, circleRelativeY, halfRectWidth, halfRectHeight, rectRangeX, rectRangeY;
                // If circle is not in the rect X range, it can't overlap.
                halfRectWidth = rect.width / 2;
                circleRelativeX = Math.abs(circle.x - rect.x - halfRectWidth);
                rectRangeX = circle.radius + halfRectWidth;
                if (circleRelativeX > rectRangeX) {
                    output.result = false;
                    return output;
                }
                // If circle is not in the rect Y range, it can't overlap.
                halfRectHeight = rect.height / 2;
                circleRelativeY = Math.abs(circle.y - rect.y - halfRectHeight);
                rectRangeY = circle.radius + halfRectHeight;
                if (circleRelativeY > rectRangeY) {
                    output.result = false;
                    return output;
                }
                // If circle centroid is within the rect, it overlaps.
                if (circleRelativeX <= halfRectWidth ||
                    circleRelativeY <= rect.height / 2) {
                    output.result = true;
                    return output;
                }
                // Because relative coordinates are normalized, we can consider
                // a single ideal corner. If the circle centroid is within its
                // own radius of this ideal corner, it overlaps.
                cornerDistX = circleRelativeX - halfRectWidth;
                cornerDistY = circleRelativeY - halfRectHeight;
                output.result = cornerDistX * cornerDistX + cornerDistY * cornerDistY <=
                    circle.radius * circle.radius;
                return output;
            };
            /**
            * Check if the given Point is found within the given Circle.
            *
            * @method circleContainsPoint
            * @param circle {Kiwi.Geom.Circle} The circle object to check
            * @param point {Kiwi.Geom.Point} The point object to check
            * @param [output] {Kiwi.Geom.IntersectResult} An optional IntersectResult object to store the intersection values in. One is created if none given.
            * @return {Kiwi.Geom.IntersectResult} An IntersectResult object containing the results of this intersection
            * @public
            * @static
            */
            Intersect.circleContainsPoint = function (circle, point, output) {
                if (output === void 0) { output = new Geom.IntersectResult; }
                output.result = false;
                output.result = circle.radius * circle.radius >= Intersect.distanceSquared(circle.x, circle.y, point.x, point.y);
                return output;
            };
            /**
            * -------------------------------------------------------------------------------------------
            * Rectangles
            * -------------------------------------------------------------------------------------------
            **/
            /**
            * Determines whether the specified point is contained within a given Rectangle object.
            *
            * @method pointToRectangle
            * @param point {Kiwi.Geom.Point} The point object being checked.
            * @param rect {Kiwi.Geom.Rectangle} The rectangle object being checked.
            * @param [output] {Kiwi.Geom.IntersectResult}  An optional IntersectResult object to store the intersection values in. One is created if none given.
            * @return {Kiwi.Geom.IntersectResult} An IntersectResult object containing the results of this intersection in x/y/result
            * @public
            * @static
            */
            Intersect.pointToRectangle = function (point, rect, output) {
                if (output === void 0) { output = new Geom.IntersectResult; }
                output.result = false;
                output.setTo(point.x, point.y);
                output.result = rect.containsPoint(point);
                return output;
            };
            /**
            * Check whether two axis aligned rectangles intersect. Return the intersecting rectangle dimensions if they do.
            *
            * @method rectangleToRectangle
            * @param rect1 {Kiwi.Geom.Rectangle} The first Rectangle object.
            * @param rect2 {Kiwi.Geom.Rectangle} The second Rectangle object.
            * @param [output] {Kiwi.Geom.IntersectResult} An optional IntersectResult object to store the intersection values in. One is created if none given.
            * @return {Kiwi.Geom.IntersectResult} An IntersectResult object containing the results of this intersection in x/y/width/height
            * @public
            * @static
            */
            Intersect.rectangleToRectangle = function (rect1, rect2, output) {
                if (output === void 0) { output = new Geom.IntersectResult; }
                output.result = false;
                var leftX = Math.max(rect1.x, rect2.x);
                var rightX = Math.min(rect1.right, rect2.right);
                var topY = Math.max(rect1.y, rect2.y);
                var bottomY = Math.min(rect1.bottom, rect2.bottom);
                output.setTo(leftX, topY, rightX - leftX, bottomY - topY, rightX - leftX, bottomY - topY);
                var cx = output.x + output.width * .5;
                var cy = output.y + output.height * .5;
                if ((cx > rect1.x && cx < rect1.right) && (cy > rect1.y && cy < rect1.bottom)) {
                    output.result = true;
                }
                return output;
            };
            return Intersect;
        })();
        Geom.Intersect = Intersect;
    })(Geom = Kiwi.Geom || (Kiwi.Geom = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Geom
*/
var Kiwi;
(function (Kiwi) {
    var Geom;
    (function (Geom) {
        /**
        * A Lightweight object to hold the results of an Intersection.
        * Used in combination with the STATIC methods on the Intersect class.
        *
        * If you are using the Intersect methods a lot, you may want to consider
        * creating a IntersectResult class a reusing it (by passing it to the methods on the Intersect class)
        * instead of having new IntersectResults created.
        *
        *
        * @class IntersectResult
        * @namespace Kiwi.Geom
        * @constructor
        */
        var IntersectResult = (function () {
            function IntersectResult() {
                /**
                * Holds the result of an Intersection between two geometric items.
                * TRUE means an Intersection did occur and FALSE means not.
                * @property result
                * @type boolean
                * @default false
                * @public
                */
                this.result = false;
            }
            /**
            * The type of object this is.
            * @method objType
            * @return {String} "IntersectResult"
            * @public
            */
            IntersectResult.prototype.objType = function () {
                return "IntersectResult";
            };
            /**
            * Sets the coordinates of the points based on the parameters passed.
            * @method setTo
            * @param {Number} x1
            * @param {Number} y1
            * @param {Number} [x2=0]
            * @param {Number} [y2=0]
            * @param {Number} [width=0]
            * @param {Number} [height=0]
            * @public
            */
            IntersectResult.prototype.setTo = function (x1, y1, x2, y2, width, height) {
                if (x2 === void 0) { x2 = 0; }
                if (y2 === void 0) { y2 = 0; }
                if (width === void 0) { width = 0; }
                if (height === void 0) { height = 0; }
                this.x = x1;
                this.y = y1;
                this.x1 = x1;
                this.y1 = y1;
                this.x2 = x2;
                this.y2 = y2;
                this.width = width;
                this.height = height;
            };
            return IntersectResult;
        })();
        Geom.IntersectResult = IntersectResult;
    })(Geom = Kiwi.Geom || (Kiwi.Geom = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Geom
*/
var Kiwi;
(function (Kiwi) {
    var Geom;
    (function (Geom) {
        /**
        * Represents a 2d transformation matrix. This can be used to map points
        * between different coordinate spaces. Matrices are used by Transform
        * objects to represent translation, scale and rotation transformations,
        * and to determine where objects are in world space or camera space.
        * Objects such as entities and groups may be nested, and their associated
        * transforms may represent how they are scaled, translated and rotated
        * relative to a parent transform. By concatenating an object's
        * transformation matrix with its ancestors matrices, it is possible to
        * determine the absolute position of the object in world space.
        * See
        * http://en.wikipedia.org/wiki/Transformation_matrix#Examples_in_2D_graphics
        * for an in depth discussion of 2d tranformation matrices.
        *
        * @class Matrix
        * @namespace Kiwi.Geom
        * @constructor
        * @param [a=1] {Number}  position 0,0 of the matrix,
        *	affects scaling and rotation.
        * @param [b=0] {Number}  position 0,1 of the matrix,
        *	affects scaling and rotation.
        * @param [c=0] {Number}  position 1,0 of the matrix,
        *	affects scaling and rotation.
        * @param [d=1] {Number}  position 1,1 of the matrix,
        *	affects scaling and rotation.
        * @param [tx=0] {Number}  position 2,0 of the matrix,
        *	affects translation on x axis.
        * @param [ty=0] {Number}  position 2,1 of the matrix,
        *	affects translation on y axis.
        * @return (Object) This object.
        *
        */
        var Matrix = (function () {
            function Matrix(a, b, c, d, tx, ty) {
                if (a === void 0) { a = 1; }
                if (b === void 0) { b = 0; }
                if (c === void 0) { c = 0; }
                if (d === void 0) { d = 1; }
                if (tx === void 0) { tx = 0; }
                if (ty === void 0) { ty = 0; }
                /**
                * Position 0,0 of the matrix, affects scaling and rotation
                * @property a
                * @type Number
                * @default 1
                * @public
                */
                this.a = 1;
                /**
                * Position 0,1 of the matrix, affects scaling and rotation.
                * @property b
                * @type Number
                * @default 0
                * @public
                */
                this.b = 0;
                /**
                * Position 1,0 of the matrix, affects scaling and rotation.
                * @property c
                * @type Number
                * @default 0
                * @public
                */
                this.c = 0;
                /**
                * Position 1,1 of the matrix, affects scaling and rotation.
                * @property d
                * @type Number
                * @default 1
                * @public
                */
                this.d = 1;
                /**
                * Position 2,0 of the matrix, affects translation on x axis.
                * @property tx
                * @type Number
                * @default 0
                * @public
                */
                this.tx = 0;
                /**
                * Position 2,1 of the matrix, affects translation on y axis.
                * @property ty
                * @type Number
                * @default 0
                * @public
                */
                this.ty = 0;
                this.setTo(a, b, c, d, tx, ty);
            }
            /**
            * The type of object this is.
            * @method objType
            * @return {String} "Matrix"
            * @public
            */
            Matrix.prototype.objType = function () {
                return "Matrix";
            };
            /**
            * Set all matrix values
            * @method setTo
            * @param [a=1] {Number} position 0,0 of the matrix, affects scaling and rotation.
            * @param [b=0] {Number} position 0,1 of the matrix, affects scaling and rotation.
            * @param [c=0] {Number} position 1,0 of the matrix, affects scaling and rotation.
            * @param [d=1] {Number} position 1,1 of the matrix, affects scaling and rotation.
            * @param [tx=0] {Number} position 2,0 of the matrix, affects translation on x axis.
            * @param [ty=0] {Number} position 2,1 of the matrix, affects translation on y axis.
            * @return {Kiwi.Geom.Matrix} This object.
            * @public
            */
            Matrix.prototype.setTo = function (a, b, c, d, tx, ty) {
                if (a === void 0) { a = 1; }
                if (b === void 0) { b = 0; }
                if (c === void 0) { c = 0; }
                if (d === void 0) { d = 1; }
                if (tx === void 0) { tx = 0; }
                if (ty === void 0) { ty = 0; }
                this.a = a;
                this.b = b;
                this.c = c;
                this.d = d;
                this.tx = tx;
                this.ty = ty;
                return this;
            };
            /**
            * Set matrix values from transform values
            * @method setFromTransform
            * @param tx {Number} Translation on x axis.
            * @param ty {Number} Translation on y axis.
            * @param scaleX {Number} scaleX. Scale on x axis.
            * @param scaleY {Number} scaleY. Scale on y axis.
            * @param rotation {Number} rotation.
            * @return {Kiwi.Geom.Matrix} This object.
            * @public
            */
            Matrix.prototype.setFromTransform = function (tx, ty, scaleX, scaleY, rotation) {
                this.identity();
                var cos = Math.cos(rotation);
                var sin = Math.sin(rotation);
                this.append(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, tx, ty);
                return this;
            };
            /**
            * Set matrix values from transform values, with rotation point data included
            * @method setFromOffsetTransform
            * @param tx {Number} tx. Translation on x axis.
            * @param ty {Number} ty. Translation on y axis.
            * @param scaleX {Number} scaleX. Scale on x axis.
            * @param scaleY {Number} scaleY. Scale on y axis.
            * @param rotation {Number} rotation.
            * @param rotPointX {Number} Rotation point offset on x axis.
            * @param rotPointY {Number} Rotation point offset on y axis.
            * @return {Kiwi.Geom.Matrix} This object.
            * @public
            * @since 1.0.1
            */
            Matrix.prototype.setFromOffsetTransform = function (tx, ty, scaleX, scaleY, rotation, rotPointX, rotPointY) {
                this.identity();
                var cos = Math.cos(rotation);
                var sin = Math.sin(rotation);
                this.append(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, tx + rotPointX, ty + rotPointY);
                return this;
            };
            /**
            * Prepend values to this matrix, paramters supplied individually.
            * @method prepend
            * @param [a=1]{Number} position 0,0 of the matrix, affects scaling and rotation.
            * @param [b=0]{Number} position 0,1 of the matrix, affects scaling and rotation.
            * @param [c=0]{Number} position 1,0 of the matrix, affects scaling and rotation.
            * @param [d=0]{Number} position 1,1 of the matrix, affects scaling and rotation.
            * @param [tx=0]{Number} position 2,0 of the matrix, affects translation on x axis.
            * @param [ty=0]{Number} position 2,1 of the matrix, affects translation on y axis.
            * @return {Kiwi.Geom.Matrix} This object.
            * @public
            */
            Matrix.prototype.prepend = function (a, b, c, d, tx, ty) {
                if (a === void 0) { a = 1; }
                if (b === void 0) { b = 0; }
                if (c === void 0) { c = 0; }
                if (d === void 0) { d = 1; }
                if (tx === void 0) { tx = 0; }
                if (ty === void 0) { ty = 0; }
                var tx1 = this.tx;
                var a1 = this.a;
                var c1 = this.c;
                this.a = a1 * a + this.b * c;
                this.b = a1 * b + this.b * d;
                this.c = c1 * a + this.d * c;
                this.d = c1 * b + this.d * d;
                this.tx = tx1 * a + this.ty * c + tx;
                this.ty = tx1 * b + this.ty * d + ty;
                return this;
            };
            /**
            * Prepend a matrix to this matrix.
            * @method prependMatrix
            * @param m {Kiwi.Geom.Matrix} The matrix to prepend.
            * @return {Kiwi.Geom.Matrix} This object.
            * @public
            */
            Matrix.prototype.prependMatrix = function (m) {
                var tx1 = this.tx;
                var a1 = this.a;
                var c1 = this.c;
                this.a = a1 * m.a + this.b * m.c;
                this.b = a1 * m.b + this.b * m.d;
                this.c = c1 * m.a + this.d * m.c;
                this.d = c1 * m.b + this.d * m.d;
                this.tx = tx1 * m.a + this.ty * m.c + m.tx;
                this.ty = tx1 * m.b + this.ty * m.d + m.ty;
                return this;
            };
            /**
            * Append values to this matrix, parameters supplied individually.
            * @method append
            * @param [a=1]{Number} position 0,0 of the matrix, affects scaling and rotation.
            * @param [b=0]{Number} position 0,1 of the matrix, affects scaling and rotation.
            * @param [c=0]{Number} position 1,0 of the matrix, affects scaling and rotation.
            * @param [d=1]{Number} position 1,1 of the matrix, affects scaling and rotation.
            * @param [tx=0]{Number} position 2,0 of the matrix, affects translation on x axis.
            * @param [ty=0]{Number} position 2,1 of the matrix, affects translation on y axis.
            * @return {Kiwi.Geom.Matrix} This object.
            * @public
            */
            Matrix.prototype.append = function (a, b, c, d, tx, ty) {
                if (a === void 0) { a = 1; }
                if (b === void 0) { b = 0; }
                if (c === void 0) { c = 0; }
                if (d === void 0) { d = 1; }
                if (tx === void 0) { tx = 0; }
                if (ty === void 0) { ty = 0; }
                var a1 = this.a;
                var b1 = this.b;
                var c1 = this.c;
                var d1 = this.d;
                this.a = a * a1 + b * c1;
                this.b = a * b1 + b * d1;
                this.c = c * a1 + d * c1;
                this.d = c * b1 + d * d1;
                this.tx = tx * a1 + ty * c1 + this.tx;
                this.ty = tx * b1 + ty * d1 + this.ty;
                return this;
            };
            /**
            * Append a matrix to this matrix.
            * @method appendMatrix
            * @param m {Kiwi.Geom.Matrix} The matrix to append.
            * @return {Kiwi.Geom.Matrix} This object.
            * @public
            */
            Matrix.prototype.appendMatrix = function (m) {
                var a1 = this.a;
                var b1 = this.b;
                var c1 = this.c;
                var d1 = this.d;
                this.a = m.a * a1 + m.b * c1;
                this.b = m.a * b1 + m.b * d1;
                this.c = m.c * a1 + m.d * c1;
                this.d = m.c * b1 + m.d * d1;
                this.tx = m.tx * a1 + m.ty * c1 + this.tx;
                this.ty = m.tx * b1 + m.ty * d1 + this.ty;
                return this;
            };
            /**
            * Set the tx and ty elements of the matrix.
            * @method setPosition
            * @param x {Number} Translation on x axis.
            * @param y {Number} Translation on y axis.
            * @return {Kiwi.Geom.Matrix} This object.
            * @public
            */
            Matrix.prototype.setPosition = function (x, y) {
                this.tx = x;
                this.ty = y;
                return this;
            };
            /**
            * Set the tx and ty elements of the matrix from an object with x and y properties.
            * @method setPositionPoint
            * @param p {Number} The object from which to copy the x and y properties from.
            * @return {Kiwi.Geom.Matrix} This object.
            * @public
            */
            Matrix.prototype.setPositionPoint = function (p) {
                this.tx = p.x;
                this.ty = p.y;
                return this;
            };
            /**
            * Get the x and y position of the matrix as an object with x and y properties
            * @method getPosition
            * @return {Kiwi.Geom.Point} An object constructed from a literal with x and y properties.
            * @public
            */
            Matrix.prototype.getPosition = function (output) {
                if (output === void 0) { output = new Kiwi.Geom.Point; }
                return output.setTo(this.tx, this.ty);
            };
            /**
            * Set the matrix to the identity matrix - when appending or prepending this matrix to another there will be no change in the resulting matrix
            * @method identity
            * @return {Kiwi.Geom.Matrix} This object.
            * @public
            */
            Matrix.prototype.identity = function () {
                this.a = 1;
                this.b = 0;
                this.c = 0;
                this.d = 1;
                this.tx = 0;
                this.ty = 0;
                return this;
            };
            /**
            * Rotate the matrix by "radians" degrees
            * @method rotate
            * @param radians {Number} The angle (in radians) to rotate this matrix by.
            * @return {Kiwi.Geom.Matrix} This object.
            * @public
            */
            Matrix.prototype.rotate = function (radians) {
                var cos = Math.cos(radians);
                var sin = Math.sin(radians);
                var a1 = this.a;
                var c1 = this.c;
                var tx1 = this.tx;
                this.a = a1 * cos - this.b * sin;
                this.b = a1 * sin + this.b * cos;
                this.c = c1 * cos - this.d * sin;
                this.d = c1 * sin + this.d * cos;
                this.tx = tx1 * cos - this.ty * sin;
                this.ty = tx1 * sin + this.ty * cos;
                return this;
            };
            /**
            * Translate the matrix by the amount passed.
            *
            * @method translate
            * @param tx {Number} The amount to translate on the x axis.
            * @param ty {Number} The amount to translate on the y axis.
            * @return {Kiwi.Geom.Matrix} This object.
            * @public
            */
            Matrix.prototype.translate = function (tx, ty) {
                this.tx += tx;
                this.ty += ty;
                return this;
            };
            /**
            * Scales the matrix by the amount passed.
            *
            * @method scale
            * @param scaleX {Number} The amount to scale on the x axis.
            * @param scaleY {Number} The amount to scale on the y axis.
            * @return {Kiwi.Geom.Matrix} This object.
            * @public
            */
            Matrix.prototype.scale = function (scaleX, scaleY) {
                this.a *= scaleX;
                this.d *= scaleY;
                return this;
            };
            /**
            * Apply this matrix to a an object with x and y properties representing a point and return the transformed point.
            * @method transformPoint
            * @param pt {Object} The point to be translated.
            * @return {Kiwi.Geom.Matrix} This object.
            * @public
            */
            Matrix.prototype.transformPoint = function (pt) {
                var x = pt.x;
                var y = pt.y;
                pt.x = this.a * x + this.c * y + this.tx;
                pt.y = this.b * x + this.d * y + this.ty;
                return pt;
            };
            /**
            * Invert this matrix so that it represents the opposite of its orginal tranformaation.
            * @method invert
            * @return {Kiwi.Geom.Matrix} This object.
            * @public
            */
            Matrix.prototype.invert = function () {
                var a1 = this.a;
                var b1 = this.b;
                var c1 = this.c;
                var d1 = this.d;
                var tx1 = this.tx;
                var n = a1 * d1 - b1 * c1;
                this.a = d1 / n;
                this.b = -b1 / n;
                this.c = -c1 / n;
                this.d = a1 / n;
                this.tx = (c1 * this.ty - d1 * tx1) / n;
                this.ty = -(a1 * this.ty - b1 * tx1) / n;
                return this;
            };
            /**
            * Copy another matrix to this matrix.
            * @method copyFrom
            * @param m {Kiwi.Geom.Matrix} The matrixto be copied from.
            * @return {Kiwi.Geom.Matrix} This object.
            * @public
            */
            Matrix.prototype.copyFrom = function (m) {
                this.a = m.a;
                this.b = m.b;
                this.c = m.c;
                this.d = m.d;
                this.tx = m.tx;
                this.ty = m.ty;
                return this;
            };
            /**
            * Copy this matrix to another matrix.
            * @method copyTo
            * @param m {Kiwi.Geom.Matrix} The matrix to copy to.
            * @return {Kiwi.Geom.Matrix} This object.
            * @public
            */
            Matrix.prototype.copyTo = function (m) {
                m.a = this.a;
                m.b = this.b;
                m.c = this.c;
                m.d = this.d;
                m.tx = this.tx;
                m.ty = this.ty;
                return this;
            };
            /**
            * Clone this matrix and returns a new Matrix object.
            * @method clone
            * @return {Kiwi.Geom.Matrix}
            * @public
            */
            Matrix.prototype.clone = function () {
                return new Kiwi.Geom.Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);
            };
            Object.defineProperty(Matrix.prototype, "toString", {
                /**
                * Returns a string representation of this object.
                * @method toString
                * @return {string} A string representation of the instance.
                * @public
                */
                get: function () {
                    return "[{Matrix (a=" + this.a + " b=" + this.b + " c=" + this.c + " d=" + this.d + " tx=" + this.tx + " ty=" + this.ty + ")}]";
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Check whether this matrix equals another matrix.
            *
            * @method equals
            * @param matrix {Kiwi.Geom.Matrix}
            * @return boolean
            * @public
            */
            Matrix.prototype.equals = function (matrix) {
                return (this.a === matrix.a &&
                    this.b === matrix.b &&
                    this.c === matrix.c &&
                    this.d === matrix.d &&
                    this.tx === matrix.tx &&
                    this.ty === matrix.ty);
            };
            return Matrix;
        })();
        Geom.Matrix = Matrix;
    })(Geom = Kiwi.Geom || (Kiwi.Geom = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Geom
*/
var Kiwi;
(function (Kiwi) {
    var Geom;
    (function (Geom) {
        /**
        * Represents a location in a two-dimensional coordinate system, where x represents the horizontal axis and y represents the vertical axis.
        *
        * @class Point
        * @constructor
        * @namespace Kiwi.Geom
        * @param [x=0] {Number} Position of this point on the x-axis.
        * @param [y=0] {Number} Position of this point on the y-axis.
        *
        */
        var Point = (function () {
            function Point(x, y) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                this.setTo(x, y);
            }
            /**
            * The type of this object.
            * @method objType
            * @return {String} "Point"
            * @public
            */
            Point.prototype.objType = function () {
                return "Point";
            };
            /**
            * Converts a pair of polar coordinates to a Cartesian point coordinate and sets them on the point instance.
            * @method polar
            * @param length {Number} The length coordinate of the polar pair.
            * @param angle {Number} The angle, in radians, of the polar pair.
            * @return {Kiwi.Geom.Point} The new Cartesian Point object.
            * @public
            */
            Point.prototype.polar = function (distance, angle) {
                //Note: Would be badarse if it did this based on the current x/y coordinates
                this.x = distance * Math.cos(angle);
                this.y = distance * Math.sin(angle);
                return this;
            };
            /**
            * Adds the coordinates of another point to the coordinates of this point to create a new point.
            * @method add
            * @param toAdd {Kiwi.Geom.Point} The point to be added.
            * @param output {Kiwi.Geom.Point}
            * @return {Kiwi.Geom.Point} The new Point object.
            * @public
            */
            Point.prototype.add = function (toAdd, output) {
                if (output === void 0) { output = new Point; }
                return output.setTo(this.x + toAdd.x, this.y + toAdd.y);
            };
            /**
            * Adds the given values to the coordinates of this point and returns it
            * @method addTo
            * @param x {Number} The amount to add to the x value of the point
            * @param y {Number} The amount to add to the x value of the point
            * @return {Kiwi.Geom.Point} This Point object.
            * @public
            */
            Point.prototype.addTo = function (x, y) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                return this.setTo(this.x + x, this.y + y);
            };
            /**
            * Adds the given values to the coordinates of this point and returns it
            * @method subtractFrom
            * @param x {Number} The amount to subtract from the x value of the point
            * @param y {Number} The amount to subtract from the x value of the point
            * @return {Kiwi.Geom.Point} This Point object.
            * @public
            */
            Point.prototype.subtractFrom = function (x, y) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                return this.setTo(this.x - x, this.y - y);
            };
            /**
            * Inverts the x and y values of this point
            * @method invert
            * @return {Kiwi.Geom.Point} This Point object.
            * @public
            */
            Point.prototype.invert = function () {
                return this.setTo(this.y, this.x);
            };
            /**
            * Clamps this Point object to be between the given min and max.
            * @method clamp
            * @param min {number} The minimum value to clamp this Point to.
            * @param max {number} The maximum value to clamp this Point to.
            * @return {Kiwi.Geom.Point} This Point object.
            * @public
            */
            Point.prototype.clamp = function (min, max) {
                this.clampX(min, max);
                this.clampY(min, max);
                return this;
            };
            /**
            * Clamps the x value of this Point object to be between the given min and max
            * @method clampX
            * @param min {Number} The minimum value to clamp this Point to
            * @param max {Number} The maximum value to clamp this Point to
            * @return {Kiwi.Geom.Point} This Point object.
            * @public
            */
            Point.prototype.clampX = function (min, max) {
                this.x = Math.max(Math.min(this.x, max), min);
                return this;
            };
            /**
            * Clamps the y value of this Point object to be between the given min and max
            * @method clampY
            * @param min {Number} The minimum value to clamp this Point to
            * @param max {Number} The maximum value to clamp this Point to
            * @return {Kiwi.Geom.Point} This Point object.
            * @public
            */
            Point.prototype.clampY = function (min, max) {
                this.x = Math.max(Math.min(this.x, max), min);
                this.y = Math.max(Math.min(this.y, max), min);
                return this;
            };
            /**
            * Creates a copy of this Point.
            * @method clone
            * @param [output] {Kiwi.Geom.Point} Optional Point object. If given the values will be set into this object, otherwise a new Point object will be created.
            * @return {Kiwi.Geom.Point}
            * @public
            */
            Point.prototype.clone = function (output) {
                if (output === void 0) { output = new Point; }
                return output.setTo(this.x, this.y);
            };
            /**
            * Copies the point data from the source Point object into this Point object.
            * @method copyFrom
            * @param source {Kiwi.Geom.Point} The point to copy from.
            * @return {Kiwi.Geom.Point} This Point object. Useful for chaining method calls.
            * @public
            */
            Point.prototype.copyFrom = function (source) {
                return this.setTo(source.x, source.y);
            };
            /**
            * Copies the point data from this Point object to the given target Point object.
            * @method copyTo
            * @param target {Kiwi.Geom.Point} target - The point to copy to.
            * @return {Kiwi.Geom.Point} The target Point object.
            * @public
            */
            Point.prototype.copyTo = function (target) {
                return target.setTo(this.x, this.y);
            };
            /**
            * Get the angle from this Point object to given Point object.
            * @method angleTo
            * @param target {Kiwi.Geom.Point} destination Point object.
            * @return {Number} angle to point
            * @public
            */
            Point.prototype.angleTo = function (target) {
                //Y then X ....cause JavaScript :P
                return Math.atan2(target.y - this.y, target.x - this.x);
            };
            /**
            * Get the angle from this Point object to given X,Y coordinates.
            * @method angleToXY
            * @param x {Number} x value.
            * @param y {Number} y value.
            * @return {Number} angle to point.
            */
            Point.prototype.angleToXY = function (x, y) {
                //Y then X ....cause JavaScript :P
                return Math.atan2(y - this.y, x - this.x);
            };
            /**
            * Returns the distance from this Point object to the given Point object.
            * @method distanceTo
            * @param target {Kiwi.Geom.Point} The destination Point object.
            * @param round {boolean} Round the distance to the nearest integer (default false)
            * @return {Number} The distance between this Point object and the destination Point object.
            * @public
            */
            Point.prototype.distanceTo = function (target, round) {
                if (round === void 0) { round = false; }
                var dx = this.x - target.x;
                var dy = this.y - target.y;
                if (round === true) {
                    return Math.round(Math.sqrt(dx * dx + dy * dy));
                }
                else {
                    return Math.sqrt(dx * dx + dy * dy);
                }
            };
            /**
            * Returns the distance from this Point object to the given Point object.
            * @method distanceToXY
            * @param x {Number} The x value.
            * @param y {Number} The y value.
            * @param [round=false] {boolean} Round the distance to the nearest integer (default false)
            * @return {Number} The distance between this Point object and the x/y values.
            * @public
            */
            Point.prototype.distanceToXY = function (x, y, round) {
                if (round === void 0) { round = false; }
                var dx = this.x - x;
                var dy = this.y - y;
                if (round === true) {
                    return Math.round(Math.sqrt(dx * dx + dy * dy));
                }
                else {
                    return Math.sqrt(dx * dx + dy * dy);
                }
            };
            /**
            * Returns the distance between the two Point objects.
            * @method distanceBetween
            * @param pointA {Kiwi.Geom.Point} The first Point object.
            * @param pointB {Kiwi.Geom.Point} The second Point object.
            * @param [round=false] {boolean} Round the distance to the nearest integer (default false)
            * @return {Number} The distance between the two Point objects.
            * @public
            */
            Point.distanceBetween = function (pointA, pointB, round) {
                if (round === void 0) { round = false; }
                var dx = pointA.x - pointB.x;
                var dy = pointA.y - pointB.y;
                if (round === true) {
                    return Math.round(Math.sqrt(dx * dx + dy * dy));
                }
                else {
                    return Math.sqrt(dx * dx + dy * dy);
                }
            };
            /**
            * Creates a new point with cartesian coordinates from a pair of polar coordinates
            * @method polar
            * @param length {Number} The length coordinate of the polar pair.
            * @param angle {Number} The angle, in radians, of the polar pair.
            * @return {Kiwi.Geom.Point} The new Cartesian Point object.
            * @public
            */
            Point.polar = function (length, angle) {
                return new Point(length * Math.cos(angle), length * Math.sin(angle));
            };
            /**
            * Returns true if the distance between this point and a target point is greater than or equal a specified distance.
            * This avoids using a costly square root operation
            * @method distanceCompare
            * @param target {Kiwi.Geom.Point} The Point object to use for comparison.
            * @param distance {Number} The distance to use for comparison.
            * @return {Boolean} True if distance is >= specified distance.
            * @public
            */
            Point.prototype.distanceCompare = function (target, distance) {
                if (this.distanceTo(target) >= distance) {
                    return true;
                }
                else {
                    return false;
                }
            };
            /**
            * Determines whether this Point object and the given point object are equal. They are equal if they have the same x and y values.
            * @method equals
            * @param point {Kiwi.Geom.Point} The point to compare against.
            * @return {boolean} A value of true if the object is equal to this Point object; false if it is not equal.
            * @public
            */
            Point.prototype.equals = function (toCompare) {
                if (this.x === toCompare.x && this.y === toCompare.y) {
                    return true;
                }
                else {
                    return false;
                }
            };
            /**
            * Determines a point between two specified points.
            * The parameter f determines where the new interpolated point is located relative to the two end points specified by parameters pt1 and pt2.
            *
            * The closer the value of the parameter f is to 1.0,
            * the closer the interpolated point is to the first point (parameter pt1).
            * The closer the value of the parameter f is to 0, the closer the interpolated point is to the second point (parameter pt2).
            *
            * @method interpolate
            * @param pointA{Kiwi.Geom.Point} The first Point object.
            * @param pointB {Kiwi.Geom.Point} The second Point object.
            * @param f {Number} The level of interpolation between the two points. Indicates where the new point will be, along the line between pt1 and pt2. If f=1, pt1 is returned; if f=0, pt2 is returned.
            * @return {Kiwi.Geom.Point} The new interpolated Point object.
            * @public
            */
            Point.interpolate = function (pointA, pointB, f) {
                var xDiff = pointB.x - pointA.x;
                var yDiff = pointB.y - pointA.y;
                return new Point(pointB.x - xDiff * f, pointB.y - yDiff * f);
            };
            /**
            * Offsets the Point object by the specified amount. The value of dx is added to the original value of x to create the new x value.
            * The value of dy is added to the original value of y to create the new y value.
            *
            * @method offset
            * @param dx {Number} The amount by which to offset the horizontal coordinate, x.
            * @param dy {Number} The amount by which to offset the vertical coordinate, y.
            * @return {Kiwi.Geom.Point} This Point object. Useful for chaining method calls.
            * @public
            */
            Point.prototype.offset = function (dx, dy) {
                this.x += dx;
                this.y += dy;
                return this;
            };
            /**
            * Sets the x and y values of this Point object to the given coordinates.
            * @method setTo
            * @param x {Number} The horizontal position of this point.
            * @param y {Number} The vertical position of this point.
            * @return {Kiwi.Geom.Point} This Point object. Useful for chaining method calls.
            * @public
            */
            Point.prototype.setTo = function (x, y) {
                this.x = x;
                this.y = y;
                return this;
            };
            /**
            * Subtracts the coordinates of another point from the coordinates of this point to create a new point.
            * @method subtract
            * @param point {Kiwi.Geom.Point} The point to be subtracted.
            * @param output {Kiwi.Geom.Point} Optional Point object. If given the values will be set into this object, otherwise a brand new Point object will be created and returned.
            * @return {Kiwi.Geom.Point} The new Point object.
            * @public
            */
            Point.prototype.subtract = function (point, output) {
                if (output === void 0) { output = new Point; }
                return output.setTo(this.x - point.x, this.y - point.y);
            };
            Point.prototype.getCSS = function () {
                return this.x + 'px ' + this.y + 'px';
            };
            /**
            * Returns a string representation of this object.
            * @method toString
            * @return {String} a string representation of the instance.
            * @public
            */
            Point.prototype.toString = function () {
                return '[{Point (x=' + this.x + ' y=' + this.y + ')}]';
            };
            return Point;
        })();
        Geom.Point = Point;
    })(Geom = Kiwi.Geom || (Kiwi.Geom = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Geom
*/
var Kiwi;
(function (Kiwi) {
    var Geom;
    (function (Geom) {
        /**
        * An area defined by its position, as indicated by its top-left corner (x,y) and width and height
        *
        * @class Rectangle
        * @namespace Kiwi.Geom
        * @constructor
        * @param [x=0] {Number} The x coordinate of the top-left corner of the rectangle.
        * @param [y=0] {Number} The y coordinate of the top-left corner of the rectangle.
        * @param [width=0] {Number} width The width of the rectangle in pixels.
        * @param [height=0] {Number} height The height of the rectangle in pixels.
        * @return {Kiwi.Geom.Rectangle} This rectangle object
        *
        */
        var Rectangle = (function () {
            /**
            * Creates a new Rectangle object with the top-left corner specified by the x and y parameters and with the specified width and height parameters. If you call this function without parameters, a rectangle with x, y, width, and height properties set to 0 is created.
            **/
            function Rectangle(x, y, width, height) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (width === void 0) { width = 0; }
                if (height === void 0) { height = 0; }
                /**
                * The x coordinate of the top-left corner of the rectangle
                * @property x
                * @type Number
                * @default 0
                * @public
                */
                this.x = 0;
                /**
                * The y coordinate of the top-left corner of the rectangle
                * @property y
                * @type Number
                * @default 0
                * @public
                */
                this.y = 0;
                /**
                * The width of the rectangle in pixels
                * @property width
                * @type Number
                * @default 0
                * @public
                */
                this.width = 0;
                /**
                * The height of the rectangle in pixels
                * @property height
                * @type Number
                * @default 0
                * @public
                */
                this.height = 0;
                this.setTo(x, y, width, height);
            }
            /**
            * The type of this object.
            * @method objType
            * @return {String} "Rectangle"
            * @public
            */
            Rectangle.prototype.objType = function () {
                return "Rectangle";
            };
            Object.defineProperty(Rectangle.prototype, "bottom", {
                get: function () {
                    return this.y + this.height;
                },
                /**
                * The sum of the y and height properties.
                * Changing the bottom property of a Rectangle object has no effect on the x, y and width properties,
                * but does change the height property.
                *
                * @property bottom
                * @type Number
                * @public
                */
                set: function (value) {
                    if (value) {
                        if (value < this.y) {
                            this.height = 0;
                        }
                        else {
                            this.height = value;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rectangle.prototype, "center", {
                /**
                * Returns a Point containing the location of the center of the Rectangle, relative to the top left edge
                * @property center
                * @type Kiwi.Geom.Point
                * @readOnly
                * @public
                */
                get: function () {
                    var output = new Geom.Point();
                    return output.setTo(Math.round(this.width / 2), Math.round(this.height / 2));
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rectangle.prototype, "bottomRight", {
                get: function () {
                    var output = new Geom.Point();
                    return output.setTo(this.right, this.bottom);
                },
                /**
                * Returns a Point containing the location of the Rectangle's bottom-right corner, determined by the values of the right and bottom properties.
                * @property bottomRight
                * @type Kiwi.Geom.Point
                * @public
                */
                set: function (value) {
                    if (value) {
                        this.right = value.x;
                        this.bottom = value.y;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rectangle.prototype, "left", {
                get: function () {
                    return this.x;
                },
                /**
                * The x coordinate of the top-left corner of the rectangle. Changing the left property of a Rectangle object has no effect on the y and height properties. However it does affect the width property, whereas changing the x value does not affect the width property.
                * @property left
                * @type Number
                * @public
                */
                set: function (value) {
                    if (value) {
                        var diff = this.x - value;
                        if (this.width + diff < 0) {
                            this.width = 0;
                            this.x = value;
                        }
                        else {
                            this.width += diff;
                            this.x = value;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rectangle.prototype, "right", {
                get: function () {
                    return this.x + this.width;
                },
                /**
                * The sum of the x and width properties. Changing the right property of a Rectangle object has no effect on the x, y and height properties. However it does affect the width property.
                * @property right
                * @type Number
                * @public
                */
                set: function (value) {
                    if (value) {
                        if (value < this.x) {
                            this.width = 0;
                        }
                        else {
                            this.width = value - this.x;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rectangle.prototype, "size", {
                /**
                * The size of the Rectangle object, expressed as a Point object with the values of the width and height properties.
                * @property size
                * @type Kiwi.Geom.Point
                * @readOnly
                * @public
                */
                get: function () {
                    var output = new Geom.Point();
                    return output.setTo(this.width, this.height);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rectangle.prototype, "volume", {
                /**
                * The volume of the Rectangle object in pixels, derived from width * height
                * @property volume
                * @type Number
                * @readOnly
                * @return
                */
                get: function () {
                    return this.width * this.height;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rectangle.prototype, "perimeter", {
                /**
                * The perimeter size of the Rectangle object in pixels. This is the sum of all 4 sides.
                * @property perimeter
                * @type Number
                * @readOnly
                * @public
                */
                get: function () {
                    return (this.width * 2) + (this.height * 2);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rectangle.prototype, "top", {
                get: function () {
                    return this.y;
                },
                /**
                * The y coordinate of the top-left corner of the rectangle.
                * Changing the top property of a Rectangle object has no effect on the x and width properties.
                * However it does affect the height property, whereas changing the y value does not affect the height property.
                *
                * @method top
                * @return {Number}
                * @public
                */
                set: function (value) {
                    if (value) {
                        var diff = this.y - value;
                        if (this.height + diff < 0) {
                            this.height = 0;
                            this.y = value;
                        }
                        else {
                            this.height += diff;
                            this.y = value;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rectangle.prototype, "topLeft", {
                get: function () {
                    var output = new Geom.Point();
                    return output.setTo(this.x, this.y);
                },
                /**
                * The location of the Rectangle object's top-left corner, determined by the x and y coordinates of the point.
                * @property topLeft
                * @type Kiwi.Geom.Point
                * @public
                */
                set: function (value) {
                    if (value) {
                        this.x = value.x;
                        this.y = value.y;
                    }
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Returns a new Rectangle object with the same values for the x, y, width, and height properties as the original Rectangle object.
            * @method clone
            * @param [output] {Kiwi.Geom.Rectangle} Optional Rectangle object. If given the values will be set into the object, otherwise a brand new Rectangle object will be created and returned.
            * @return {Kiwi.Geom.Rectangle}
            * @public
            */
            Rectangle.prototype.clone = function (output) {
                if (output === void 0) { output = new Rectangle; }
                return output.setTo(this.x, this.y, this.width, this.height);
            };
            /**
            * Determines whether the specified coordinates are contained within the region defined by this Rectangle object.
            * @method contains
            * @param {Number} x The x coordinate of the point to test.
            * @param {Number} y The y coordinate of the point to test.
            * @return {boolean} A value of true if the Rectangle object contains the specified point; otherwise false.
            * @public
            */
            Rectangle.prototype.contains = function (x, y) {
                if (x >= this.x && x <= this.right && y >= this.y && y <= this.bottom) {
                    return true;
                }
                return false;
            };
            /**
            * Determines whether the specified point is contained within the rectangular region defined by this Rectangle object.
            * This method is similar to the Rectangle.contains() method, except that it takes a Point object as a parameter.
            *
            * @method containsPoint
            * @param {Kiwi.Geom.Point} point The point object being checked. Can be Kiwi.Geom.Point or any object with .x and .y values.
            * @return {boolean} A value of true if the Rectangle object contains the specified point; otherwise false.
            * @public
            */
            Rectangle.prototype.containsPoint = function (point) {
                return this.contains(point.x, point.y);
            };
            /**
            * Determines whether the Rectangle object specified by the rect parameter is contained within this Rectangle object.
            * A Rectangle object is said to contain another if the second Rectangle object falls entirely within the boundaries of the first.
            *
            * @method containsRect
            * @param rect {Kiwi.Geom.Rectangle} The rectangle object being checked.
            * @return {boolean} A value of true if the Rectangle object contains the specified point; otherwise false.
            * @public
            */
            Rectangle.prototype.containsRect = function (rect) {
                //	If the given rect has a larger volume than this one then it can never contain it
                if (rect.volume > this.volume) {
                    return false;
                }
                if (rect.x >= this.x && rect.y >= this.y && rect.right <= this.right && rect.bottom <= this.bottom) {
                    return true;
                }
                return false;
            };
            /**
            * Copies all of rectangle data from the source Rectangle object into the calling Rectangle object.
            *
            * @method copyFrom
            * @param source {Kiwi.Geom.Rectangle} The source rectangle object to copy from
            * @return {Kiwi.Geom.Rectangle} This rectangle object
            * @public
            */
            Rectangle.prototype.copyFrom = function (source) {
                return this.setTo(source.x, source.y, source.width, source.height);
            };
            /**
            * Copies all the rectangle data from this Rectangle object into the destination Rectangle object.
            * Creates a new rectangle if one was not passed.
            *
            * @method copyTo
            * @param [target] {Kiwi.Geom.Rectangle} The destination rectangle object to copy in to. Creates a new rectangle if one is not passed.
            * @return {Kiwi.Geom.Rectangle} The destination rectangle object
            * @public
            */
            Rectangle.prototype.copyTo = function (target) {
                if (target === void 0) { target = new Rectangle(); }
                return target.copyFrom(this);
            };
            /**
            * Determines whether the object specified in the toCompare parameter is equal to this Rectangle object.
            * This method compares the x, y, width, and height properties of an object against the same properties of this Rectangle object.
            *
            * @method equals
            * @param  toCompare {Kiwi.Geom.Rectangle} toCompare The rectangle to compare to this Rectangle object.
            * @return {boolean} A value of true if the object has exactly the same values for the x, y, width, and height properties as this Rectangle object; otherwise false.
            * @public
            */
            Rectangle.prototype.equals = function (toCompare) {
                if (this.x === toCompare.x && this.y === toCompare.y && this.width === toCompare.width && this.height === toCompare.height) {
                    return true;
                }
                return false;
            };
            /**
            * Increases the size of the Rectangle object by the specified amounts, in pixels.
            *
            * The center point of the Rectangle object stays the same,
            * and its size increases to the left and right by the dx value,
            * and to the top and the bottom by the dy value.
            *
            * @method inflate
            * @param dx {Number} dx The amount to be added to the left side of this Rectangle.
            * @param dy {Number} dy The amount to be added to the bottom side of this Rectangle.
            * @return {Kiwi.Geom.Rectangle} This Rectangle object.
            * @public
            */
            Rectangle.prototype.inflate = function (dx, dy) {
                if (!isNaN(dx) && !isNaN(dy)) {
                    this.x -= dx;
                    this.width += 2 * dx;
                    this.y -= dy;
                    this.height += 2 * dy;
                }
                return this;
            };
            /**
            * Increases the size of the Rectangle object. This method is similar to the Rectangle.inflate() method except it takes a Point object as a parameter.
            *
            * @method inflatePoint
            * @param point {Kiwi.Geom.Point} The x property of this Point object is used to increase the horizontal dimension of the Rectangle object. The y property is used to increase the vertical dimension of the Rectangle object.
            * @return {Kiwi.Geom.Rectangle} This Rectangle object.
            * @public
            */
            Rectangle.prototype.inflatePoint = function (point) {
                return this.inflate(point.x, point.y);
            };
            /**
            * If the Rectangle object specified in the toIntersect parameter intersects with this Rectangle object,
            * returns the area of intersection as a Rectangle object.
            * If the rectangles do not intersect, this method returns an empty Rectangle object with its properties set to 0.
            *
            * @method intersection
            * @param toIntersect {Kiwi.Geom.Rectangle} The Rectangle object to compare against to see if it intersects with this Rectangle object.
            * @param [output] {Kiwi.Geom.Rectangle} Optional Rectangle object. If given the intersection values will be set into this object, otherwise a brand new Rectangle object will be created and returned.
            * @return {Kiwi.Geom.Rectangle} A Rectangle object that equals the area of intersection. If the rectangles do not intersect, this method returns an empty Rectangle object; that is, a rectangle with its x, y, width, and height properties set to 0.
            * @public
            */
            Rectangle.prototype.intersection = function (toIntersect, output) {
                if (output === void 0) { output = new Rectangle; }
                if (this.intersects(toIntersect) === true) {
                    output.x = Math.max(toIntersect.x, this.x);
                    output.y = Math.max(toIntersect.y, this.y);
                    output.width = Math.min(toIntersect.right, this.right) - output.x;
                    output.height = Math.min(toIntersect.bottom, this.bottom) - output.y;
                }
                return output;
            };
            /**
            * Determines whether the object specified in the toIntersect parameter intersects with this Rectangle object.
            * This method checks the x, y, width, and height properties of the specified Rectangle object to see if it intersects with this Rectangle object.
            *
            * @method intersects
            * @param toIntersect {Kiwi.Geom.Rectangle} The Rectangle object to compare against to see if it intersects with this Rectangle object.
            * @return {boolean} A value of true if the specified object intersects with this Rectangle object; otherwise false.
            * @public
            **/
            Rectangle.prototype.intersects = function (toIntersect) {
                if (toIntersect.x > this.right - 1) {
                    return false;
                }
                if (toIntersect.right - 1 < this.x) {
                    return false;
                }
                if (toIntersect.bottom - 1 < this.y) {
                    return false;
                }
                if (toIntersect.y > this.bottom - 1) {
                    return false;
                }
                return true;
            };
            /**
            * Checks for overlaps between this Rectangle and the given Rectangle. Returns an object with boolean values for each check.
            *
            * @method overlap
            * @param rect {Kiwi.Geom.Rectangle}
            * @return {Object} An object containing the overlapping details between the two Rectangles
            * @todo Move to an IntersectResult? Do not want to be generating all of these values each time this is called
            * @public
            */
            Rectangle.prototype.overlap = function (rect) {
                var result = { top: false, bottom: false, left: false, right: false, contains: false, contained: false };
                var interRect = this.intersection(rect);
                if (interRect.isEmpty)
                    return result;
                if (this.containsRect(rect))
                    result.contains = true;
                if (rect.containsRect(this))
                    result.contained = true;
                if (this.top < rect.top)
                    result.top = true;
                if (this.bottom > rect.bottom)
                    result.bottom = true;
                if (this.left < rect.left)
                    result.left = true;
                if (this.right > rect.right)
                    result.right = true;
                return result;
            };
            /**
            * Determines whether or not this Rectangle object is empty.
            * @method isEmpty
            * @return {boolean} A value of true if the Rectangle object's width or height is less than or equal to 0; otherwise false.
            * @public
            */
            Rectangle.prototype.isEmpty = function () {
                if (this.width < 1 || this.height < 1) {
                    return true;
                }
                return false;
            };
            /**
            * Adjusts the location of the Rectangle object, as determined by its top-left corner, by the specified amounts.
            *
            * @method offset
            * @param dx {Number} Moves the x value of the Rectangle object by this amount.
            * @param dy {Number} Moves the y value of the Rectangle object by this amount.
            * @return {Kiwi.Geom.Rectangle} This Rectangle object.
            * @public
            */
            Rectangle.prototype.offset = function (dx, dy) {
                if (!isNaN(dx) && !isNaN(dy)) {
                    this.x += dx;
                    this.y += dy;
                }
                return this;
            };
            /**
            * Adjusts the location of the Rectangle object using a Point object as a parameter.
            * This method is similar to the Rectangle.offset() method, except that it takes a Point object as a parameter.
            *
            * @method offsetPoint
            * @param point {Kiwi.Geom.Point} A Point object to use to offset this Rectangle object.
            * @return {Kiwi.Geom.Rectangle} This Rectangle object.
            * @public
            */
            Rectangle.prototype.offsetPoint = function (point) {
                return this.offset(point.x, point.y);
            };
            /**
            * Sets all of the Rectangle object's properties to 0.
            * A Rectangle object is empty if its width or height is less than or equal to 0.
            *
            * @method setEmpty
            * @return {Kiwi.Geom.Rectangle} This rectangle object
            * @public
            */
            Rectangle.prototype.setEmpty = function () {
                return this.setTo(0, 0, 0, 0);
            };
            /**
            * Sets the properties of Rectangle to the specified values.
            *
            * @method setTo
            * @param x {Number} x The x coordinate of the top-left corner of the rectangle.
            * @param y {Number} y The y coordinate of the top-left corner of the rectangle.
            * @param width {Number} width The width of the rectangle in pixels.
            * @param height {Number} height The height of the rectangle in pixels.
            * @return {Kiwi.Geom.Rectangle} This rectangle object
            * @public
            */
            Rectangle.prototype.setTo = function (x, y, width, height) {
                if (!isNaN(x) && !isNaN(y) && !isNaN(width) && !isNaN(height)) {
                    this.x = x;
                    this.y = y;
                    if (width >= 0) {
                        this.width = width;
                    }
                    if (height >= 0) {
                        this.height = height;
                    }
                }
                return this;
            };
            /**
            * Adds two rectangles together to create a new Rectangle object, by filling in the horizontal and vertical space between the two rectangles.
            *
            * @method union
            * @param toUnion {Kiwi.Geom.Rectangle} toUnion A Rectangle object to add to this Rectangle object.
            * @param [output] {Kiwi.Geom.Rectangle} output Optional Rectangle object. If given the new values will be set into this object, otherwise a new Rectangle object will be created.
            * @return {Kiwi.Geom.Rectangle} A Rectangle object that is the union of the two rectangles.
            * @public
            */
            Rectangle.prototype.union = function (toUnion, output) {
                if (output === void 0) { output = new Rectangle; }
                return output.setTo(Math.min(toUnion.x, this.x), Math.min(toUnion.y, this.y), Math.max(toUnion.right, this.right), Math.max(toUnion.bottom, this.bottom));
            };
            /**
            * Scales this Rectangle by values passed.
            *
            * @method scale
            * @param x {number}
            * @param y {number}
            * @param translation {Kiwi.Geom.Point}
            * @return {Kiwi.Geom.Rectangle}
            * @public
            */
            Rectangle.prototype.scale = function (x, y, translation) {
                var trans = new Kiwi.Geom.Transform;
                trans.scaleX = x;
                trans.scaleY = y;
                trans.x = translation.x;
                trans.y = translation.y;
                var tl = this.topLeft;
                trans.transformPoint(tl);
                this.topLeft = tl;
                this.width *= x;
                this.height *= y;
                return this;
            };
            /**
            * Returns a string representation of this object.
            * @method toString
            * @return {String} a string representation of the instance.
            */
            Rectangle.prototype.toString = function () {
                return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " isEmpty=" + this.isEmpty() + ")}]";
            };
            return Rectangle;
        })();
        Geom.Rectangle = Rectangle;
    })(Geom = Kiwi.Geom || (Kiwi.Geom = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Geom
*/
var Kiwi;
(function (Kiwi) {
    var Geom;
    (function (Geom) {
        /**
        * Represents position, scale, rotation and rotationPoint of an Entity.
        * - Values can be transformed with a 3x3 affine transformation matrix, which each transform is assigned.
        * - A tranform can be assigned a parent, which may in turn have it's own parent, thereby creating a tranform inheritence heirarchy
        * - A concatenated transformation matrix, representing the combined matrices of the transform and its ancestors.
        *
        * @class Transform
        * @namespace Kiwi.Geom
        * @constructor
        * @param [x=0] {Number} X position of the transform.
        * @param [y=0] {Number} Y position of the transform.
        * @param [scaleX=1] {Number} X scaling of the transform.
        * @param [scaleY=1] {Number} Y scaling of the transform.
        * @param [rotation=0] {Number} Rotation of the transform in radians.
        * @param [rotX=0] {Number} rotationPoint offset on X axis.
        * @param [rotY=0] {Number} rotationPoint offset on Y axis.
        * @return {Transform} This object.
        *
        */
        var Transform = (function () {
            function Transform(x, y, scaleX, scaleY, rotation, rotPointX, rotPointY) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (scaleX === void 0) { scaleX = 1; }
                if (scaleY === void 0) { scaleY = 1; }
                if (rotation === void 0) { rotation = 0; }
                if (rotPointX === void 0) { rotPointX = 0; }
                if (rotPointY === void 0) { rotPointY = 0; }
                /**
                * X position of the transform
                * @property _x
                * @type Number
                * @default 0
                * @private
                */
                this._x = 0;
                /**
                * Y position of the transform
                * @property _y
                * @type Number
                * @default 0
                * @private
                */
                this._y = 0;
                /**
                * X scaleof the transform
                * @property _scaleX
                * @type Number
                * @default 1
                * @private
                */
                this._scaleX = 1;
                /**
                * Y scale of the transform
                * @property _scaleY
                * @type Number
                * @default 1
                * @private
                */
                this._scaleY = 1;
                /**
                * Rotation of the transform in radians.
                * @property _rotation
                * @type Number
                * @default 0
                * @private
                */
                this._rotation = 0;
                /**
                * Rotation offset on X axis.
                * @property _rotPointX
                * @type Number
                * @default 0
                * @private
                */
                this._rotPointX = 0;
                /**
                * Rotation offset on Y axis.
                * @property _rotPointY
                * @type Number
                * @default 0
                * @private
                */
                this._rotPointY = 0;
                /**
                * The parent transform. If set to null there is no parent. Otherwise this is used by getConcatenatedMatrix to offset the current transforms by the another matrix
                * @property _parent
                * @type Kiwi.Geom.Transform
                * @default null
                * @private
                */
                this._parent = null;
                /**
                * Private copy.
                * Whether the Transform is locked. In locked mode, the Transform
                * will not update its matrix, saving on computation.
                * However, it will still follow its parent.
                * @property _locked
                * @type boolean
                * @default false
                * @private
                * @since 1.2.0
                */
                this._locked = false;
                /**
                * Private copy.
                * Whether to ignore its parent when concatenating matrices.
                * If true, it won't compute parent matrices.
                * This can save computation, but prevents it from following
                * its parent's transforms.
                * Use this to save some processor cycles if the transform isn't
                * following a parent and the state does not transform.
                * @property _ignoreParent
                * @type boolean
                * @default false
                * @private
                * @since 1.2.0
                */
                this._ignoreParent = false;
                /**
                * Private copy.
                * Whether to prevent children from acquiring this as a parent
                * when concatenating matrices. This can save computation,
                * but prevents it from passing any transform data to children.
                *
                * Use this to save some processor cycles if this is a Group
                * that does not control its children, and the state does not
                * transform.
                *
                * @property _ignoreChild
                * @type boolean
                * @default false
                * @private
                * @since 1.3.1
                */
                this._ignoreChild = false;
                /**
                * Whether the transform has been altered since the last time
                * it was used to create a matrix. Used to determine whether to rebuild
                * the matrix or not.
                *
                * @property _dirty
                * @type boolean
                * @default true
                * @private
                * @since 1.3.1
                */
                this._dirty = true;
                this.setTransform(x, y, scaleX, scaleY, rotation, rotPointX, rotPointY);
                this._matrix = new Geom.Matrix();
                this._cachedConcatenatedMatrix = new Geom.Matrix();
                this._matrix.setFromOffsetTransform(this._x, this._y, this._scaleX, this._scaleY, this._rotation, this._rotPointX, this._rotPointY);
            }
            /**
            * The type of this object.
            * @method objType
            * @return {String} "Transform"
            * @public
            */
            Transform.prototype.objType = function () {
                return "Transform";
            };
            Object.defineProperty(Transform.prototype, "x", {
                get: function () {
                    return this._x;
                },
                /**
                * Return the X value of the transform.
                * @property x
                * @type Number
                * @public
                */
                set: function (value) {
                    this._x = value;
                    this._dirty = true;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Transform.prototype, "y", {
                get: function () {
                    return this._y;
                },
                /**
                * Return the Y value of the transform.
                * @property y
                * @type Number
                * @public
                */
                set: function (value) {
                    this._y = value;
                    this._dirty = true;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Transform.prototype, "scaleX", {
                get: function () {
                    return this._scaleX;
                },
                /**
                * Return the X scale value of the transform.
                * @property scaleX
                * @type Number
                * @public
                */
                set: function (value) {
                    this._scaleX = value;
                    this._dirty = true;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Transform.prototype, "scaleY", {
                get: function () {
                    return this._scaleY;
                },
                /**
                * Return the Y scale value of the transform.
                * @property scaleY
                * @type Number
                * @public
                */
                set: function (value) {
                    this._scaleY = value;
                    this._dirty = true;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Transform.prototype, "rotation", {
                get: function () {
                    return this._rotation;
                },
                /**
                * Return the rotation value of the transform in radians.
                * @property rotation
                * @type Number
                * @public
                */
                set: function (value) {
                    this._rotation = value;
                    this._dirty = true;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Transform.prototype, "rotPointX", {
                get: function () {
                    return this._rotPointX;
                },
                /**
                * Return the rotation offset from the x axis.
                * @property rotPointX
                * @type Number
                * @default 0
                * @public
                */
                set: function (value) {
                    this._rotPointX = value;
                    this._dirty = true;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Transform.prototype, "rotPointY", {
                get: function () {
                    return this._rotPointY;
                },
                /**
                * Return the rotation offset from the y axis.
                * @property rotPointY
                * @type Number
                * @public
                */
                set: function (value) {
                    this._rotPointY = value;
                    this._dirty = true;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Transform.prototype, "anchorPointX", {
                get: function () {
                    return (this.rotPointX);
                },
                /**
                * Return the anchor point value from the X axis. (Aliases to rotPointX.)
                * @property anchorPointX
                * @type Number
                * @public
                * @since 1.1.0
                */
                set: function (value) {
                    this.rotPointX = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Transform.prototype, "anchorPointY", {
                get: function () {
                    return (this.rotPointY);
                },
                /**
                * Return the anchor point value from the Y axis. (Aliases to rotPointY.)
                * @property anchorPointY
                * @type Number
                * @public
                * @since 1.1.0
                */
                set: function (value) {
                    this.rotPointY = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Transform.prototype, "matrix", {
                /**
                * Return the Matrix being used by this Transform
                * @property matrix
                * @type Kiwi.Geom.Matrix
                * @readOnly
                * @public
                */
                get: function () {
                    return this._matrix;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Transform.prototype, "worldX", {
                /**
                * Return the x of this transform translated to world space.
                * @property worldX
                * @type Number
                * @readOnly
                * @public
                */
                get: function () {
                    return this.getConcatenatedMatrix().tx - this._rotPointX;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Transform.prototype, "worldY", {
                /**
                * Return the y of this transform translated to world space.
                * @property worldY
                * @type Number
                * @readOnly
                * @public
                */
                get: function () {
                    return this.getConcatenatedMatrix().ty - this._rotPointY;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Transform.prototype, "parent", {
                get: function () {
                    return this._parent;
                },
                /**
                * Return the parent Transform. If the transform does not have a parent this null is returned.
                * @property parent
                * @type Kiwi.Geom.Transform
                * @default null
                * @public
                */
                set: function (value) {
                    if (!this.checkAncestor(value)) {
                        this._parent = value;
                        this._dirty = true;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Transform.prototype, "locked", {
                get: function () {
                    return this._locked;
                },
                /**
                * Whether the Transform is locked. In locked mode, the Transform
                * will not update its matrix, saving on computation.
                * However, it will still follow its parent.
                * When locked is set to true, it will set the matrix according to
                * current transform values.
                * @property locked
                * @type boolean
                * @default false
                * @public
                * @since 1.2.0
                */
                set: function (value) {
                    this._locked = value;
                    if (this._locked) {
                        this._matrix.setFromOffsetTransform(this.x, this.y, this.scaleX, this.scaleY, this.rotation, this.anchorPointX, this.anchorPointY);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Transform.prototype, "ignoreParent", {
                get: function () {
                    return this._ignoreParent;
                },
                /**
                * Whether to ignore its parent when concatenating matrices.
                * If true, it won't compute parent matrices.
                * This can save computation, but prevents it from following
                * its parent's transforms.
                *
                * Use this to save some processor cycles if the transform isn't
                * following a parent and the state does not transform.
                * @property ignoreParent
                * @type boolean
                * @default false
                * @public
                * @since 1.2.0
                */
                set: function (value) {
                    this._ignoreParent = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Transform.prototype, "ignoreChild", {
                /**
                * Whether to prevent children from acquiring this as a parent
                * when concatenating matrices. This can save computation,
                * but prevents it from passing any transform data to children.
                *
                * Use this to save some processor cycles if this is a Group
                * that does not control its children, and the state does not
                * transform.
                *
                * @property ignoreChild
                * @type boolean
                * @default false
                * @public
                * @since 1.3.1
                */
                get: function () {
                    return this._ignoreChild;
                },
                set: function (value) {
                    this._ignoreChild = value;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Set the X and Y values of the transform.
            * @method setPosition
            * @param x {Number}
            * @param y {Number}
            * @return {Kiwi.Geom.Transform} This object.
            * @public
            */
            Transform.prototype.setPosition = function (x, y) {
                this._x = x;
                this._y = y;
                this._dirty = true;
                return this;
            };
            /**
            * Set the X and Y values of the transform from a point.
            * @method setPositionPoint
            * @param point {Kiwi.Geom.Point} point.
            * @return {Kiwi.Geom.Transform} This object.
            * @public
            */
            Transform.prototype.setPositionFromPoint = function (point) {
                this._x = point.x;
                this._y = point.y;
                this._dirty = true;
                return this;
            };
            /**
            * Translate the X and Y value of the transform by point components.
            * @method translatePositionFromPoint
            * @param point {Kiwi.Geom.Point} point.
            * @return {Kiwi.Geom.Transform} This object.
            * @public
            */
            Transform.prototype.translatePositionFromPoint = function (point) {
                this._x += point.x;
                this._y += point.y;
                this._dirty = true;
                return this;
            };
            /**
            * Return a Point representing the X and Y values of the transform.
            * If no point is given a new Point objected will be created.
            *
            * @method getPositionPoint
            * @param [output] {Kiwi.Geom.Point} The Point to output the coordinates into. Creates a new Point if none given.
            * @return {Kiwi.Geom.Point} A point representing the X and Y values of the transform.
            * @public
            */
            Transform.prototype.getPositionPoint = function (output) {
                if (output === void 0) { output = new Kiwi.Geom.Point; }
                return output.setTo(this._x, this._y);
            };
            Object.defineProperty(Transform.prototype, "scale", {
                /**
                * Set the X and Y scale value of the transform.
                * This property is set only.
                * In the future this will be looked into and updated as needed.
                *
                * @property scale
                * @type Number
                * @public
                */
                set: function (value) {
                    this._scaleX = value;
                    this._scaleY = value;
                    this._dirty = true;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Set the core properties of the transform.
            *
            * @method setTransform
            * @param [x=0] {Number} X position of the transform.
            * @param [y=0] {Number} Y position of the transform.
            * @param [scaleX=1] {Number} X scaling of the transform.
            * @param [scaleY=1] {Number} Y scaling of the transform.
            * @param [rotation=0] {Number} Rotation of the transform in radians.
            * @param [rotX=0] {Number} rotationPoint offset on X axis.
            * @param [rotY=0] {Number} rotationPoint offset on Y axis.
            * @return {Kiwi.Geom.Transform} This object.
            * @public
            */
            Transform.prototype.setTransform = function (x, y, scaleX, scaleY, rotation, rotPointX, rotPointY) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (scaleX === void 0) { scaleX = 1; }
                if (scaleY === void 0) { scaleY = 1; }
                if (rotation === void 0) { rotation = 0; }
                if (rotPointX === void 0) { rotPointX = 0; }
                if (rotPointY === void 0) { rotPointY = 0; }
                this._x = x;
                this._y = y;
                this._scaleX = scaleX;
                this._scaleY = scaleY;
                this._rotation = rotation;
                this._rotPointX = rotPointX;
                this._rotPointY = rotPointY;
                this._dirty = true;
                return this;
            };
            /**
            * Return the parent matrix of the transform.
            * If there is no parent then null is returned.
            * @method getParentMatrix
            * @return {Kiwi.Geom.Matrix} Parent transform matrix
            * @public
            */
            Transform.prototype.getParentMatrix = function () {
                if (this._parent) {
                    return this._parent.getConcatenatedMatrix();
                }
                return null;
            };
            /**
            * Return the transformation matrix that concatenates this transform
            * with all ancestor transforms. If there is no parent then this will
            * return a matrix the same as this transform's matrix.
            * @method getConcatenatedMatrix
            * @return {Kiwi.Geom.Matrix} The concatenated matrix.
            * @public
            */
            Transform.prototype.getConcatenatedMatrix = function () {
                /*
    
                Matrix caching
    
                Potential cases:
                - This dirty, parent dirty	:	Update matrix, build concat
                - This dirty, parent clean	:	Update matrix, build concat
                - This dirty, no parent		:	Update matrix
                - This clean, parent dirty	:	Build concat
                - This clean, parent clean	:	Use cachedConcatenated
                - This clean, no parent		:	Use cachedConcatenated
    
                Simplifies to four cases:
                - This dirty, has parent	:	Update matrix, build concat
                - This dirty, no parent		:	Update matrix
                - This clean, parent dirty	:	Build concat
                - Otherwise					:	Use cachedConcatenated
    
                This has been further simplified because of some issues.
                Now, the matrix is updated if it's dirty;
                and the parent is applied if it exists.
                Parent dirtiness is not considered, as this appeared to be
                causing issues.
    
                */
                // Set correct local matrix
                if (this._dirty && !this.locked) {
                    this._matrix.setFromOffsetTransform(this.x, this.y, this.scaleX, this.scaleY, this.rotation, this.anchorPointX, this.anchorPointY);
                }
                // Get local matrix
                this._cachedConcatenatedMatrix.copyFrom(this._matrix);
                // Apply parent transform
                if (this._parent &&
                    !this._parent.ignoreChild &&
                    !this.ignoreParent) {
                    this._cachedConcatenatedMatrix.tx -= this._parent.anchorPointX;
                    this._cachedConcatenatedMatrix.ty -= this._parent.anchorPointY;
                    this._cachedConcatenatedMatrix.prependMatrix(this.getParentMatrix());
                }
                this._dirty = false;
                return this._cachedConcatenatedMatrix;
            };
            /**
            * Apply this matrix to a an object with x and y properties representing a point and return the transformed point.
            * @method transformPoint
            * @param point {Kiwi.Geom.Point}
            * @return {Kiwi.Geom.Point}
            * @public
            */
            Transform.prototype.transformPoint = function (point) {
                var mat = this.getConcatenatedMatrix();
                return mat.transformPoint(point);
            };
            /**
            * Copy another transforms data to this transform. A clone of the source matrix is created for the matrix property.
            * @method copyFrom
            * @param transform {Kiwi.Geom.Transform} transform. The tranform to be copied from.
            * @return {Kiwi.Geom.Transform} This object.
            * @public
            */
            Transform.prototype.copyFrom = function (source) {
                this.setTransform(source.x, source.y, source.scaleX, source.scaleY, source.rotation, source.rotPointX, source.rotPointY);
                this.parent = source.parent;
                this._matrix = source.matrix.clone();
                return this;
            };
            /**
            * Copy this transforms data to the destination Transform.
            * A clone of this transforms matrix is created in the destination Transform Matrix.
            *
            * @method copyTo
            * @param destination {Kiwi.Geom.Transform} The tranform to copy to.
            * @return {Kiwi.Geom.Transform} This object.
            * @public
            */
            Transform.prototype.copyTo = function (destination) {
                destination.copyFrom(this);
                return this;
            };
            /**
            * Return a clone of this transform.
            *
            * @method clone
            * @param [output] {Kiwi.Geom.Transform} A Transform to copy the clone in to. If none is given a new Transform object will be made.
            * @return {Kiwi.Geom.Transform} A clone of this object.
            * @public
            */
            Transform.prototype.clone = function (output) {
                if (output === void 0) { output = new Transform(); }
                output.copyFrom(this);
                return output;
            };
            /**
            * Recursively check that a transform does not appear as its own ancestor
            * @method checkAncestor
            * @param transform {Kiwi.Geom.Transform} The Transform to check.
            * @return {boolean} Returns true if the given transform is the same as this or an ancestor, otherwise false.
            * @public
            */
            Transform.prototype.checkAncestor = function (transform) {
                /*if (transform === this)
                {
                    return true
                }
    
                if (transform.parent !== null)
                {
                    return (this.checkAncestor(transform._parent))
                }*/
                return false;
            };
            Object.defineProperty(Transform.prototype, "toString", {
                /**
                * Return a string represention of this object.
                * @method toString
                * @return {String} A string represention of this object.
                * @public
                */
                get: function () {
                    return "[{Transform (x=" + this._x + " y=" + this._y + " scaleX=" + this._scaleX + " scaleY=" + this._scaleY + " rotation=" + this._rotation + " regX=" + this._rotPointX + " regY=" + this.rotPointY + " matrix=" + this._matrix + ")}]";
                },
                enumerable: true,
                configurable: true
            });
            return Transform;
        })();
        Geom.Transform = Transform;
    })(Geom = Kiwi.Geom || (Kiwi.Geom = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Geom
*/
var Kiwi;
(function (Kiwi) {
    var Geom;
    (function (Geom) {
        /**
        * A two dimensional vector object for storing and manipulating x and y vector components.
        *
        * @class Vector2
        * @namespace Kiwi.Geom
        * @constructor
        * @param [x=0] {Number} The x component of the vector.
        * @param [y=0] {Number} The y component of the vector.
        * @return {Kiwi.Geom.Vector2}
        */
        var Vector2 = (function () {
            function Vector2(x, y) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                this.setTo(x, y);
            }
            /**
            * The type of this object.
            * @method objType
            * @return {String} "Vector2"
            * @public
            */
            Vector2.prototype.objType = function () {
                return "Vector2";
            };
            /**
            * Generate a Vector2 from an angle
            * @method fromAngle
            * @param angle {Number} The angle to generate the Vector2 from.
            * @return {Kiwi.Geom.Vector2} A new Vector2
            * @static
            * @public
            */
            Vector2.fromAngle = function (angle) {
                return new Vector2(Math.cos(angle), Math.sin(angle));
            };
            /**
            * Generate a random Vector2 within a given radius.
            * @method randomRadius
            * @param radius {Number} The size of the radius to use.
            * @return {Kiwi.Geom.Vector2} A new Vector2
            * @static
            * @public
            */
            Vector2.randomRadius = function (radius) {
                return new Vector2(Math.random() * 2 - 1, Math.random() * 2 - 1).multiplyScalar(radius);
            };
            /**
            * Generate a Vector2 from a point.
            * @method fromPoint
            * @param point {Kiwi.Geom.Point} point.
            * @return {Kiwi.Geom.Vector2} A new Vector2
            * @static
            * @public
            */
            Vector2.fromPoint = function (point) {
                return new Vector2(point.x, point.y);
            };
            /**
            * Add each component of another Vector2 to this vectors components.
            * @method add
            * @param {Kiwi.Geom.Vector2} Vector2 to add
            * @return {Kiwi.Geom.Vector2} A new Vector2 containing the product
            * @public
            */
            Vector2.prototype.add = function (vector2) {
                return new Vector2(this.x + vector2.x, this.y + vector2.y);
            };
            /**
            * Add only the x component of another Vector2 to this vector.
            * @method addX
            * @param vector2 {Kiwi.Geom.Vector2} Vector2 to add
            * @return {Kiwi.Geom.Vector2} A new Vector2 containing the result
            * @public
            */
            Vector2.prototype.addX = function (vector2) {
                return new Vector2(this.x + vector2.x, this.y);
            };
            /**
            * Add only the y component of another Vector2 to this vector.
            * @method addY
            * @param vector2 {Kiwi.Geom.Vector2} Vector2 to add
            * @return {Kiwi.Geom.Vector2} A new Vector2 containing the result
            * @public
            */
            Vector2.prototype.addY = function (vector2) {
                return new Vector2(this.x, this.y + vector2.y);
            };
            /**
            * Subtract each component of another Vector2 from this vectors components.
            * @method subtract
            * @param vector2 {Kiwi.Geom.Vector2} Vector2 to subtract
            * @return {Kiwi.Geom.Vector2} A new Vector2 containing the result
            * @public
            */
            Vector2.prototype.subtract = function (vector2) {
                return new Kiwi.Geom.Vector2(this.x - vector2.x, this.y - vector2.y);
            };
            /**
            * Multiply each component of another Vector2 with this vectors components.
            * @method multiply
            * @param vector2 {Kiwi.Geom.Vector2} Vector2 to multiply
            * @return {Kiwi.Geom.Vector2} A new Vector2 containing the result
            * @public
            */
            Vector2.prototype.multiply = function (vector2) {
                return new Kiwi.Geom.Vector2(this.x * vector2.x, this.y * vector2.y);
            };
            /**
            * Multiply each component of this vector with a scalar number.
            * @method multiplyScalar
            * @param scalar {Number} Scalar to multiply
            * @return {Kiwi.Geom.Vector2} A new Vector2 containing the result
            * @public
            */
            Vector2.prototype.multiplyScalar = function (scalar) {
                return new Kiwi.Geom.Vector2(this.x * scalar, this.y * scalar);
            };
            /**
            * Calculate the dot product if a Vector2 with this Vector2.
            * @method dot
            * @param vector2 {Kiwi.Geom.Vector2} Vector2 to dot with this Vector2.
            * @return {Number} Result of dot product.
            * @public
            */
            Vector2.prototype.dot = function (vector2) {
                return this.x * vector2.x + this.y * vector2.y;
            };
            /**
            * Calculate the square length of this Vector2 (Distance from the origin).
            * @method lenSqr
            * @return {Number} The square length.
            * @public
            */
            Vector2.prototype.lenSqr = function () {
                return this.x * this.x + this.y * this.y;
            };
            /**
            * Calculate the length of this Vector2 (Distance from the origin).
            * @method len
            * @return {Number} The length.
            * @public
            */
            Vector2.prototype.len = function () {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            };
            /**
            * Calculate a normalised unit Vector2 from this Vector2.
            * @method unit
            * @return {Kiwi.Geom.Vector2} a new Unit Length Vector2.
            * @public
            */
            Vector2.prototype.unit = function () {
                var invLen = 1.0 / this.len();
                return this.multiplyScalar(invLen);
            };
            /**
            * Reduce each component of the Vector to the closest lower round value.
            * @method floor
            * @return {Kiwi.Geom.Vector2} a rounded down Vector2.
            * @public
            */
            Vector2.prototype.floor = function () {
                return new Vector2(Math.floor(this.x), Math.floor(this.y));
            };
            /**
            * Increase each component of the Vector to the closest upper round value.
            * @method ceil
            * @return {Kiwi.Geom.Vector2} a rounded up Vector2.
            * @public
            */
            Vector2.prototype.ceil = function () {
                return new Vector2(Math.ceil(this.x), Math.ceil(this.y));
            };
            /**
            * Round each component of the Vector to the closest round value.
            * @method round
            * @return {Kiwi.Geom.Vector2} a rounded Vector2.
            * @public
            */
            Vector2.prototype.round = function () {
                return new Vector2(Math.round(this.x), Math.round(this.y));
            };
            /**
            * Clamp the vector between a maximum and minimum Vector2 range component-wise.
            * @method clamp
            * @param min {Kiwi.Geom.Vector2} Minimum values for Vector2.
            * @param max {Kiwi.Geom.Vector2} Maximum values for Vector2.
            * @return {Kiwi.Geom.Vector2} a clamped Vector2.
            * @public
            */
            Vector2.prototype.clamp = function (min, max) {
                return new Vector2(Math.max(Math.min(this.x, max.x), min.x), Math.max(Math.min(this.y, max.y), min.y));
            };
            /**
            * Calculate a Vector2 perpendicular to this Vector2.
            * @method perp
            * @return {Kiwi.Geom.Vector2} the perpendicular Vector2.
            * @public
            */
            Vector2.prototype.perp = function () {
                return new Vector2(-this.y, this.x);
            };
            /**
            * Calculate a Vector2 opposite to this Vector2.
            * @method neg
            * @return {Kiwi.Geom.Vector2} the opposite Vector2.
            * @public
            */
            Vector2.prototype.neg = function () {
                return new Vector2(-this.x, -this.y);
            };
            /**
            * Check if two Vector2s from equal components.
            * @method equal
            * @param vector2 {Kiwi.Geom.Vector2} vector2. Vector2 to check against.
            * @return {boolean} returns true if equal.
            * @public
            */
            Vector2.prototype.equal = function (vector2) {
                return this.x === vector2.x && this.y === vector2.y;
            };
            /**
            * Get a Point object with the same components as this Vector2.
            * @method point
            * @return {Kiwi.Geom.Point} A new Point.
            * @public
            */
            Vector2.prototype.point = function () {
                return new Geom.Point(this.x, this.y);
            };
            /**
            * Set both components to zero.
            * @method clear
            * @return {Kiwi.Geom.Vector2} This object.
            * @public
            */
            Vector2.prototype.clear = function () {
                this.x = 0;
                this.y = 0;
                return this;
            };
            /**
            * Get a clone of this Vector2.
            * @method clone
            * @param [output] {Kiwi.Geom.Vector2} Optional. A vector2 that will be cloned to. One will be created if none passed.
            * @return {Kiwi.Geom.Vector2} Either a new cloned Vector2 or the output vector with cloned components.
            * @public
            */
            Vector2.prototype.clone = function (output) {
                if (output === void 0) { output = new Vector2; }
                return output.setTo(this.x, this.y);
            };
            /**
            * Copy components from another Vector2.
            * @method copyFrom
            * @param source {Kiwi.Geom.Vector2} A Vector2 to copy from.
            * @return {Kiwi.Geom.Vector2} This object.
            * @public
            */
            Vector2.prototype.copyFrom = function (source) {
                this.x = source.x;
                this.y = source.y;
                return this;
            };
            /**
            * Copy components to another Vector2.
            * @method copyTo
            * @param target {Kiwi.Geom.Vector2} A Vector2 to copy to.
            * @return {Kiwi.Geom.Vector2} The supplied Vector2.
            * @public
            */
            Vector2.prototype.copyTo = function (target) {
                target.x = this.x;
                target.y = this.y;
                return target;
            };
            /**
            * Set components on this Vector2.
            * @method setTo
            * @param x {Number} x component to set.
            * @param y {Number} y component to set.
            * @return {Kiwi.Geom.Vector2} This object.
            * @public
            */
            Vector2.prototype.setTo = function (x, y) {
                this.x = x;
                this.y = y;
                return this;
            };
            /**
            * Get a string representation of this object.
            * @method toString
            * @return {String} This object as a string.
            */
            Vector2.prototype.toString = function () {
                return '[{Vector2 (x=' + this.x + ' y=' + this.y + ')}]';
            };
            return Vector2;
        })();
        Geom.Vector2 = Vector2;
    })(Geom = Kiwi.Geom || (Kiwi.Geom = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule HUD
*
*/
var Kiwi;
(function (Kiwi) {
    var HUD;
    (function (HUD) {
        /**
        * A HUDDisplay is a container for which you can add/removes widget on, and is more used to manage the widgets that are being displayed on it.
        * A HUDDisplay is created through a games HUDManager and is NOT directly instantiated.
        * Each game can contain multiple HUDDisplay's and each HUDDisplay can contain multiple HUDWidgets.
        *
        * @class HUDDisplay
        * @namespace Kiwi.HUD
        * @constructor
        * @param game {Kiwi.Game} The game that this HUD Display belongs to.
        * @param name {string} The name of this display.
        * @return HUDDisplay
        */
        var HUDDisplay = (function () {
            function HUDDisplay(game, name) {
                this._game = game;
                this.name = name;
                this._manager = this._game.huds;
                this._device = this._game.deviceTargetOption;
                if (this._manager.supported) {
                    switch (this._device) {
                        case Kiwi.TARGET_BROWSER:
                            this.container = document.createElement("div");
                            this.container.id = "HUD-layer-" + game.rnd.uuid();
                            this.container.style.width = "100%";
                            this.container.style.height = "100%";
                            this.container.style.position = "absolute";
                            this._widgets = new Array();
                            break;
                    }
                    this.class = 'kiwi-display';
                }
            }
            /**
            * Returns the type of object that this is.
            * @method objType
            * @return {String} "HUDDisplay"
            * @public
            */
            HUDDisplay.prototype.objType = function () {
                return 'HUDDisplay';
            };
            /**
            * Adds a widget to the HUDDisplay. Returns a boolean as an indication of whether or not it was successful.
            *
            * @method addWidget
            * @param widget {Kiwi.HUD.HUDWidget}  The widget to be added to the Display
            * @return {Boolean} If it was successful or not.
            * @public
            */
            HUDDisplay.prototype.addWidget = function (widget) {
                if (this._manager.supported) {
                    this._widgets.push(widget);
                    if (this._device == Kiwi.TARGET_BROWSER) {
                        this.container.appendChild(widget.container);
                        return true;
                    }
                }
                return false;
            };
            /**
            * Removes a singular widget from the display. Returns a boolean as an indication of if anything happened or not.
            *
            * @method removeWidget
            * @param widget {Kiwi.HUD.HUDWidget} The widget to be removed.
            * @return {boolean} If it was successful or not.
            * @public
            */
            HUDDisplay.prototype.removeWidget = function (widget) {
                if (this._manager.supported) {
                    if (this.removeFromContainer(widget)) {
                        var i = this._widgets.indexOf(widget);
                        if (i !== -1) {
                            this._widgets.splice(i, 1);
                            return true;
                        }
                    }
                }
                return false;
            };
            /**
            * Removes all of the widgets on this display.
            * @method removeAllWidgets
            * @public
            */
            HUDDisplay.prototype.removeAllWidgets = function () {
                for (var i = 0; i < this._widgets.length; i++) {
                    this.removeFromContainer(this._widgets[i]);
                }
                this._widgets = [];
            };
            /**
            * Removes a widget from on the HUDDisplay.
            * @method removeFromContainer
            * @param widget {Kiwi.HUD.HUDWidget} The Widget to be removed.
            * @returns {boolean}
            */
            HUDDisplay.prototype.removeFromContainer = function (widget) {
                if (this._manager.supported) {
                    if (this._device == Kiwi.TARGET_BROWSER) {
                        if (this.container.contains(widget.container)) {
                            this.container.removeChild(widget.container);
                            return true;
                        }
                    }
                }
                return false;
            };
            /**
            * Update loop.
            * @method update
            * @public
            */
            HUDDisplay.prototype.update = function () {
                for (var i = 0; i < this._widgets.length; i++) {
                    this._widgets[i].update();
                }
            };
            /**
            * Shows displays the HUD Display on screen.
            * @method show
            * @public
            */
            HUDDisplay.prototype.show = function () {
                this.container.style.display = 'block';
            };
            /**
            * Hides the current HUD Display from the screen.
            * @method hide
            * @public
            */
            HUDDisplay.prototype.hide = function () {
                this.container.style.display = 'none';
            };
            Object.defineProperty(HUDDisplay.prototype, "class", {
                get: function () {
                    if (this._device == Kiwi.TARGET_BROWSER) {
                        return this.container.className;
                    }
                },
                /**
                * The class name that the container element that this HUDWidget current has.
                * @property class
                * @type {String}
                * @public
                */
                set: function (cssClass) {
                    if (this._device == Kiwi.TARGET_BROWSER) {
                        this.container.className = cssClass;
                    }
                },
                enumerable: true,
                configurable: true
            });
            return HUDDisplay;
        })();
        HUD.HUDDisplay = HUDDisplay;
    })(HUD = Kiwi.HUD || (Kiwi.HUD = {}));
})(Kiwi || (Kiwi = {}));
/**
* The HUD (Heads Up Display) is a section that handles the displayment of information that you always want visible to user.
* This section is managed differently to normal GameObjects, where the difference being that HUD items aren't added to a Canvas but are DOM elements instead. Since they DOM elements you can style these elements using a CSS sheet if you wish.
*
* @module Kiwi
* @submodule HUD
* @main HUD
*/
var Kiwi;
(function (Kiwi) {
    var HUD;
    (function (HUD) {
        /**
        * This class manages all of the various HUDDisplays that are currently used on this Managers game.
        * Using this class you can create/add and remove HUDDisplays from this game,
        * change the HUDDisplay that is currently being display (also known as the currentHUD) and show/hide the currentHUD.
        * Each HUDManager also has at least one HUDDisplay which is called the 'defaultHUD' you cannot remove,
        * but you can reassign the defaultHUD to be a different HUDDisplay if you want.
        *
        *
        * @class HUDManager
        * @namespace Kiwi.HUD
        * @constructor
        * @param game {Kiwi.Game} game
        * @return {Kiwi.HUD.HUDManager}
        */
        var HUDManager = (function () {
            function HUDManager(game) {
                this._game = game;
                this._device = this._game.deviceTargetOption;
            }
            Object.defineProperty(HUDManager.prototype, "supported", {
                /**
                * Returns the _supported property indicating whether HUD is supported or not.
                * @property supported
                * @type boolean
                * @public
                */
                get: function () {
                    return this._supported;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * The DOM is ready, so if the current state is pending we can boot up the HUD now.
            * @method boot
            * @public
            */
            HUDManager.prototype.boot = function () {
                if (this._device === Kiwi.TARGET_BROWSER) {
                    this._supported = true;
                    this._hudContainer = document.createElement("div");
                    this._hudContainer.id = "HUDContainer";
                    this._hudContainer.style.position = "absolute";
                    this._hudContainer.style.width = "100%";
                    this._hudContainer.style.height = "100%";
                    this._hudContainer.style.top = '0';
                    this._hudContainer.style.left = '0';
                    this._game.stage.container.appendChild(this._hudContainer);
                    this._huds = new Array();
                    this._defaultHUD = this.createHUD("defaultHUD");
                    this._currentHUD = this._defaultHUD;
                    this.setHUD(this._defaultHUD);
                }
                else {
                    this._supported = false;
                }
            };
            /**
            * Returns the type of object this is.
            * @method objType
            * @return {String} "HUDManager"
            * @public
            */
            HUDManager.prototype.objType = function () {
                return "HUDManager";
            };
            Object.defineProperty(HUDManager.prototype, "defaultHUD", {
                get: function () {
                    return this._defaultHUD;
                },
                /**
                * The default HUDDisplay that is to be used.
                * The defaultHUD cannot be removed, and a game (that supports HUDS) will always contain the defaultHUD.
                *
                * @property defaultHUD
                * @type Kiwi.HUD.HUDDisplay
                * @public
                */
                set: function (value) {
                    if (this._currentHUD === this._defaultHUD) {
                        this._currentHUD = value;
                        this.setHUD(this._currentHUD);
                    }
                    this._defaultHUD = value;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Changes the currentHUD that is being displayed to one that is passed.
            * @method setHUD
            * @param hud {Kiwi.HUD.HUDDisplay} The HUD you want to display.
            * @public
            */
            HUDManager.prototype.setHUD = function (hud) {
                if (this.supported) {
                    this.hideHUD();
                    this._currentHUD = hud;
                    this.showHUD();
                }
            };
            /**
            * Shows the currentHUD (if nothing is passed) or shows a HUDDisplay that is passed.
            * @method showHUD
            * @param [hud=currentHUD] {Kiwi.HUD.HUDDisplay} The HUDDisplay you want to show. Defaults to the currentHUD if nothing is passed.
            * @public
            */
            HUDManager.prototype.showHUD = function (hud) {
                if (hud === void 0) { hud = this._currentHUD; }
                hud.show();
            };
            /**
            * Hides the currentHUD (if nothing is passed) or shows a HUDDisplay that is passed.
            * @method hideHUD
            * @param [hud=currentHUD] {Kiwi.HUD.HUDDisplay} The HUDDisplay you want to hude. Defaults to the currentHUD if nothing is passed.
            * @public
            */
            HUDManager.prototype.hideHUD = function (hud) {
                if (hud === void 0) { hud = this._currentHUD; }
                hud.hide();
            };
            /**
            * Creates a new HUDDisplay on this HUDManager.
            *
            * @method createHUD
            * @param name {string} Name of the new HUDDisplay that is being creates.
            * @param [switchTo=false] {boolean} Switch to the new HUD that was created. DE
            * @return {Kiwi.HUD.HUDDisplay} The HUDDisplay that was created.
            * @public
            */
            HUDManager.prototype.createHUD = function (name, switchTo) {
                if (switchTo === void 0) { switchTo = false; }
                if (this.supported) {
                    var hud = new Kiwi.HUD.HUDDisplay(this._game, name);
                    hud.hide();
                    this.addToContainer(hud);
                    this._huds.push(hud);
                    if (switchTo === true)
                        this.setHUD(hud);
                    return hud;
                }
            };
            /**
            * Removes a HUDDisplay off this manager. Returns a boolean indicating whether or not this method was a success.
            *
            * @method removeHUD
            * @param hud {Kiwi.HUD.HUDDisplay} The hud you want to remove.
            * @returns {boolean} If this method succeeded or not.
            * @public
            */
            HUDManager.prototype.removeHUD = function (hud) {
                if (this.supported) {
                    if (hud === this._defaultHUD) {
                        return false;
                    }
                    if (this._currentHUD === hud) {
                        this.setHUD(this._defaultHUD);
                    }
                    this.removeFromContainer(hud);
                    var i = this._huds.indexOf(hud);
                    if (i !== -1) {
                        this._huds.splice(i, 1);
                    }
                    return true;
                }
            };
            /**
            * Adds a HUDDisplays HTMLDivElement to this HUDManagers container element.
            * @method addToContainer
            * @param hud {Kiwi.HUD.HUDDisplay} The HUDDisplay that is to be added.
            * @private
            */
            HUDManager.prototype.addToContainer = function (hud) {
                if (this._device == Kiwi.TARGET_BROWSER) {
                    this._hudContainer.appendChild(hud.container);
                }
            };
            /**
            * Removes the hud that is passed from this HUD Manager. Checks to see if that hud has this container as a parent first.
            * @method removeFromContainer
            * @param hud {Kiwi.HUD.HUDDisplay} The hud to be removed
            * @private
            */
            HUDManager.prototype.removeFromContainer = function (hud) {
                if (this._device == Kiwi.TARGET_BROWSER) {
                    if (this._hudContainer.contains(hud.container)) {
                        this._hudContainer.removeChild(hud.container);
                    }
                }
            };
            /**
            * Game loop
            * @method update
            * @public
            */
            HUDManager.prototype.update = function () {
                if (this._supported) {
                    for (var i = 0; i < this._huds.length; i++) {
                        this._huds[i].update();
                    }
                }
            };
            return HUDManager;
        })();
        HUD.HUDManager = HUDManager;
    })(HUD = Kiwi.HUD || (Kiwi.HUD = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule HUD
*/
var Kiwi;
(function (Kiwi) {
    var HUD;
    (function (HUD) {
        /**
        * The HUDWidget is an abstract class containing the fundamental properties and methods that every HUDWidget needs to have.
        * This class is designed to be extended from and thus objects should not directly instantiate it.
        *
        * @class HUDWidget
        * @namespace Kiwi.HUD
        * @constructor
        * @param game {Kiwi.Game}  The game that this HUDWidget belongs to.
        * @param name {string} Name of the type of HUDWidget.
        * @param x {number} The coordinates of this HUDWidget on the x-axis.
        * @param y {number} The coordinates of this HUDWidget on the y-axis.
        * @return {Kiwi.HUD.HUDWidget}
        */
        var HUDWidget = (function () {
            function HUDWidget(game, name, x, y) {
                /**
                * Contains the current CSS style that will used for the x position.
                * Should either be `LEFT` or `RIGHT` but these values are not checked upon assignment.
                *
                * @property _horizontalOrigin
                * @type string
                * @default 'left'
                * @since 1.3.0
                * @protected
                */
                this._horizontalOrigin = HUDWidget.LEFT;
                /**
                * Contains the current CSS style that will used for the y position.
                * Should either be `TOP` or `BOTTOM` but these values are not checked upon assignment.
                *
                * @property _verticalOrigin
                * @type string
                * @default 'top'
                * @since 1.3.0
                * @protected
                */
                this._verticalOrigin = HUDWidget.TOP;
                this.name = name;
                this.game = game;
                this._manager = this.game.huds;
                this._device = this.game.deviceTargetOption;
                this.components = new Kiwi.ComponentManager(Kiwi.HUD_WIDGET, this);
                if (this._manager.supported) {
                    if (this._device === Kiwi.TARGET_BROWSER) {
                        this.container = document.createElement("div");
                        this.container.id = 'HUD-widget-' + this.game.rnd.uuid();
                        this.container.className = 'HUD-widget';
                        this.container.style.position = "absolute";
                    }
                    this.onCoordsUpdate = new Kiwi.Signal();
                    this.x = x;
                    this.y = y;
                }
            }
            /**
            * Returns the type of object that this is.
            * @method objType
            * @return {String} "HUDWidget"
            * @public
            */
            HUDWidget.prototype.objType = function () {
                return 'HUDWidget';
            };
            Object.defineProperty(HUDWidget.prototype, "style", {
                /**
                * A quick way to reference the style object that exists on the container element of this widget.
                * @property style
                * @type any
                * @public
                */
                get: function () {
                    if (this._device === Kiwi.TARGET_BROWSER) {
                        return this.container.style;
                    }
                },
                set: function (val) {
                    if (this._device === Kiwi.TARGET_BROWSER) {
                        this.container.style = val;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(HUDWidget.prototype, "x", {
                /**
                * Get the x coordinate of the widget
                * @property x
                * @type number
                * @public
                */
                get: function () {
                    return this._x;
                },
                set: function (value) {
                    if (this._manager.supported) {
                        this._x = value;
                        if (this._device == Kiwi.TARGET_BROWSER)
                            this.container.style[this._horizontalOrigin] = this.x + "px";
                        this.onCoordsUpdate.dispatch(this.x, this.y);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(HUDWidget.prototype, "y", {
                /**
                * Get the y coordinate of the widget
                * @property y
                * @type number
                * @public
                */
                get: function () {
                    return this._y;
                },
                set: function (value) {
                    if (this._manager.supported) {
                        this._y = value;
                        if (this._device == Kiwi.TARGET_BROWSER)
                            this.container.style[this._verticalOrigin] = this.y + "px";
                        this.onCoordsUpdate.dispatch(this.x, this.y);
                    }
                },
                enumerable: true,
                configurable: true
            });
            /**
            * This method is used to remove existing DOM elements and place them inside a HUDWidget's container element.
            * Useful so that when making HUD Widgets the developer can style HUDWidgets without having to create/write to much javascript.
            *
            * Can be used by itself but maybe more useful if you customise it to suit your own needs.
            * Currently doesn't have that great support.
            *
            * @method setTemplate
            * @param main {string} main - ID of an HTMLElement. This element should contain all of the elements you would like to place inside the HUDWidget.
            * @param [element] {string} element - ID of an HTMLElement that resides inside of the main param. This is the element that the HUDWidget can use to populate with information. E.g. Your score, health remaining, the icon, e.t.c.
            * @public
            */
            HUDWidget.prototype.setTemplate = function (main, element) {
                var paramsArr = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    paramsArr[_i - 2] = arguments[_i];
                }
                if (this._device == Kiwi.TARGET_BROWSER) {
                    var containerElement = document.getElementById(main);
                    if (containerElement === undefined) {
                        return;
                    }
                    if (element === undefined) {
                        var fieldElement = containerElement;
                    }
                    else {
                        var fieldElement = document.getElementById(element);
                        if (fieldElement === undefined || containerElement.contains(fieldElement) === false) {
                            return;
                        }
                    }
                    this.tempElement = fieldElement;
                    this._tempContainer = containerElement;
                    this._tempParent = containerElement.parentElement;
                    this._tempParent.removeChild(containerElement);
                    this.container.appendChild(containerElement);
                }
            };
            /**
            * Used to remove any the template HTML from this HUDWidget.
            * Currently doesn't have that great support.
            *
            * @method removeTemplate
            * @public
            */
            HUDWidget.prototype.removeTemplate = function () {
                if (this._device == Kiwi.TARGET_BROWSER) {
                    if (this.tempElement !== undefined) {
                        this.container.removeChild(this._tempContainer);
                        this._tempParent.appendChild(this._tempContainer);
                        this.tempElement = null;
                        this._tempParent = null;
                        this._tempContainer = null;
                    }
                }
            };
            Object.defineProperty(HUDWidget.prototype, "class", {
                get: function () {
                    if (this._device == Kiwi.TARGET_BROWSER) {
                        return this.container.className;
                    }
                },
                /**
                * The class name/s that the container element that this HUDWidget current has.
                * @property class
                * @type {String}
                * @public
                */
                set: function (cssClass) {
                    if (this._device == Kiwi.TARGET_BROWSER) {
                        this.container.className = cssClass;
                    }
                },
                enumerable: true,
                configurable: true
            });
            /**
            * The game update loop.
            * @method update
            * @public
            */
            HUDWidget.prototype.update = function () {
                this.components.update();
            };
            Object.defineProperty(HUDWidget.prototype, "horizontalOrigin", {
                /**
                * Contains the current CSS style that will used for the x position.
                * Should either be `LEFT` or `RIGHT` but these values are not checked upon assignment.
                *
                * @property horizontalOrigin
                * @type string
                * @default 'left'
                * @since 1.3.0
                * @public
                */
                get: function () {
                    return this._horizontalOrigin;
                },
                set: function (val) {
                    //Reset the current
                    this.container.style[this._horizontalOrigin] = 'auto';
                    //Set the new value
                    this._horizontalOrigin = val;
                    this.container.style[this._horizontalOrigin] = this.x + 'px';
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(HUDWidget.prototype, "verticalOrigin", {
                /**
                * Contains the current CSS style that will used for the y position.
                * Should either be `TOP` or `BOTTOM` but these values are not checked upon assignment.
                *
                * @property vertical
                * @type string
                * @default 'top'
                * @since 1.3.0
                * @public
                */
                get: function () {
                    return this._verticalOrigin;
                },
                set: function (val) {
                    //Reset the current
                    this.container.style[this._verticalOrigin] = 'auto';
                    //Set the new value
                    this._verticalOrigin = val;
                    this.container.style[this._verticalOrigin] = this.y + 'px';
                },
                enumerable: true,
                configurable: true
            });
            /**
            *
            * @method destroy
            * @public
            */
            HUDWidget.prototype.destroy = function () {
                delete this.game;
                delete this._manager;
                delete this._device;
                if (this.onCoordsUpdate)
                    this.onCoordsUpdate.dispose();
                delete this.onCoordsUpdate;
                //remove the elements....
            };
            /**
            * Contains the CSS style used to position a HUD element from the top corner.
            *
            * @property TOP
            * @type string
            * @default 'top'
            * @since 1.3.0
            * @static
            * @readOnly
            * @final
            * @public
            */
            HUDWidget.TOP = 'top';
            /**
            * Contains the CSS style used to position a HUD element from the bottom corner.
            *
            * @property BOTTOM
            * @type string
            * @default 'bottom'
            * @since 1.3.0
            * @static
            * @readOnly
            * @final
            * @public
            */
            HUDWidget.BOTTOM = 'bottom';
            /**
            * Contains the CSS style used to position a HUD element from the left corner.
            *
            * @property LEFT
            * @type string
            * @default 'left'
            * @since 1.3.0
            * @static
            * @readOnly
            * @final
            * @public
            */
            HUDWidget.LEFT = 'left';
            /**
            * Contains the CSS style used to position a HUD element from the right corner.
            *
            * @property RIGHT
            * @type string
            * @default 'right'
            * @since 1.3.0
            * @static
            * @readOnly
            * @final
            * @public
            */
            HUDWidget.RIGHT = 'right';
            return HUDWidget;
        })();
        HUD.HUDWidget = HUDWidget;
    })(HUD = Kiwi.HUD || (Kiwi.HUD = {}));
})(Kiwi || (Kiwi = {}));
/**
* HUD Widgets are objects that are generally placed on to a HUD Display for displaying and managing information that the user would always need to see.
* An example of such information would be: the Health remaining, amount of ammo left, time they have left, e.t.c.
* And each one of those examples would have its own widget.
*
* @module HUD
* @submodule Widget
* @main Widget
*/
var Kiwi;
(function (Kiwi) {
    var HUD;
    (function (HUD) {
        var Widget;
        (function (Widget) {
            /**
            * A Widget that is used for the displaying of text on the HUD.
            * Foreach TextField you can add some prefix/suffix text, which is more useful on classes extending this one.
            *
            * @class TextField
            * @extends Kiwi.HUD.HUDWidget
            * @namespace Kiwi.HUD.Widget
            * @constructor
            * @param game {Kiwi.Game} The game that this textfield belongs to.
            * @param text {string} The text on this textfield.
            * @param x {number} The x coordinates
            * @param y {number} The y coordinates
            * @return {Kiwi.HUD.Widget.TextField}
            */
            var TextField = (function (_super) {
                __extends(TextField, _super);
                function TextField(game, text, x, y) {
                    _super.call(this, game, "textField", x, y);
                    /**
                    * A string that is to be added in-front of the score. Can contain HTMLElements.
                    * @property _prefix
                    * @type string
                    * @default ''
                    * @private
                    */
                    this._prefix = '';
                    /**
                    * A string that is to be added after the score. Can contain HTMLElements.
                    * @property _suffix
                    * @type string
                    * @default ''
                    * @private
                    */
                    this._suffix = '';
                    this.class = 'kiwi-textfield-widget kiwi-widget';
                    if (this._manager.supported) {
                        if (this._device === Kiwi.TARGET_BROWSER) {
                            this._textField = this.container;
                            this._textField.innerHTML = text;
                        }
                    }
                }
                /**
                * Returns the type of object that this is.
                * @method objType
                * @return {String} 'TextFieldWidget'
                * @public
                */
                TextField.prototype.objType = function () {
                    return 'TextFieldWidget';
                };
                /**
                * This method is used to remove existing DOM elements and place them inside a HUDWidget's container element.
                * Useful so that when making HUD Widgets the developer can style HUDWidgets without having to create/write to much javascript.
                *
                * Currently doesn't have great support.
                *
                * @method setTemplate
                * @param main {string} ID of an HTMLElement. This element should contain all of the elements you would like to place inside the HUDWidget.
                * @param icon {string} ID of an HTMLElement that resides inside of the main param. This is the element that the HUDWidget can use to populate with information. E.g. Your score, health remaining, the icon, e.t.c.
                * @public
                */
                TextField.prototype.setTemplate = function (main, field) {
                    if (this._device === Kiwi.TARGET_BROWSER) {
                        this._textField.innerText = '';
                        _super.prototype.setTemplate.call(this, main, field);
                        if (this.tempElement !== undefined) {
                            this._textField = this.tempElement;
                        }
                        this._textField.innerHTML = this._text;
                    }
                };
                /**
                * Used to remove any the template HTML from this HUDWidget.
                * Currently doesn't have great support.
                *
                * @method removeTemplate
                * @public
                */
                TextField.prototype.removeTemplate = function () {
                    if (this._device === Kiwi.TARGET_BROWSER) {
                        _super.prototype.removeTemplate.call(this);
                        if (this._device === Kiwi.TARGET_BROWSER) {
                            this._textField = this.container;
                            this._textField.innerHTML = this._text;
                        }
                    }
                };
                Object.defineProperty(TextField.prototype, "text", {
                    get: function () {
                        return this._text;
                    },
                    /**
                    * The text that is currently being displayed inside the textfield.
                    * @property text
                    * @type string
                    * @public
                    */
                    set: function (val) {
                        if (this._manager.supported) {
                            if (this._device === Kiwi.TARGET_BROWSER) {
                                if (this._prefix !== '')
                                    val = this._prefix + val;
                                if (this._suffix !== '')
                                    val += this._suffix;
                                this._text = val;
                                this._textField.innerHTML = this._text;
                            }
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "suffix", {
                    get: function () {
                        return this._suffix;
                    },
                    /**
                    * A string that is to be added after the score. Can contain HTMLElements.
                    * @property _suffix
                    * @type string
                    * @default ''
                    * @public
                    */
                    set: function (val) {
                        this._suffix = val;
                        this._updateText();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TextField.prototype, "prefix", {
                    get: function () {
                        return this._prefix;
                    },
                    /**
                    * A string that is to be added in-front of the score. Can contain HTMLElements.
                    * @property _prefix
                    * @type string
                    * @default ''
                    * @public
                    */
                    set: function (val) {
                        this._prefix = val;
                        this._updateText();
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                * This method is intended to be overriden by subclasses which functions update the text being displayed.
                * @method _updateText
                * @protected
                */
                TextField.prototype._updateText = function () {
                    //..your code here
                    this.text = this._text;
                };
                return TextField;
            })(Kiwi.HUD.HUDWidget);
            Widget.TextField = TextField;
        })(Widget = HUD.Widget || (HUD.Widget = {}));
    })(HUD = Kiwi.HUD || (Kiwi.HUD = {}));
})(Kiwi || (Kiwi = {}));
/**
* @module HUD
* @submodule Widget
*/
var Kiwi;
(function (Kiwi) {
    var HUD;
    (function (HUD) {
        var Widget;
        (function (Widget) {
            /**
            * Used for displaying of information in a bar like of format. Example: Amount of health remaining for a character.
            * This class creates a 'innerbar' div inside of its main container which you can apply styles to.
            * You can control the minimum/maximum and current values of the bar through the Counter widget.
            *
            * @class Bar
            * @extends Kiwi.HUD.HUDWidget
            * @namespace Kiwi.HUD.Widget
            * @constructor
            * @param game {Kiwi.Game} The game that this bar belongs to.
            * @param current {Number} The current value of the bar.
            * @param max {Number} The maximum value that there can be.
            * @param x {Number} The coordinates of this widget on the x-axis.
            * @param y {Number} The cooridnates of this widget on the y-axis.
            * @param [width=120] {number} The width of the widget. Defaults to 120.
            * @param [height=20] {number} The height of the widget. Defaults to 20.
            * @param [color='#000'] {string} The default color of the inner bar. Defaults to #000 (black).
            * @return {Kiwi.HUD.Widget.Bar}
            */
            var Bar = (function (_super) {
                __extends(Bar, _super);
                function Bar(game, current, max, x, y, width, height, color) {
                    if (width === void 0) { width = 120; }
                    if (height === void 0) { height = 20; }
                    if (color === void 0) { color = '#000'; }
                    _super.call(this, game, "bar", x, y);
                    this._horizontal = true;
                    this.class = 'kiwi-bar-widget kiwi-widget';
                    if (this._manager.supported) {
                        if (this._device == Kiwi.TARGET_BROWSER) {
                            this._bar = document.createElement('div');
                            this._bar.className = 'kiwi-innerbar-widget';
                            this._bar.style.backgroundColor = color;
                            this.bar = this._bar;
                            this.container.appendChild(this.bar);
                        }
                        this.counter = this.components.add(new Kiwi.HUD.HUDComponents.Counter(this, current, max, 0));
                        this.counter.updated.add(this.updateCSS, this);
                        this.width = width;
                        this.height = height;
                        this._bar.style.height = '100%';
                        this._bar.style.width = '100%';
                        this.updateCSS();
                    }
                }
                /**
                * Returns the type of object that this is.
                * @method objType
                * @return {String} "BarWidget"
                * @public
                */
                Bar.prototype.objType = function () {
                    return 'BarWidget';
                };
                Object.defineProperty(Bar.prototype, "width", {
                    /**
                    * The width of the container
                    * @property width
                    * @type number
                    * @public
                    */
                    get: function () {
                        return this._width;
                    },
                    set: function (value) {
                        if (this._device == Kiwi.TARGET_BROWSER) {
                            this.container.style.width = value + "px";
                        }
                        this._width = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Bar.prototype, "height", {
                    /**
                    * The height of the container
                    * @property height
                    * @type number
                    * @public
                    */
                    get: function () {
                        return this._height;
                    },
                    set: function (value) {
                        if (this._device == Kiwi.TARGET_BROWSER) {
                            this.container.style.height = value + "px";
                        }
                        this._height = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Bar.prototype, "horizontal", {
                    /**
                    * Used to set the bar to be horizontal or vertical by passing a boolean.
                    * @property horizontal
                    * @type boolean
                    * @public
                    */
                    get: function () {
                        return this._horizontal;
                    },
                    set: function (val) {
                        this._horizontal = val;
                        this.updateCSS();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Bar.prototype, "vertical", {
                    /**
                    * Used to set the bar to be horizontal or vertical by passing a boolean.
                    * @property verticle
                    * @type boolean
                    * @public
                    */
                    get: function () {
                        return !this._horizontal;
                    },
                    set: function (val) {
                        this._horizontal = !val;
                        this.updateCSS();
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                * This method is used to remove existing DOM elements and place them inside a HUDWidget's container element.
                * Useful so that when making HUD Widgets the developer can style HUDWidgets without having to create/write to much javascript.
                * Currently not supported.
                *
                * @method setTemplate
                * @param main {string} ID of an HTMLElement. This element should contain all of the elements you would like to place inside the HUDWidget.
                * @param innerbar {string} ID of an HTMLElement that resides inside of the main param. This is the element that the HUDWidget can use to populate with information. E.g. Your score, health remaining, the icon, e.t.c.
                * @public
                */
                Bar.prototype.setTemplate = function (main, innerbar) {
                    if (this._device == Kiwi.TARGET_BROWSER) {
                        _super.prototype.setTemplate.call(this, main, innerbar);
                        if (this.tempElement !== undefined) {
                            this.bar = this.tempElement;
                        }
                    }
                };
                /**
                * Used to remove any the template HTML from this HUDWidget.
                * Current not supported.
                *
                * @method removeTemplate
                * @public
                */
                Bar.prototype.removeTemplate = function () {
                    if (this._device == Kiwi.TARGET_BROWSER) {
                        _super.prototype.removeTemplate.call(this);
                        this.bar = this._bar;
                        this.container.appendChild(this.bar);
                        this.updateCSS();
                    }
                };
                /**
                * Will be called when the range has been updated and thus you will want to preform the render of the bar here.
                * This should be overriden by subclasses so that you have your own custom bars.
                * @method updateCSS
                * @public
                */
                Bar.prototype.updateCSS = function () {
                    if (this.horizontal === true) {
                        this.bar.style.width = String(this.counter.currentPercent()) + '%';
                        this.bar.style.height = '100%';
                    }
                    else {
                        this.bar.style.height = String(this.counter.currentPercent()) + '%';
                        this.bar.style.width = '100%';
                    }
                };
                return Bar;
            })(Kiwi.HUD.HUDWidget);
            Widget.Bar = Bar;
        })(Widget = HUD.Widget || (HUD.Widget = {}));
    })(HUD = Kiwi.HUD || (Kiwi.HUD = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module HUD
* @submodule Widget
*
*/
var Kiwi;
(function (Kiwi) {
    var HUD;
    (function (HUD) {
        var Widget;
        (function (Widget) {
            /**
            * Used to display a cell from a TextureAtlas in the HUD. This could be used for portraits of the character, e.t.c.
            * You can change the current cell that is being used in the TextureAtlas by modifing the cellIndex property.
            *
            * @class Icon
            * @extends Kiwi.HUD.HUDWidget
            * @namespace Kiwi.HUD.Widget
            * @constructor
            * @param game {Kiwi.Game} The game that this icon belongs to.
            * @param atlas {Kiwi.Textures.TextureAtlas} The image that you would like displayed.
            * @param x {Number} The coordinate of the icon on the x-axis.
            * @param y {Number} The coordinate of the icon on the y-axis.
            * @return {Kiwi.HUD.Widget.Icon}
            */
            var Icon = (function (_super) {
                __extends(Icon, _super);
                function Icon(game, atlas, x, y) {
                    _super.call(this, game, 'Icon', x, y);
                    /**
                    * The cell inside the texture atlas that this icon is using
                    * @property _cellIndex
                    * @type number
                    * @default 0
                    * @private
                    */
                    this._cellIndex = 0;
                    this.class = 'kiwi-icon-widget kiwi-widget';
                    this.atlas = atlas;
                    this.icon = this.container;
                    this._applyCSS();
                }
                Object.defineProperty(Icon.prototype, "cellIndex", {
                    /**
                    * Gets the cell index that is being used.
                    * @property cellIndex
                    * @type number
                    * @default 0
                    * @public
                    */
                    get: function () {
                        return this._cellIndex;
                    },
                    set: function (value) {
                        this._cellIndex = value;
                        this.width = this.atlas.cells[this.cellIndex].w;
                        this.height = this.atlas.cells[this.cellIndex].h;
                        this._applyCSS();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Icon.prototype, "width", {
                    /**
                    * Returns the width of the cell that is being used.
                    * @property width
                    * @type number
                    * @public
                    */
                    get: function () {
                        return this.atlas.cells[this.cellIndex].w;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Icon.prototype, "height", {
                    /**
                    * Returns the height of the cell that is being used.
                    * @property height
                    * @type number
                    * @public
                    */
                    get: function () {
                        return this.atlas.cells[this.cellIndex].h;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                * Removes the CSS from the Icon.
                * This can happen when setting/removing a template and is public to allow for overriding from subclasses.
                * @method _removeCSS
                * @protected
                */
                Icon.prototype._removeCSS = function () {
                    this.icon.style.width = '';
                    this.icon.style.height = '';
                    this.icon.style.backgroundImage = '';
                    this.icon.style.backgroundRepeat = '';
                };
                /**
                * Applys the css to the HTMLElement that is to be affected.
                * @method _applyCSS
                * @protected
                */
                Icon.prototype._applyCSS = function () {
                    this.icon.style.width = this.width + "px";
                    this.icon.style.height = this.height + "px";
                    this.icon.style.backgroundPositionX = -this.atlas.cells[this.cellIndex].x + "px";
                    this.icon.style.backgroundPositionY = -this.atlas.cells[this.cellIndex].y + "px";
                    this.icon.style.backgroundRepeat = 'no-repeat';
                    if (Kiwi.Utils.Common.isUndefined(this.atlas.image.src) == false) {
                        this.icon.style.backgroundImage = 'url("' + this.atlas.image.src + '")';
                    }
                    else {
                        this.icon.style.backgroundImage = 'url("' + this.atlas.image.toDataURL("image/png") + '")';
                    }
                };
                /**
                * This method is used to remove existing DOM elements and place them inside a HUDWidget's container element.
                * Useful so that when making HUD Widgets the developer can style HUDWidgets without having to create/write to much javascript.
                * Currently not supported.
                *
                * @method setTemplate
                * @param main {string} main - ID of an HTMLElement. This element should contain all of the elements you would like to place inside the HUDWidget.
                * @param icon {string} icon - ID of an HTMLElement that resides inside of the main param. This is the element that the HUDWidget can use to populate with information. E.g. Your score, health remaining, the icon, e.t.c.
                * @public
                */
                Icon.prototype.setTemplate = function (main, icon) {
                    if (this._device == Kiwi.TARGET_BROWSER) {
                        this._removeCSS();
                        _super.prototype.setTemplate.call(this, main, icon);
                        if (this.tempElement !== undefined) {
                            this.icon = this.tempElement;
                        }
                        this._applyCSS();
                    }
                };
                /**
                * Used to remove any the template HTML from this HUDWidget.
                *
                * @method removeTemplate
                * @public
                */
                Icon.prototype.removeTemplate = function () {
                    if (this._device == Kiwi.TARGET_BROWSER) {
                        _super.prototype.removeTemplate.call(this);
                        this._removeCSS();
                        this.icon = this.container;
                        this._applyCSS();
                    }
                };
                return Icon;
            })(Kiwi.HUD.HUDWidget);
            Widget.Icon = Icon;
        })(Widget = HUD.Widget || (HUD.Widget = {}));
    })(HUD = Kiwi.HUD || (Kiwi.HUD = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module HUD
* @submodule Widget
*/
var Kiwi;
(function (Kiwi) {
    var HUD;
    (function (HUD) {
        var Widget;
        (function (Widget) {
            /**
            * The IconBar used to display a series of icons which represent a number of 'something' the user may have.
            * Example: If you had a shooter style game you might want to display the amount of 'ammo' left in the gun using a series of bullet icons. You could then use this IconBar to display that series.
            * The amount is based of a counter components current value, so you can set a maximum and minimum number of images to be displayed.
            *
            * @class IconBar
            * @extends Kiwi.HUD.HUDWidget
            * @namespace Kiwi.HUD.Widget
            * @constructor
            * @param game {Kiwi.Game} The game that this icon bar belongs to.
            * @param atlas {Kiwi.Textures.TextureAtlas} The texture atlas that the icons will have.
            * @param current {number} The current amount of icons in the bar.
            * @param max {number} The maximum number of icons.
            * @param x {number} The x coordinates of the first icon.
            * @param y {number} The y coordinates of the last icon.
            * @return {Kiwi.HUD.Widget.IconBar}
            */
            var IconBar = (function (_super) {
                __extends(IconBar, _super);
                function IconBar(game, atlas, current, max, x, y) {
                    _super.call(this, game, 'IconBar', x, y);
                    /**
                    * The amount of spacing you want between each icon in the bar. Defaults to 0.
                    * @property iconGap
                    * @type number
                    * @default 0
                    * @public
                    */
                    this.iconGap = 0;
                    this.class = 'kiwi-iconbar-widget kiwi-widget';
                    this.atlas = atlas;
                    this.width = this.atlas.cells[0].w;
                    this.height = this.atlas.cells[0].h;
                    this._horizontal = true;
                    this.counter = this.components.add(new Kiwi.HUD.HUDComponents.Counter(this, current, max, 0));
                    this.counter.updated.add(this._amountChanged, this);
                    this._icons = [];
                    this._amountChanged();
                }
                /**
                * The type of object that this is.
                * @method objType
                * @return {String} "IconBarWidget"
                * @public
                */
                IconBar.prototype.objType = function () {
                    return 'IconBarWidget';
                };
                /**
                * Gets called when the range has updated and then it updates the size of the bar.
                * @method _changeSize
                * @private
                */
                IconBar.prototype._amountChanged = function () {
                    //do we need to do something to the icons?!?
                    if (this.counter.max !== this._icons.length) {
                        if ((this.counter.max) > this._icons.length) {
                            //add more
                            var amount = (this.counter.max) - this._icons.length;
                            for (var i = 0; i < amount; i++) {
                                this._addIcon();
                            }
                        }
                        else {
                            //remove some
                            for (var i = this.counter.max; i < this._icons.length; i++) {
                                this._removeIcon(this._icons[i]);
                                this._icons[i].destroy();
                                this._icons.splice(i, 1);
                                i--;
                            }
                        }
                    }
                    //display them all!
                    for (var i = 0; i < this._icons.length; i++) {
                        if (i > (this.counter.current - 1)) {
                            this._icons[i].style.display = 'none';
                        }
                        else {
                            this._icons[i].style.display = 'block';
                        }
                    }
                };
                /**
                * Creates a new Icon and adds it to this IconBar.
                * @method _addIcon
                * @private
                */
                IconBar.prototype._addIcon = function () {
                    if (this.horizontal) {
                        var i = new Kiwi.HUD.Widget.Icon(this.game, this.atlas, this.x + ((this.width + this.iconGap) * (this._icons.length - 1)), 0);
                    }
                    else {
                        var i = new Kiwi.HUD.Widget.Icon(this.game, this.atlas, this.x, ((this.height + this.iconGap) * (this._icons.length - 1)));
                    }
                    i.horizontalOrigin = this.horizontalOrigin;
                    i.verticalOrigin = this.verticalOrigin;
                    this._icons.push(i);
                    if (this._device == Kiwi.TARGET_BROWSER) {
                        this.container.appendChild(i.container);
                    }
                };
                /**
                * Removes a Icon from the container.
                * @method _removeIcon
                * @param icon {Kiwi.HUD.Widget.Icon} The icon that you want to remove.
                * @private
                */
                IconBar.prototype._removeIcon = function (icon) {
                    if (this._device == Kiwi.TARGET_BROWSER) {
                        this.container.removeChild(icon.container);
                    }
                };
                Object.defineProperty(IconBar.prototype, "horizontal", {
                    /**
                    * Used to set the bar to be horizontal or vertical by passing a boolean.
                    * @property horizontal
                    * @type boolean
                    * @default true
                    * @public
                    */
                    get: function () {
                        return this._horizontal;
                    },
                    set: function (val) {
                        this._horizontal = val;
                        this._amountChanged();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(IconBar.prototype, "vertical", {
                    /**
                    * Used to set the bar to be horizontal or vertical by passing a boolean.
                    * @property vertical
                    * @type boolean
                    * @default false
                    * @public
                    */
                    get: function () {
                        return !this._horizontal;
                    },
                    set: function (val) {
                        this._horizontal = !val;
                        this._amountChanged();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(IconBar.prototype, "horizontalOrigin", {
                    /**
                    * Contains the current CSS style that will used for the x position.
                    * Should either be `LEFT` or `RIGHT` but these values are not checked upon assignment.
                    *
                    * @property horizontalOrigin
                    * @type string
                    * @default 'left'
                    * @since 1.3.0
                    * @public
                    */
                    get: function () {
                        return this._horizontalOrigin;
                    },
                    set: function (val) {
                        //Reset the current
                        this.container.style[this._horizontalOrigin] = 'auto';
                        //Set the new value
                        this._horizontalOrigin = val;
                        this.container.style[this._horizontalOrigin] = this.x + 'px';
                        //Loop through the children and apply the same origin
                        var i = 0;
                        while (i < this._icons.length) {
                            this._icons[i].horizontalOrigin = val;
                            i++;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(IconBar.prototype, "verticalOrigin", {
                    /**
                    * Contains the current CSS style that will used for the y position.
                    * Should either be `TOP` or `BOTTOM` but these values are not checked upon assignment.
                    *
                    * @property vertical
                    * @type string
                    * @default 'top'
                    * @since 1.3.0
                    * @public
                    */
                    get: function () {
                        return this._verticalOrigin;
                    },
                    set: function (val) {
                        //Reset the current
                        this.container.style[this._verticalOrigin] = 'auto';
                        //Set the new value
                        this._verticalOrigin = val;
                        this.container.style[this._verticalOrigin] = this.y + 'px';
                        //Loop through the children and apply the same origin
                        var i = 0;
                        while (i < this._icons.length) {
                            this._icons[i].verticalOrigin = val;
                            i++;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                return IconBar;
            })(Kiwi.HUD.HUDWidget);
            Widget.IconBar = IconBar;
        })(Widget = HUD.Widget || (HUD.Widget = {}));
    })(HUD = Kiwi.HUD || (Kiwi.HUD = {}));
})(Kiwi || (Kiwi = {}));
/**
* @module HUD
* @submodule Widget
*/
var Kiwi;
(function (Kiwi) {
    var HUD;
    (function (HUD) {
        var Widget;
        (function (Widget) {
            /**
            * A subclass of textfield that is primarily used to keep track of a score.
            * The score can be accessed via the counter component.
            *
            * @class BasicScore
            * @extends Kiwi.HUD.TextField
            * @namespace Kiwi.HUD.Widget
            * @constructor
            * @param game {Kiwi.Game} The game that this BasicScore belongs to.
            * @param x {number} The cooridnates of the game on the x-axis.
            * @param y {number} The cooridnates of the game on the y-axis.
            * @param [initial=0] {number} The initial score to start off at.
            * @return {Kiwi.HUD.Widget.BasicScore}
            */
            var BasicScore = (function (_super) {
                __extends(BasicScore, _super);
                function BasicScore(game, x, y, initial) {
                    if (initial === void 0) { initial = 0; }
                    _super.call(this, game, "basicScore", x, y);
                    this.name = 'basicScore';
                    this.class = 'kiwi-basicscore-widget kiwi-widget';
                    this.counter = this.components.add(new Kiwi.HUD.HUDComponents.Counter(this, initial));
                    this.counter.updated.add(this._updateText, this);
                    this._updateText();
                }
                /**
                * Returns the type of object that this is.
                * @method objType
                * @return {String} "BasicScoreWidget"
                * @public
                */
                BasicScore.prototype.objType = function () {
                    return 'BasicScoreWidget';
                };
                /**
                * Updates the text inside the textfield.
                * @method _updateText
                * @private
                */
                BasicScore.prototype._updateText = function () {
                    this.text = String(this.counter.current);
                };
                return BasicScore;
            })(Kiwi.HUD.Widget.TextField);
            Widget.BasicScore = BasicScore;
        })(Widget = HUD.Widget || (HUD.Widget = {}));
    })(HUD = Kiwi.HUD || (Kiwi.HUD = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module HUD
* @submodule Widget
*
*/
var Kiwi;
(function (Kiwi) {
    var HUD;
    (function (HUD) {
        var Widget;
        (function (Widget) {
            /**
            * A subclass of the TextField that has its own input component so that you can listen for mouse events on this widget.
            *
            * @class Button
            * @extends Kiwi.HUD.TextField
            * @namespace Kiwi.HUD.Widget
            * @constructor
            * @param game {Kiwi.Game} The game that this belongs to.
            * @param text {string} The text that you want to display inside the button.
            * @param x {number} The x-coordnates of this Widget.
            * @param y {number} The y-coordinates of this Widget.
            * @return {Kiwi.HUD.Widget.Button}
            */
            var Button = (function (_super) {
                __extends(Button, _super);
                function Button(game, text, x, y) {
                    _super.call(this, game, text, x, y);
                    this.name = 'button';
                    this.class = 'kiwi-button-widget kiwi-widget';
                    this.input = this.components.add(new Kiwi.HUD.HUDComponents.WidgetInput(this, this.container));
                }
                /**
                * The type of object that this is.
                * @method objType
                * @return {String} "ButtonWidget"
                * @public
                */
                Button.prototype.objType = function () {
                    return 'ButtonWidget';
                };
                return Button;
            })(Kiwi.HUD.Widget.TextField);
            Widget.Button = Button;
        })(Widget = HUD.Widget || (HUD.Widget = {}));
    })(HUD = Kiwi.HUD || (Kiwi.HUD = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module HUD
* @submodule Widget
*/
/*
* TO DO---- SIGNALS/CALLBACKS
*/
var Kiwi;
(function (Kiwi) {
    var HUD;
    (function (HUD) {
        var Widget;
        (function (Widget) {
            /**
            * A subclass of TextField which manages the displaying of a Time/Timer by creating a new clock on the Time Manager.
            * The time is managed by a Time Component which contains a format property that handles how the time should be formatted.
            *
            * @class Time
            * @extends Kiwi.HUD.Widget.TextField
            * @namespace Kiwi.HUD.Widget
            * @constructor
            * @param game {Kiwi.Game} The game that this object belongs to.
            * @param format {string} The format that you want the time to be displayed in. Leave it empty to display as normal.
            * @param x {number} The position of this text on the field.
            * @param y {number} The position of this text on the field.
            * @return {Kiwi.HUD.Widget.Time}
            */
            var Time = (function (_super) {
                __extends(Time, _super);
                function Time(game, format, x, y) {
                    _super.call(this, game, 'time', x, y);
                    this.name = 'time';
                    this.class = 'kiwi-time-widget kiwi-widget';
                    this.time = this.components.add(new Kiwi.HUD.HUDComponents.Time(this, format));
                }
                /**
                * The type of object that this is.
                * @method objType
                * @return {String} 'TimeWidget'
                * @public
                */
                Time.prototype.objType = function () {
                    return 'TimeWidget';
                };
                /**
                * Pauses the clock where is stands. Calls the pause method on the clock.
                * @method pause
                * @public
                */
                Time.prototype.pause = function () {
                    this.time.pause();
                };
                /**
                * Stops the clock and thus the time. Calls the stop method of the clock.
                * @method stop
                * @public
                */
                Time.prototype.stop = function () {
                    this.time.stop();
                };
                /**
                * Starts the clock and thus the time.
                * @method start
                * @public
                */
                Time.prototype.start = function () {
                    this.time.start();
                };
                /**
                * Resumes the clock and thus the time.
                * @method resume
                * @public
                */
                Time.prototype.resume = function () {
                    this.time.resume();
                };
                /**
                * The update loop.
                * @method update
                * @public
                */
                Time.prototype.update = function () {
                    _super.prototype.update.call(this);
                    //update the time
                    if (this.time.isRunning) {
                        this.text = this.time.getTime();
                    }
                };
                return Time;
            })(Kiwi.HUD.Widget.TextField);
            Widget.Time = Time;
        })(Widget = HUD.Widget || (HUD.Widget = {}));
    })(HUD = Kiwi.HUD || (Kiwi.HUD = {}));
})(Kiwi || (Kiwi = {}));
/**
* @module HUD
* @submodule Widget
*/
var Kiwi;
(function (Kiwi) {
    var HUD;
    (function (HUD) {
        var Widget;
        (function (Widget) {
            /**
            * A Widget for that is used for the management/displaying of a Menu.
            * This class is primarily used as a manager of MenuItems, so on this class you can create/add MenuItems
            * and styles that you want applyed to all MenuItems.
            *
            * @class Menu
            * @extends Kiwi.HUD.HUDWidget
            * @namespace Kiwi.HUD.Widget
            * @constructor
            * @param game {Kiwi.Game} The game that this Menu belongs to.
            * @param x {number} Its position on the x-axis.
            * @param y {number} Its position on the y -axis.
            * @return {Kiwi.HUD.Widget.Menu}
            */
            var Menu = (function (_super) {
                __extends(Menu, _super);
                function Menu(game, x, y) {
                    _super.call(this, game, 'menu', x, y);
                    this._menuItems = [];
                    this._styles = [];
                    this.class = 'kiwi-menu-widget kiwi-widget';
                }
                /**
                * The type of object that this is.
                * @method objType
                * @return {string} "MenuWidget"
                * @public
                */
                Menu.prototype.objType = function () {
                    return 'MenuWidget';
                };
                /**
                * Sets the style of all of the icons that will be on this menu.
                * @method setStyle
                * @param index {string}
                * @param value {string}
                * @public
                */
                Menu.prototype.setIconStyle = function (index, value) {
                    this._styles.push(({ 'index': index, 'value': value }));
                    for (var i = 0; i < this._menuItems.length; i++) {
                        this._menuItems[i].style[index] = value;
                    }
                };
                Object.defineProperty(Menu.prototype, "menuItems", {
                    /**
                    * Returns a list that contains all of the menu items (buttons) that are currently on this menu.
                    * Each item in the list is of the type Kiwi.HUD.Widget.MenuItem.
                    * Note: The array itself is READ ONLY but you can modify the objects contained inside of it.
                    * @property menuItems
                    * @type Array
                    * @public
                    */
                    get: function () {
                        return this._menuItems;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                * Creates a new menu item and add's it to this menu.
                * @method createMenuItem
                * @param text {string} The text that you would like the menu item to have.
                * @param x {number} The x position of the menu item you are wanting to add.
                * @param y {number} The y position of the menu item you are wanting to add.
                * @return {Kiwi.HUD.Widget.MenuItem} The newly created MenuItem.
                * @public
                */
                Menu.prototype.createMenuItem = function (text, x, y) {
                    return this.addMenuItem(new Kiwi.HUD.Widget.MenuItem(this.game, text, x, y));
                };
                /**
                * Adds a MenuItem to this menu.
                * @method addMenuItem
                * @param item {Kiwi.HUD.Widget.MenuItem} The MenuItem that you would like to add to this menu.
                * @return {Kiwi.HUD.Widget.MenuItem}
                * @public
                */
                Menu.prototype.addMenuItem = function (item) {
                    this._menuItems.push(item);
                    item.menu = this;
                    for (var i = 0; i < this._styles.length; i++) {
                        item.style[this._styles[i].index] = this._styles[i].value;
                    }
                    item.verticalOrigin = this.verticalOrigin;
                    item.horizontalOrigin = this.horizontalOrigin;
                    if (this._device == Kiwi.TARGET_BROWSER) {
                        this.container.appendChild(item.container);
                    }
                    return item;
                };
                /**
                * Adds multiple MenuItems to this Menu. Each item in the array you would like to add needs to be of the type Kiwi.HUD.Widget.MenuItem.
                * @method addMenuItems
                * @param items {Array} The array containing all of the menu items you want to add.
                * @public
                */
                Menu.prototype.addMenuItems = function (items) {
                    for (var i = 0; i < items.length; i++) {
                        this.addMenuItem(items[i]);
                    }
                };
                /**
                * Returns a MenuItem based on its corresponding numeric position that you pass in the array.
                * @method getMenuItem
                * @param val {Number}
                * @return {Kiwi.HUD.Widget.MenuItem}
                * @public
                */
                Menu.prototype.getMenuItem = function (val) {
                    return this._menuItems[val];
                };
                /**
                * Currently not supported or working.
                * @method setTemplate
                * @param main {string}
                * @param [sub] {string}
                * @public
                */
                Menu.prototype.setTemplate = function (main, sub) {
                    if (false) {
                        var mainElement = document.getElementById(main);
                        if (mainElement === undefined) {
                            return;
                        }
                        var subElements = mainElement.getElementsByTagName(sub);
                        if (subElements === undefined) {
                            return;
                        }
                        _super.prototype.setTemplate.call(this, main);
                    }
                };
                /**
                * Currently not supported or working.
                * @method removeTemplate
                * @public
                */
                Menu.prototype.removeTemplate = function () {
                };
                /**
                * The update loop.
                * @method update
                * @public
                */
                Menu.prototype.update = function () {
                    for (var i = 0; i < this._menuItems.length; i++) {
                        this._menuItems[i].update();
                    }
                    _super.prototype.update.call(this);
                };
                Object.defineProperty(Menu.prototype, "horizontalOrigin", {
                    /**
                    * Contains the current CSS style that will used for the x position.
                    * Should either be `LEFT` or `RIGHT` but these values are not checked upon assignment.
                    *
                    * @property horizontalOrigin
                    * @type string
                    * @default 'left'
                    * @since 1.3.0
                    * @public
                    */
                    get: function () {
                        return this._horizontalOrigin;
                    },
                    set: function (val) {
                        //Reset the current
                        this.container.style[this._horizontalOrigin] = 'auto';
                        //Set the new value
                        this._horizontalOrigin = val;
                        this.container.style[this._horizontalOrigin] = this.x + 'px';
                        //Loop through the children and apply the same origin
                        var i = 0;
                        while (i < this._menuItems.length) {
                            this._menuItems[i].horizontalOrigin = val;
                            i++;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Menu.prototype, "verticalOrigin", {
                    /**
                    * Contains the current CSS style that will used for the y position.
                    * Should either be `TOP` or `BOTTOM` but these values are not checked upon assignment.
                    *
                    * @property vertical
                    * @type string
                    * @default 'top'
                    * @since 1.3.0
                    * @public
                    */
                    get: function () {
                        return this._verticalOrigin;
                    },
                    set: function (val) {
                        //Reset the current
                        this.container.style[this._verticalOrigin] = 'auto';
                        //Set the new value
                        this._verticalOrigin = val;
                        this.container.style[this._verticalOrigin] = this.y + 'px';
                        //Loop through the children and apply the same origin
                        var i = 0;
                        while (i < this._menuItems.length) {
                            this._menuItems[i].verticalOrigin = val;
                            i++;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                return Menu;
            })(Kiwi.HUD.HUDWidget);
            Widget.Menu = Menu;
        })(Widget = HUD.Widget || (HUD.Widget = {}));
    })(HUD = Kiwi.HUD || (Kiwi.HUD = {}));
})(Kiwi || (Kiwi = {}));
/**
* @module HUD
* @submodule Widget
*/
var Kiwi;
(function (Kiwi) {
    var HUD;
    (function (HUD) {
        var Widget;
        (function (Widget) {
            /**
            * A MenuItem extends the Button Widget and is typically contained inside of a Menu Widget.
            * Since a MenuItem extends the Button Widget you can access the Input Component that it has to listen to mouse events.
            *
            * @class MenuItem
            * @extends Kiwi.HUD.Widget.Button
            * @namespace Kiwi.HUD.Widget
            * @constructor
            * @param game {Kiwi.Game} The game that this MenuItem belongs to.
            * @param text {string} The text that is to be inside the menuitem.
            * @param x {number} The position of this menu item on the x-axis.
            * @param y {number} The position of this menu item on the y-axis.
            * @return {Kiwi.HUD.Widget.MenuItem}
            */
            var MenuItem = (function (_super) {
                __extends(MenuItem, _super);
                function MenuItem(game, text, x, y) {
                    _super.call(this, game, text, x, y);
                    this.name = 'menuItem';
                    this.class = 'kiwi-menuitem-widget kiwi-widget';
                }
                /**
                * The type of object that this is.
                * @method objType
                * @return {string} "MenuItem"
                * @public
                */
                MenuItem.prototype.objType = function () {
                    return 'MenuItem';
                };
                return MenuItem;
            })(Kiwi.HUD.Widget.Button);
            Widget.MenuItem = MenuItem;
        })(Widget = HUD.Widget || (HUD.Widget = {}));
    })(HUD = Kiwi.HUD || (Kiwi.HUD = {}));
})(Kiwi || (Kiwi = {}));
/**
* HUDComponents are a space where components that are specific to HUDWidgets are kept. This are seperated from the normal Components section as the implementation of these are unique and only make sense when implemented on HUDWidgets, otherwise the concepts behind these are the same as normal Components.
*
* @module HUD
* @submodule HUDComponents
* @main HUDComponents
*/
var Kiwi;
(function (Kiwi) {
    var HUD;
    (function (HUD) {
        var HUDComponents;
        (function (HUDComponents) {
            /**
            * The Counter component handles a incrementation/decrementation of a singular numeric value.
            * You can also specifiy maximum/minimum values that the numeric value has be within but by default there is no max/min.
            *
            * @class Counter
            * @extends Kiwi.Component
            * @namespace Kiwi.HUD.HUDComponents
            * @constructor
            * @param owner {any} The object that this Component belongs to.
            * @param current {number} The current value.
            * @param [max=null] {number} The maximum value it can be. Default is null which means no maximum.
            * @param [min=null] {number} The minimum value that the current can be. Default is null which means no minium.
            * @return {Kiwi.HUD.HUDComponents.Counter}
            */
            var Counter = (function (_super) {
                __extends(Counter, _super);
                function Counter(owner, current, max, min) {
                    if (max === void 0) { max = null; }
                    if (min === void 0) { min = null; }
                    _super.call(this, owner, "counter");
                    this._current = current;
                    this._max = max;
                    this._min = min;
                    //signals!!!
                    this.updated = new Kiwi.Signal();
                }
                /**
                * The type of object that this is.
                * @method objType
                * @return {String} 'CounterComponent'
                * @public
                */
                Counter.prototype.objType = function () {
                    return 'CounterComponent';
                };
                Object.defineProperty(Counter.prototype, "max", {
                    get: function () {
                        return this._max;
                    },
                    /**
                    * Set allows setting of the maximum value that the range can be in.
                    * Get returns the maximum value.
                    *
                    * @property max
                    * @type number
                    * @public
                    */
                    set: function (val) {
                        this._max = val;
                        this.updated.dispatch(this._current, this._max, this._min);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Counter.prototype, "min", {
                    get: function () {
                        return this._min;
                    },
                    /**
                    * Set allows setting of the minimum value that the range can be in.
                    * Get returns the minimum value.
                    *
                    * @property min
                    * @type number
                    * @public
                    */
                    set: function (val) {
                        this._min = val;
                        this.updated.dispatch(this._current, this._max, this._min);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Counter.prototype, "current", {
                    get: function () {
                        return this._current;
                    },
                    /**
                    * Set allows setting of the current value that the range can be in.
                    * The current value will only change if it is within the maximum/minimum values.
                    * Get returns the current value.
                    *
                    * @property current
                    * @type number
                    * @public
                    */
                    set: function (val) {
                        if (this._max !== null && val > this._max) {
                            this._current = this._max;
                        }
                        else if (this._min !== null && val < this._min) {
                            this._current = this._min;
                        }
                        else {
                            this._current = val;
                        }
                        this.updated.dispatch(this._current, this._max, this._min);
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                * Decreases the current value by the amount past.
                * If the new amount would be less than the minimun it goes to the min instead.
                *
                * @method decrease
                * @param [val=1] {number} The amount that you want to decrease the current value by. Default is 1.
                * @return {number}
                * @public
                */
                Counter.prototype.decrease = function (val) {
                    if (val === void 0) { val = 1; }
                    if (this._min === null || this._current > this._min) {
                        if (this._min !== null && this._current - val < this._min) {
                            this._current = this._min;
                        }
                        else {
                            this._current -= val;
                        }
                        this.updated.dispatch(this._current, this._max, this._min);
                    }
                    return this._current;
                };
                /**
                * Increases the current value by the amount past.
                * If the new amount would be greater than the maximum it goes to the max instead.
                *
                * @method increase
                * @param [val=1] {number} The amount that you want to increase the current value by. Default is 1.
                * @return {number}
                * @public
                */
                Counter.prototype.increase = function (val) {
                    if (val === void 0) { val = 1; }
                    if (this._max === null || this._current < this._max) {
                        if (this._max !== null && this._current + val > this._max) {
                            this._current = this._max;
                        }
                        else {
                            this._current += val;
                        }
                        this.updated.dispatch(this._current, this._max, this._min);
                    }
                    return this._current;
                };
                /**
                * @method currentPercent
                * @return {number}
                * @public
                */
                Counter.prototype.currentPercent = function () {
                    if (this.max !== null)
                        return ((this.current) / (this.max)) * 100;
                };
                return Counter;
            })(Kiwi.Component);
            HUDComponents.Counter = Counter;
        })(HUDComponents = HUD.HUDComponents || (HUD.HUDComponents = {}));
    })(HUD = Kiwi.HUD || (Kiwi.HUD = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module HUD
* @submodule HUDComponents
*
*/
var Kiwi;
(function (Kiwi) {
    var HUD;
    (function (HUD) {
        var HUDComponents;
        (function (HUDComponents) {
            /**
            * The WidgetInput Component handles the input events that you may want to listen to on a widget.
            * This Component is essentually another version of the normal Input Component but instead of for GameObjects this is for HUDWidgets.
            *
            * @class WidgetInput
            * @extends Kiwi.Component
            * @namespace Kiwi.HUD.HUDComponents
            * @constructor
            * @param owner {any} The object that this WidgetInput belongs to.
            * @param container {HTMLElement} The HTMLElement that the events will occur on/to.
            * @return {Kiwi.HUD.HUDComponents.WidgetInput}
            */
            var WidgetInput = (function (_super) {
                __extends(WidgetInput, _super);
                function WidgetInput(owner, container) {
                    _super.call(this, owner, 'WidgetInput');
                    /**
                    * If the events are currently actively running or not.
                    * @property active
                    * @type boolean
                    * @private
                    */
                    this._active = false;
                    this._container = container;
                    //signals!!
                    this.onUp = new Kiwi.Signal;
                    this.onDown = new Kiwi.Signal;
                    this.onOver = new Kiwi.Signal;
                    this.onOut = new Kiwi.Signal;
                    this._addEvents();
                }
                /**
                * The type of object that this is.
                * @method objType
                * @return {String} 'WidgetInputComponent'
                * @public
                */
                WidgetInput.prototype.objType = function () {
                    return 'WidgetInputComponent';
                };
                /**
                * Changes the HTMLElement that the events are occuring on to one passed.
                * Removes all of the current events from container before changing.
                * @method setElement
                * @param container {HTMLElement} The new element that the events are going to occur on.
                * @public
                */
                WidgetInput.prototype.setElement = function (container) {
                    this._removeEvents();
                    this._container = container;
                    this._addEvents();
                };
                /**
                * Creates new bindings and adds the events to the HTMLElement.
                * @method _addEvents
                * @private
                */
                WidgetInput.prototype._addEvents = function () {
                    if (!this._active) {
                        this._binds = [];
                        this._binds.push({ 'event': 'mouseup', 'function': this._up.bind(this) });
                        this._binds.push({ 'event': 'mousedown', 'function': this._down.bind(this) });
                        this._binds.push({ 'event': 'mouseover', 'function': this._over.bind(this) });
                        this._binds.push({ 'event': 'mouseout', 'function': this._out.bind(this) });
                        for (var i = 0; i < this._binds.length; i++) {
                            this._container.addEventListener(this._binds[i].event, this._binds[i].function, false);
                        }
                        this._active = true;
                    }
                };
                /**
                * Removes the events off of the current container.
                * @method _removeEvents
                * @private
                */
                WidgetInput.prototype._removeEvents = function () {
                    if (this._active) {
                        for (var i = 0; i < this._binds.length; i++) {
                            this._container.removeEventListener(this._binds[i].event, this._binds[i].function, false);
                        }
                        this._binds = [];
                        this._active = false;
                    }
                };
                /**
                * The method that is called when a mouseup event fires. The onUp Signal is called.
                * @method _up
                * @param evt {MouseEvent}
                * @private
                */
                WidgetInput.prototype._up = function (evt) {
                    this.onUp.dispatch(evt);
                };
                /**
                * The method that is called when a mousedown event fires. The onDown Signal is called.
                * @method _down
                * @param evt {MouseEvent}
                * @private
                */
                WidgetInput.prototype._down = function (evt) {
                    this.onDown.dispatch(evt);
                };
                /**
                * The method that is called when a mouseover event fires. The onOver Signal is called.
                * @method _over
                * @param evt {MouseEvent}
                * @private
                */
                WidgetInput.prototype._over = function (evt) {
                    this.onOver.dispatch(evt);
                };
                /**
                * The method that is called when a mouseout event fires. The onOut Signal is called.
                * @method _out
                * @param evt {MouseEvent}
                * @private
                */
                WidgetInput.prototype._out = function (evt) {
                    this.onOut.dispatch(evt);
                };
                return WidgetInput;
            })(Kiwi.Component);
            HUDComponents.WidgetInput = WidgetInput;
        })(HUDComponents = HUD.HUDComponents || (HUD.HUDComponents = {}));
    })(HUD = Kiwi.HUD || (Kiwi.HUD = {}));
})(Kiwi || (Kiwi = {}));
/**
 *
 * @module HUD
 * @submodule HUDComponents
 *
*/
var Kiwi;
(function (Kiwi) {
    var HUD;
    (function (HUD) {
        var HUDComponents;
        (function (HUDComponents) {
            /**
            * A Component to manage and display a Time in a particular format.
            * The Time Component creates a new clock on the Time Manager and it uses that clock to keep track of the time.
            * When you create a new Time Component you can specify a format that you want the time to display in, which is a string based on keywords.
            * Current supported keywords for the format are:
            *  's' = 'seconds'
            *  'm' = 'minutes'
            *  'ms' = milliseconds'
            *  'ss' = 'seconds with leading zero'
            *  'mm' = 'minutes with leading zero'
            *
            * @class Time
            * @extends Kiwi.Component
            * @namespace Kiwi.HUD.HUDComponents
            * @constructor
            * @param owner {any} The object that this component belongs to.
            * @param [format=''] {string} The format that the time is to be displayed in. Leave blank for the default time.
            * @return {Kiwi.HUD.HUDComponents.Counter}
            */
            var Time = (function (_super) {
                __extends(Time, _super);
                function Time(owner, format) {
                    if (format === void 0) { format = ''; }
                    _super.call(this, owner, "time");
                    /**
                    * If the clock should 'count down' instead of up.
                    * @property countDown
                    * @type boolean
                    * @default false
                    * @public
                    */
                    this.countDown = false;
                    /**
                    * Used during the formatting stage of displaying the time.
                    * @property _displayString
                    * @type string
                    * @private
                    */
                    this._displayString = '';
                    /**
                    * The current time in seconds.
                    * @property _currentTime
                    * @type number
                    * @private
                    */
                    this._currentTime = 0;
                    /**
                    * The last time that the timer update. Used to calculate the time delta.
                    * @property _timeBefore
                    * @type number
                    * @private
                    */
                    this._timeBefore = 0;
                    /**
                    * The speed at which the time will increase/decrease by.
                    * Modify this property to make the time count down slower/faster.
                    * @property _speed
                    * @type number
                    * @default 1
                    * @private
                    */
                    this.speed = 1;
                    this.clock = this.game.time.addClock(name + '-clock', 1000);
                    this.format = format;
                }
                /**
                * The type of object that this is.
                * @method objType
                * @return {String} 'TimeComponent'
                * @public
                */
                Time.prototype.objType = function () {
                    return 'TimeComponent';
                };
                Object.defineProperty(Time.prototype, "isRunning", {
                    /**
                    * Indicates whether or not the clock is currently running or not, and thus whether or not the time is playing or not.
                    * @property isRunning
                    * @type boolean
                    * @public
                    */
                    get: function () {
                        return this.clock.isRunning();
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                * Pauses the clock where is stands. Calls the pause method on the clock.
                * @method pause
                * @public
                */
                Time.prototype.pause = function () {
                    this.clock.pause();
                };
                /**
                * Stops the clock and thus the time. Calls the stop method of the clock.
                * @method stop
                * @public
                */
                Time.prototype.stop = function () {
                    this.clock.stop();
                };
                /**
                * Starts the clock and thus the time.
                * @method start
                * @public
                */
                Time.prototype.start = function () {
                    this.clock.start();
                    this._timeBefore = this.clock.elapsed();
                };
                /**
                * Resumes the clock and thus the time.
                * @method resume
                * @public
                */
                Time.prototype.resume = function () {
                    this.clock.resume();
                };
                Object.defineProperty(Time.prototype, "format", {
                    get: function () {
                        return this._format;
                    },
                    /**
                    * The format that you want the time to be displayed in.
                    * @property format
                    * @type string
                    * @public
                    */
                    set: function (val) {
                        this._format = val;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Time.prototype, "currentTime", {
                    /**
                    * The current time in seconds. This is READ ONLY.
                    * @property currentTime
                    * @type number
                    * @public
                    */
                    get: function () {
                        return this._currentTime;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                * Sets the current time of the timer.
                * @method setTime
                * @param milli {number} The number of milliseconds.
                * @param [sec=0] {number} The number of seconds to add.
                * @param [minutes=0] {number} The number of minutes to add.
                * @public
                */
                Time.prototype.setTime = function (milli, sec, minutes) {
                    if (sec === void 0) { sec = 0; }
                    if (minutes === void 0) { minutes = 0; }
                    this._currentTime = milli;
                    if (sec != 0)
                        this._currentTime += (sec * 1000);
                    if (minutes != 0)
                        this._currentTime += (minutes * 60 * 1000);
                };
                /**
                * Increases the current time by the amount passed.
                * @method addTime
                * @param milli {number} The number of milliseconds.
                * @param [sec=0] {number} The number of seconds to add.
                * @param [minutes=0] {number} The number of minutes to add.
                * @public
                */
                Time.prototype.addTime = function (milli, sec, minutes) {
                    if (sec === void 0) { sec = 0; }
                    if (minutes === void 0) { minutes = 0; }
                    this._currentTime += milli;
                    if (sec != 0)
                        this._currentTime += (sec * 1000);
                    if (minutes != 0)
                        this._currentTime += (minutes * 60 * 1000);
                };
                /**
                * Decreases the current time by the amount passed.
                * @method removeTime
                * @param milli {number} The number of milliseconds.
                * @param [sec=0] {number} The number of seconds to add.
                * @param [minutes=0] {number} The number of minutes to add.
                * @public
                */
                Time.prototype.removeTime = function (milli, sec, minutes) {
                    if (sec === void 0) { sec = 0; }
                    if (minutes === void 0) { minutes = 0; }
                    this._currentTime -= milli;
                    if (sec != 0)
                        this._currentTime -= (sec * 1000);
                    if (minutes != 0)
                        this._currentTime -= (minutes * 60 * 1000);
                };
                /**
                * Returns a string with the current time that this component is upto in the format that was passed.
                *
                * @method updateTime
                * @return string
                * @public
                */
                Time.prototype.getTime = function () {
                    if (this.countDown) {
                        this._currentTime -= (this.clock.elapsed() - this._timeBefore) * this.speed;
                    }
                    else {
                        this._currentTime += (this.clock.elapsed() - this._timeBefore) * this.speed;
                    }
                    this._timeBefore = this.clock.elapsed();
                    //format time
                    if (this._format !== '') {
                        this._displayString = this._format;
                        //milliseconds
                        if (this._displayString.indexOf('ms') !== -1) {
                            var t = String(Math.floor(this._currentTime * 1000) % 1000);
                            this._displayString = this._displayString.replace('ms', t);
                        }
                        //seconds - leading
                        if (this._displayString.indexOf('ss') != -1) {
                            var t = String(Math.floor(this._currentTime) % 60);
                            if (t.length < 2)
                                t = '0' + t;
                            this._displayString = this._displayString.replace('ss', t);
                        }
                        //minutes - leading
                        if (this._displayString.indexOf('mm') !== -1) {
                            var t = String(Math.floor(this._currentTime / 60) % 60);
                            if (t.length < 2)
                                t = '0' + t;
                            this._displayString = this._displayString.replace('mm', t);
                        }
                        //minutes - no leading
                        if (this._displayString.indexOf('s') != -1) {
                            var t = String(Math.floor(this._currentTime) % 60);
                            this._displayString = this._displayString.replace('s', t);
                        }
                        //seconds - no leading
                        if (this._displayString.indexOf('m') !== -1) {
                            var t = String(Math.floor(this._currentTime / 60) % 60);
                            this._displayString = this._displayString.replace('m', t);
                        }
                        return this._displayString;
                    }
                    else {
                        return String(this._currentTime.toFixed(2));
                    }
                };
                return Time;
            })(Kiwi.Component);
            HUDComponents.Time = Time;
        })(HUDComponents = HUD.HUDComponents || (HUD.HUDComponents = {}));
    })(HUD = Kiwi.HUD || (Kiwi.HUD = {}));
})(Kiwi || (Kiwi = {}));
/**
* The namespace that holds all of the assets and functionality when dealing with Audio.
*
* @module Kiwi
* @submodule Sound
* @main Sound
*
*/
var Kiwi;
(function (Kiwi) {
    var Sound;
    (function (Sound) {
        /**
        * Manages the initialisation of assets necessary when dealing with audio in the game, either through Audio Tags or the Web Audio API.
        * Also provides global sound controls that will be applyed to all Audio objects at the same time, within the Game this manager is a part of.
        *
        * @class AudioManager
        * @constructor
        * @namespace Kiwi.Sound
        * @param game {Kiwi.Game} The game that this audio manager belongs to.
        * @return {Kiwi.Sound.AudioManager}
        */
        var AudioManager = (function () {
            function AudioManager(game) {
                /**
                * If the current game has audio support or not.
                * Useful because audio support is spotty in mobile browsers.
                * @property noAudio
                * @type boolean
                * @public
                */
                this.noAudio = false;
                /**
                * If the game is currently using the Web Audio API for the sound.
                * @property usingWebAudio
                * @type boolean
                * @public
                */
                this.usingWebAudio = false;
                /**
                * If the game is using audio tags for the sound. This is the fallback if the web audio api is not supported.
                * @property usingAudioTag
                * @type boolean
                * @public
                */
                this.usingAudioTag = false;
                /**
                * Web Audio API ONLY - The audio context that is used for decoding audio, e.t.c.
                * @property context
                * @type any
                * @public
                */
                this.context = null;
                /**
                * Web Audio API ONLY - The master gain node through which all sounds play.
                * @property masterGain
                * @type any
                * @public
                */
                this.masterGain = null;
                /**
                * Sound buffer
                * @property _unlockedSource
                * @type {any}
                * @private
                */
                this._unlockedSource = null;
                this._game = game;
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String} "AudioManager"
            * @public
            */
            AudioManager.prototype.objType = function () {
                return "AudioManager";
            };
            Object.defineProperty(AudioManager.prototype, "locked", {
                /**
                * Returns a boolean indicating whether the device has been touched or not. READ ONLY.
                * @property locked
                * @type boolean
                * @public
                */
                get: function () {
                    return this._locked;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * The boot method is executed when all of the DOM elements needed for the game are loaded and the game is ready to 'start' up.
            *
            * @method boot
            * @public
            */
            AudioManager.prototype.boot = function () {
                this._volume = 1;
                this._muted = false;
                this._sounds = [];
                //check to see if it is an iOS device and if it doesn't support webAudio
                if (Kiwi.DEVICE.iOS && Kiwi.DEVICE.webaudio == false) {
                    this.channels = 1;
                }
                //Add mouse event here to 'unlock' the device.
                if (Kiwi.DEVICE.iOS && this._game.deviceTargetOption !== Kiwi.TARGET_COCOON) {
                    this._locked = true;
                    this._game.input.onUp.addOnce(this._unlocked, this);
                    Kiwi.Log.log('Kiwi.AudioManager: Audio is currently Locked until at touch event.', '#audio', '#locked');
                }
                else {
                    this._locked = false;
                }
                this.usingWebAudio = true; //we hope for the best....
                this.usingAudioTag = false;
                if (!!window['AudioContext']) {
                    this.context = new window['AudioContext']();
                }
                else if (!!window['webkitAudioContext']) {
                    this.context = new window['webkitAudioContext']();
                }
                else if (!!window['Audio']) {
                    this.usingWebAudio = false;
                    this.usingAudioTag = true;
                }
                else {
                    this.usingWebAudio = false;
                    this.noAudio = true; //prepared for the worst :(
                }
                if (this.context !== null) {
                    if (this.context.createGain === undefined) {
                        this.masterGain = this.context.createGainNode();
                    }
                    else {
                        this.masterGain = this.context.createGain();
                    }
                    this.masterGain.gain.value = 1;
                    this.masterGain.connect(this.context.destination);
                }
            };
            /**
            * Is executed when a mouse event is fired on the device. This is used to enabled playback of sounds on the current device if they were awaiting for a user event.
            * @method _unlocked
            * @private
            */
            AudioManager.prototype._unlocked = function () {
                Kiwi.Log.log('Kiwi.AudioManager: Audio now Unlocked.', '#audio', '#unlocked');
                if (this.usingAudioTag) {
                    this._locked = false;
                    for (var i = 0; i < this._sounds.length; i++) {
                        this._sounds[i].playable = true;
                    }
                }
                else {
                    // Create empty buffer and play it
                    var buffer = this.context.createBuffer(1, 1, 22050);
                    this._unlockedSource = this.context.createBufferSource();
                    this._unlockedSource.buffer = buffer;
                    this._unlockedSource.connect(this.context.destination);
                    if (this._unlockedSource.start === undefined) {
                        this._unlockedSource.noteOn(0);
                    }
                    else {
                        this._unlockedSource.start(0);
                    }
                }
            };
            Object.defineProperty(AudioManager.prototype, "mute", {
                get: function () {
                    return this._muted;
                },
                /**
                * Used to mute the audio on the device, or to check to see if the device is muted.
                * This will not stop audio from being played, will just mean that the audio is silent.
                *
                * @property mute
                * @type boolean
                * @default false
                * @public
                */
                set: function (value) {
                    if (value === true) {
                        if (this._muted)
                            return;
                        this._muted = true;
                        //mute the sounds 
                        if (this.usingWebAudio) {
                            this._muteVolume = this.masterGain.gain.value;
                            this.masterGain.gain.value = 0;
                        }
                        else if (this.usingAudioTag) {
                            for (var i = 0; i < this._sounds.length; i++) {
                                this._sounds[i].mute = true;
                            }
                        }
                    }
                    else {
                        if (this._muted == false)
                            return;
                        this._muted = false;
                        if (this.usingWebAudio) {
                            this.masterGain.gain.value = this._muteVolume;
                        }
                        else if (this.usingAudioTag) {
                            for (var i = 0; i < this._sounds.length; i++) {
                                this._sounds[i].mute = false;
                            }
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(AudioManager.prototype, "volume", {
                get: function () {
                    return this._volume;
                },
                /**
                * Global setting and getting of the volume.
                * A number between 0 (silence) and 1 (full volume).
                *
                * @property volume
                * @type number
                * @default 1
                * @public
                */
                set: function (value) {
                    if (value !== undefined) {
                        value = Kiwi.Utils.GameMath.clamp(value, 1, 0);
                        this._volume = value;
                        if (this._muted) {
                            this._muteVolume = this._volume;
                        }
                        if (this.usingWebAudio) {
                            this.masterGain.gain.value = value;
                        }
                        else if (this.usingAudioTag) {
                            for (var i = 0; i < this._sounds.length; i++) {
                                //for each sound tag to update.
                                this._sounds[i].volume = this._sounds[i].volume;
                            }
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Indicates whether or not an Audio Object is registered with this Audio Manager or not. For Kiwi Internal use only.
            * @method isRegistered
            * @param sound {Audio} The Audio object you are checking for.
            * @return {Boolean} If the piece of audio is registered or not.
            * @public
            */
            AudioManager.prototype.isRegistered = function (sound) {
                if (this.noAudio)
                    return;
                if (this._sounds.indexOf(sound) !== -1) {
                    return true;
                }
                else {
                    return false;
                }
            };
            /**
            * Registers an Audio Object with this audio manager. Also assign's the audio piece a unique ID to identify it by. Internal Kiwi use only.
            * @method registerSound
            * @param sound {Audio} The audio piece you are wanting to register.
            * @return { Boolean } Indication of if the sound was successfully added or not.
            * @public
            */
            AudioManager.prototype.registerSound = function (sound) {
                if (this.isRegistered(sound) === false) {
                    sound.id = this._game.rnd.uuid();
                    this._sounds.push(sound);
                    return true;
                }
                return false;
            };
            /**
            * Used to create a new sound on the audio manager. Returns the newly created sound.
            *
            * @method add
            * @param key {string} The key for the audio file that is to be loaded from the AudioLibrary.
            * @param [volume=1] {number} The volume for the piece of audio.
            * @param [loop=false] {boolean} If the audio should keep repeat when it gets to the end.
            * @return {Kiwi.Sound.Audio}
            * @public
            */
            AudioManager.prototype.add = function (key, volume, loop) {
                if (volume === void 0) { volume = 1; }
                if (loop === void 0) { loop = false; }
                if (this.noAudio)
                    return;
                var sound = new Kiwi.Sound.Audio(this._game, key, volume, loop);
                return sound;
            };
            /**
            * Removes the passed sound from the AudioManager.
            * If you remove a Audio Object from the AudioManager, then that Audio Object will not have a update loop.
            *
            * @method remove
            * @param sound {Kiwi.Sound.Audio} The Audio object that you want to remove.
            * @param [destory=true] If the Audio Object should be removed or not.
            * @public
            */
            AudioManager.prototype.remove = function (sound, destroy) {
                if (destroy === void 0) { destroy = true; }
                for (var i = 0; i < this._sounds.length; i++) {
                    if (sound.id == this._sounds[i].id) {
                        if (this.usingWebAudio && sound.gainNode)
                            sound.gainNode.disconnect();
                        if (destroy == true)
                            sound.destroy();
                        this._sounds.splice(i, 1);
                        return;
                    }
                }
            };
            /**
            * Plays all of the sounds listed in the AudioManager.
            * @method playAll
            * @public
            */
            AudioManager.prototype.playAll = function () {
                for (var i = 0; i < this._sounds.length; i++) {
                    if (this._sounds[i]) {
                        this._sounds[i].play();
                    }
                }
            };
            /**
            * Stops all of the sounds that are listed in the AudioManager from playing.
            * @method stopAll
            * @public
            */
            AudioManager.prototype.stopAll = function () {
                for (var i = 0; i < this._sounds.length; i++) {
                    if (this._sounds[i]) {
                        this._sounds[i].stop();
                    }
                }
            };
            /**
            * Pauses all of the sounds listed in the AudioManager.
            * @method pauseAll
            * @public
            */
            AudioManager.prototype.pauseAll = function () {
                for (var i = 0; i < this._sounds.length; i++) {
                    if (this._sounds[i]) {
                        this._sounds[i].pause();
                    }
                }
            };
            /**
            * Resumes all of the sounds listed in the AudioManager.
            * @method resumeAll
            * @public
            */
            AudioManager.prototype.resumeAll = function () {
                for (var i = 0; i < this._sounds.length; i++) {
                    if (this._sounds[i]) {
                        this._sounds[i].resume();
                    }
                }
            };
            /**
            * The update loop that is executed every frame.
            * @method update
            * @public
            */
            AudioManager.prototype.update = function () {
                if (this._locked) {
                    if (this.usingWebAudio && this._unlockedSource !== null) {
                        if ((this._unlockedSource.playbackState === this._unlockedSource.PLAYING_STATE || this._unlockedSource.playbackState === this._unlockedSource.FINISHED_STATE)) {
                            this._locked = false;
                            this._unlockedSource = null;
                            for (var i = 0; i < this._sounds.length; i++) {
                                this._sounds[i].playable = true;
                            }
                        }
                    }
                }
                if (!this.noAudio) {
                    for (var i = 0; i < this._sounds.length; i++) {
                        this._sounds[i].update();
                    }
                }
            };
            return AudioManager;
        })();
        Sound.AudioManager = AudioManager;
    })(Sound = Kiwi.Sound || (Kiwi.Sound = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Sound
*
*/
var Kiwi;
(function (Kiwi) {
    var Sound;
    (function (Sound) {
        /**
        * The Audio Object contains the functionality for playing a singular sound in a Kiwi Game.
        * The Audio can contain Audio Sprites which is a nice way to play audio on mobile devices.
        * Audio Objects do not 'die' when game states are switched or changed.
        *
        * @class Audio
        * @constructor
        * @namespace Kiwi.Sound
        * @param game {Kiwi.Game} The game that this piece of audio belongs to.
        * @param key {string} The key to which which piece of audio should be loaded from the AudioLibrary.
        * @param volume {number} A number between 0 (silence) and 1 (loud).
        * @param loop {boolean} If the audio should loop when it is finished or just stop.
        * @return {Kiwi.Sound.Audio} This object
        *
        */
        var Audio = (function () {
            function Audio(game, key, volume, loop) {
                /**
                * A private indicator of whether this audio is currently muted or not.
                * @property _muted
                * @type boolean
                * @default false
                * @private
                */
                this._muted = false;
                /**
                * The total duration of the audio in seconds.
                * @property totalDuration
                * @type number
                * @public
                */
                this.totalDuration = 0;
                /**
                * Web Audio API ONLY - The audio buffer that is to be used when playing audio segments.
                * @property _buffer
                * @type any
                * @private
                */
                this._buffer = null;
                /**
                * Web Audio API ONLY - A boolean to indicate if the audio has been decoded or not yet. If not you will need to run the decode() method.
                * @property _decoded
                * @type boolean
                * @default false
                * @private
                */
                this._decoded = false;
                /**
                * A collection of all of the markers that are on this piece of audio.
                * @property _markers
                * @type object
                * @private
                */
                this._markers = {};
                /**
                * The current marker that is being used.
                * @property _currentMarker
                * @type String
                * @default 'default'
                * @private
                */
                this._currentMarker = 'default';
                this.ready = false;
                this._game = game;
                this._game.audio.registerSound(this);
                this._usingAudioTag = this._game.audio.usingAudioTag;
                this._usingWebAudio = this._game.audio.usingWebAudio;
                this._playable = (this._game.audio.locked == true) ? false : true;
                this.duration = 0;
                this._volume = volume;
                this._muteVolume = volume;
                this._muted = this._game.audio.mute;
                this._loop = loop;
                this.key = key;
                if (!Kiwi.Utils.Common.isString(this.key) && this.key.isAudio) {
                    this.key = this.key.key;
                }
                //If audio isn't supported OR the file does not exist
                if (this._game.audio.noAudio || this._game.fileStore.exists(this.key) === false) {
                    Kiwi.Log.log('Could not play Audio. Either the browser doesn\'t support audio or the Audio file was not found on the filestore.', '#audio', '#notfound');
                    return;
                }
                //Setup the Web AUDIO API Sound
                if (this._usingWebAudio) {
                    this._setAudio();
                    if (this.ready) {
                        this.context = this._game.audio.context;
                        this.masterGainNode = this._game.audio.masterGain;
                        //create our gain node
                        if (typeof this.context.createGain === 'undefined') {
                            this.gainNode = this.context.createGainNode();
                        }
                        else {
                            this.gainNode = this.context.createGain();
                        }
                        //make sure the audio is decoded.
                        this._decode();
                        this.gainNode.gain.value = this.volume * this._game.audio.volume; //this may need to change.....
                        this.gainNode.connect(this.masterGainNode);
                    }
                }
                else if (this._usingAudioTag) {
                    if (this._playable === true) {
                        this._setAudio();
                        if (this.ready) {
                            this.totalDuration = this._sound.duration;
                            this._sound.volume = this.volume * this._game.audio.volume;
                            if (isNaN(this.totalDuration) || this.totalDuration == 0)
                                this._pending = true;
                        }
                    }
                }
                this.addMarker('default', 0, this.totalDuration, this._loop);
                this._currentMarker = 'default';
                //tonnes of signals to go here.
                this.onPlay = new Kiwi.Signal();
                this.onStop = new Kiwi.Signal();
                this.onPause = new Kiwi.Signal();
                this.onResume = new Kiwi.Signal();
                this.onLoop = new Kiwi.Signal();
                this.onMute = new Kiwi.Signal();
                this.onComplete = new Kiwi.Signal();
            }
            Object.defineProperty(Audio.prototype, "playable", {
                /**
                * Returns whether or not the sound is 'playable' or not.
                * The only time the sound would be not 'playable' is on iOS devices when a mouse/touch event has not fired.
                * Devs should treat this property as READ ONLY.
                * @property playable
                * @type boolean
                * @private
                */
                get: function () {
                    return this._playable;
                },
                set: function (val) {
                    if (this._playable !== true && val == true) {
                        this._playable = val;
                        this._setAudio();
                        if (this.ready && this._usingAudioTag) {
                            this.totalDuration = this._sound.duration;
                            this._sound.volume = this.volume * this._game.audio.volume;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });
            /**
            * The type of object that this is.
            * @method objType
            * @return {String} "Audio"
            * @public
            */
            Audio.prototype.objType = function () {
                return "Audio";
            };
            Object.defineProperty(Audio.prototype, "loop", {
                /**
                * READ ONLY: Returns a boolean indicating if the current audio marker playing is/will loop.
                * @property loop
                * @readOnly
                * @type Boolean
                * @public
                */
                get: function () {
                    return this._loop;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Retrieves the audio data from the file store.
            * @method _setAudio
            * @private
            */
            Audio.prototype._setAudio = function () {
                this._file = this._game.fileStore.getFile(this.key);
                //Does the data actually exist?
                if (typeof this._file.data == "undefined")
                    return;
                //force the browser to play it at least for a little bit
                if (this._usingAudioTag) {
                    //clone the audio node
                    this._sound = this._file.data.cloneNode(true);
                    if (this._game.deviceTargetOption == Kiwi.TARGET_BROWSER) {
                        this._sound.play();
                        this._sound.pause();
                    }
                }
                else {
                    this._sound = this._file.data;
                }
                this.ready = true;
            };
            /**
            * Decodes the audio data to make it playable. By default the audio should already have been decoded when it was loaded.
            *
            * @method _decode
            * @private
            */
            Audio.prototype._decode = function () {
                //You only decode when using the web audio api, when the audio has loaded and if it hasn't been decoded already
                if (this.ready == false || this._usingAudioTag)
                    return;
                //has the 
                if (this._file.data.decoded === true && this._file.data.buffer !== null) {
                    this._buffer = this._file.data.buffer;
                    this._decoded = true;
                    return;
                }
                var that = this;
                this.context.decodeAudioData(this._file.data.raw, function (buffer) {
                    that._buffer = buffer;
                    that._decoded = true;
                });
            };
            Object.defineProperty(Audio.prototype, "volume", {
                get: function () {
                    return this._volume;
                },
                /**
                * Used to control the current volume for this sound. 0 is silent, 1 is full volume.
                *
                * @property volume
                * @type number
                * @public
                */
                set: function (val) {
                    if (this._game.audio.noAudio || this.ready === false)
                        return;
                    val = Kiwi.Utils.GameMath.clamp(val, 1, 0);
                    this._volume = val;
                    if (this._muted) {
                        this._muteVolume = this._volume;
                    }
                    if (this._playable) {
                        if (this._usingWebAudio) {
                            this.gainNode.gain.value = this._volume * this._game.audio.volume; //this may need to change....
                        }
                        else if (this._usingAudioTag) {
                            this._sound.volume = this._volume * this._game.audio.volume;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Audio.prototype, "mute", {
                get: function () {
                    return this._muted;
                },
                /**
                * Mutes the sound and makes it 'silent'.
                * This will not stop the sound from playing, or events from being dispatched due when the sound has finished/is looping.
                *
                * @property mute
                * @type boolean
                * @public
                */
                set: function (val) {
                    if (this._game.audio.noAudio)
                        return;
                    if (val !== undefined && this._muted !== val) {
                        if (val === true) {
                            this._muteVolume = this._volume;
                            this.volume = 0;
                            this._muted = true;
                        }
                        else {
                            this._muted = false;
                            this.volume = this._muteVolume;
                        }
                        this.onMute.dispatch(this._muted);
                    }
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Adds a new marker to the audio which will then allow for that section of audio to be played.
            *
            * @method addMarker
            * @param name {string} The name of the marker that you are adding.
            * @param start {number} The starting point of the audio. In seconds.
            * @param stop {number} The stopping point of the audio. In seconds.
            * @param [loop=false] {boolean} If the marker's pieve of audio should loop or not.
            * @public
            */
            Audio.prototype.addMarker = function (name, start, stop, loop) {
                if (loop === void 0) { loop = false; }
                this._markers[name] = { start: start, stop: stop, duration: stop - start, loop: loop };
            };
            /**
            * Removes a currently existing marker from this audio.
            *
            * @method removeMarker
            * @param name {String} name of the audio that you want to remove.
            * @public
            */
            Audio.prototype.removeMarker = function (name) {
                if (name === 'default')
                    return; //cannot delete the default
                if (this.isPlaying && this._currentMarker == name) {
                    this.stop();
                    this._currentMarker = 'default';
                }
                delete this._markers[name];
            };
            /**
            * Plays the current sound/audio from the start.
            *
            * @method play
            * @param [marker] {string} The marker that is to be played. If no marker is specified then it will play the current marker (which would be the whole audio piece if no marker was ever added).
            * @param [forceRestart=false] {boolean} Force the audio to stop and start again. Otherwise if the audio was already playing it would ignore the play.
            * @public
            */
            Audio.prototype.play = function (marker, forceRestart) {
                if (marker === void 0) { marker = this._currentMarker; }
                if (forceRestart === void 0) { forceRestart = false; }
                if (this.isPlaying && !forceRestart || this._game.audio.noAudio)
                    return;
                if (forceRestart && !this._pending)
                    this.stop();
                if (typeof this._markers[marker] == "undefined")
                    return;
                //If its the current marker that is playing and shouldn't force restart then stop
                if (this._currentMarker === marker && this.isPlaying && forceRestart == false)
                    return;
                this.paused = false;
                this._currentMarker = marker;
                this.duration = this._markers[this._currentMarker].duration * 1000;
                this._loop = this._markers[this._currentMarker].loop;
                if (this._playable === false) {
                    this._pending = true;
                    return;
                }
                if (this._usingWebAudio) {
                    if (this._decoded === true) {
                        if (this._buffer == null)
                            this._buffer = this._file.data.buffer;
                        this._sound = this.context.createBufferSource();
                        this._sound.buffer = this._buffer;
                        this._sound.connect(this.gainNode);
                        this.totalDuration = this._sound.buffer.duration;
                        if (this.duration == 0)
                            this.duration = this.totalDuration * 1000;
                        //start
                        if (this._sound.start === undefined) {
                            this._sound.noteGrainOn(0, this._markers[this._currentMarker].start, this.duration / 1000);
                        }
                        else {
                            this._sound.start(0, this._markers[this._currentMarker].start, this.duration / 1000);
                        }
                        this.isPlaying = true;
                        this._startTime = this._game.time.now();
                        this._currentTime = 0;
                        this.onPlay.dispatch();
                    }
                    else {
                        this._pending = true;
                        this._decode();
                    }
                }
                else if (this._usingAudioTag) {
                    if (this._sound && this._sound.readyState == 4 || this._game.deviceTargetOption == Kiwi.TARGET_COCOON) {
                        if (this.duration == 0 || isNaN(this.duration))
                            this.duration = this.totalDuration * 1000;
                        if (this._muted)
                            this._sound.volume = 0;
                        else
                            this._sound.volume = this._volume;
                        this._sound.currentTime = this._markers[this._currentMarker].start;
                        this._sound.play();
                        this.isPlaying = true;
                        this._startTime = this._game.time.now();
                        this._currentTime = 0;
                        if (!this.paused)
                            this.onPlay.dispatch();
                    }
                    else {
                        this._pending = true;
                    }
                }
            };
            /**
            * Stop the sound from playing.
            * @method stop
            * @public
            */
            Audio.prototype.stop = function () {
                if (this.isPlaying && this._sound) {
                    if (this._usingWebAudio) {
                        if (this._sound.stop === undefined) {
                            this._sound.noteOff(0);
                        }
                        else {
                            this._sound.stop(0);
                        }
                    }
                    else if (this._usingAudioTag) {
                        this._sound.pause();
                        this._sound.currentTime = 0;
                    }
                    this.isPlaying = false;
                    if (this.paused == false)
                        this.onStop.dispatch();
                }
            };
            /**
            * Pauses the sound so that you can resume it from at point to paused it at.
            * @method pause
            * @public
            */
            Audio.prototype.pause = function () {
                if (this.isPlaying) {
                    this.paused = true;
                    this.stop();
                    this.onPause.dispatch();
                }
            };
            /**
            * Plays the sound from when you paused the sound.
            * @method resume
            * @public
            */
            Audio.prototype.resume = function () {
                if (this.paused && this.isPlaying == false) {
                    if (this._usingWebAudio) {
                        if (this._buffer == null)
                            this._buffer = this._file.data.buffer;
                        this._sound = this.context.createBufferSource();
                        this._sound.buffer = this._buffer;
                        this._sound.connect(this.gainNode);
                        if (this._sound.start === undefined) {
                            this._sound.noteGrainOn(0, this._markers[this._currentMarker].start + (this._currentTime / 1000), this.duration / 1000);
                        }
                        else {
                            this._sound.start(0, this._markers[this._currentMarker].start + (this._currentTime / 1000), this.duration / 1000);
                        }
                    }
                    else {
                        this._sound.currentTime = this._markers[this._currentMarker].start + this._currentTime / 1000;
                        this._sound.play();
                    }
                    this.paused = false;
                    this.isPlaying = true;
                    this.onResume.dispatch();
                }
            };
            /**
            * The update loop that gets executed every frame.
            * @method update
            * @public
            */
            Audio.prototype.update = function () {
                //Check to see that the audio is ready
                if (!this.ready)
                    return;
                //Is the audio ready to be played and was waiting?
                if (this._playable && this._pending) {
                    //Is it the using the Web Audio API (can tell otherwise the audio would not be decoding otherwise) and it is now ready to be played?
                    if (this._decoded === true || this._file.data && this._file.data.decoded) {
                        this._pending = false;
                        this.play();
                    }
                    else if (this._usingAudioTag && !isNaN(this._sound.duration) && this._sound.duration !== 0) {
                        this.totalDuration = this._sound.duration;
                        this._markers['default'].duration = this.totalDuration;
                        this._pending = false;
                        if (this.isPlaying && this._currentMarker == 'default')
                            this.duration = this.totalDuration * 1000;
                    }
                }
                //if the audio is playing
                if (this.isPlaying) {
                    this._currentTime = this._game.time.now() - this._startTime;
                    if (this._currentTime >= this.duration) {
                        if (this._loop) {
                            this.play(this._currentMarker, true);
                            this.onLoop.dispatch();
                        }
                        else {
                            this.onComplete.dispatch();
                            this.stop();
                        }
                    }
                }
            };
            /**
            * This method handles the destruction of all of the properties when this audio is not longer needed.
            * You call this method when you want this method to be removed on the next garbage collection cycle.
            *
            * @method destroy
            * @public
            */
            Audio.prototype.destroy = function () {
                if (this._game) {
                    this._game.audio.remove(this, false);
                }
                if (this.onLoop)
                    this.onLoop.dispose();
                if (this.onStop)
                    this.onStop.dispose();
                if (this.onPlay)
                    this.onPlay.dispose();
                if (this.onMute)
                    this.onMute.dispose();
                if (this.onPause)
                    this.onPause.dispose();
                if (this.onResume)
                    this.onResume.dispose();
                delete this.onLoop;
                delete this.onStop;
                delete this.onPause;
                delete this.onMute;
                delete this.onPlay;
                delete this.onResume;
                delete this._game;
                delete this._sound;
                delete this._currentTime;
                delete this._startTime;
                delete this._pending;
                delete this.masterGainNode;
                delete this.gainNode;
                delete this.totalDuration;
                delete this.duration;
                delete this._file;
                delete this._buffer;
                delete this._decoded;
            };
            return Audio;
        })();
        Sound.Audio = Audio;
    })(Sound = Kiwi.Sound || (Kiwi.Sound = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Sound
*
*/
var Kiwi;
(function (Kiwi) {
    var Sound;
    (function (Sound) {
        /**
        * Holds a reference to all of the Audio Files (mp3, ogg, e.t.c) that are accessible on the State that this AudioLibrary is on.
        *
        * @class AudioLibrary
        * @constructor
        * @namespace Kiwi.Sound
        * @param game {Kiwi.Game} The game that this audio library is a member of.
        * @return {Kiwi.Sound.AudioLibrary}
        */
        var AudioLibrary = (function () {
            function AudioLibrary(game) {
                this._game = game;
                this.audio = {};
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String} "AudioLibrary"
            * @public
            */
            AudioLibrary.prototype.objType = function () {
                return "AudioLibrary";
            };
            /**
            * Resets the audio library.
            * @method clear
            * @public
            */
            AudioLibrary.prototype.clear = function () {
                for (var prop in this.audio) {
                    delete this.audio[prop];
                }
            };
            /**
            * Rebuild the library from a fileStore. Clears the library and repopulates it.
            * @method rebuild
            * @param {Kiwi.Files.FileStore} fileStore
            * @param {Kiwi.State} state
            * @public
            */
            AudioLibrary.prototype.rebuild = function (fileStore, state) {
                this.clear();
                Kiwi.Log.log("Kiwi.AudioLibrary: Rebuilding Audio Library.", '#audio', '#rebuild');
                var fileStoreKeys = fileStore.keys;
                for (var i = 0; i < fileStoreKeys.length; i++) {
                    var file = this._game.fileStore.getFile(fileStoreKeys[i]);
                    if (file.isAudio) {
                        Kiwi.Log.log("  Kiwi.AudioLibrary: Adding Audio: " + file.name, '#audio', '#added');
                        state.audioLibrary.add(file);
                    }
                }
            };
            /**
            * Adds a new audio file to the audio library.
            * @method add
            * @param {Kiwi.Files.File} audioFile
            * @public
            */
            AudioLibrary.prototype.add = function (audioFile) {
                switch (audioFile.dataType) {
                    case Kiwi.Files.File.AUDIO:
                        this.audio[audioFile.key] = audioFile;
                        break;
                    default:
                        //Audio file is of unknown type and was not added to audio library
                        break;
                }
            };
            return AudioLibrary;
        })();
        Sound.AudioLibrary = AudioLibrary;
    })(Sound = Kiwi.Sound || (Kiwi.Sound = {}));
})(Kiwi || (Kiwi = {}));
/**
* @module Kiwi
* @submodule Time
*/
var Kiwi;
(function (Kiwi) {
    var Time;
    (function (Time) {
        /**
        * The Clock class offers a way of tracking time within a game.
        * When creating a new Clock you should NOT directly instantiate this class
        * but instead use the addClock method on a ClockManager.
        * - The MasterClock is a property of the Kiwi.Time.Manager class and tracks
        *   real world time in milliseconds elapsed since the application started.
        *   This happens automatically and there is no need to do anything to set
        *   this up.
        * - An instance of a clock is used to track time in arbitrary units
        *   (milliseconds by default)
        * - A clock can be started, paused, unpaused and stopped. Once stopped,
        *   re-starting the clock again will reset it. It can also have its time
        *   scale freely transformed.
        * - Any number of timers can be attached to a clock. See the Kiwi.Time.Timer
        *   class for timer details.
        * - If the clock is paused, any timers attached to the clock will take this
        *   into account and not continue to fire events until the clock is
        *   unpaused. (Note that this is not the same as pausing timers, which can
        *   be done manually and needs to be undone manually.)
        * - Animations and TweenManagers can use any Clock.
        *
        * @class Clock
        * @namespace Kiwi.Time
        * @constructor
        * @param manager {ClockManager} ClockManager that this clock belongs to
        * @param master {Kiwi.Time.MasterClock} MasterClock that this is getting
        *	the time in relation to
        * @param name {String} Name of the clock
        * @param [units=1000] {Number} Units that this clock is to operate in
        *	per second
        * @return {Kiwi.Time.Clock} This Clock object
        */
        var Clock = (function () {
            function Clock(manager, master, name, units) {
                if (units === void 0) { units = 1000; }
                /**
                * Time the clock was first started relative to the master clock
                * @property _timeFirstStarted
                * @type Number
                * @default null
                * @private
                */
                this._timeFirstStarted = null;
                /**
                * Most recent time the clock was started relative to the master clock
                * @property _timeLastStarted
                * @type Number
                * @default null
                * @private
                */
                this._timeLastStarted = null;
                /**
                * Rate at which time passes on this clock.
                * 1 is normal speed. 1.5 is faster. 0 is no speed. -1 is backwards.
                * This mostly affects timers, animations and tweens.
                * @property timeScale
                * @type number
                * @default 1.0
                * @public
                * @since 1.2.0
                */
                this.timeScale = 1.0;
                /**
                * Clock units elapsed since the clock was most recently started,
                * not including paused time.
                * @property _elapsed
                * @type number
                * @private
                * @since 1.2.0
                */
                this._elapsed = 0;
                /**
                * Rate of time passage, as modified by time scale and frame rate.
                * Under ideal conditions this should be 1.
                * If the frame rate drops, this will rise. Multiply transformations
                * by rate to get smooth change over time.
                * @property rate
                * @type number
                * @public
                * @since 1.2.0
                */
                this.rate = 1;
                /**
                * Maximum frame duration. If a frame takes longer than this to render,
                * the clock will only advance this far, in effect slowing down time.
                * If this value is 0 or less, it will not be checked and frames can
                * take any amount of time to render.
                * @property _maxFrameDuration
                * @type number
                * @default -1
                * @private
                */
                this._maxFrameDuration = -1;
                /**
                * Time the clock was most recently stopped relative to the
                * master clock.
                * @property _timeLastStopped
                * @type Number
                * @default null
                * @private
                */
                this._timeLastStopped = null;
                /**
                * Time the clock was most receently paused relative to the
                * master clock.
                * @property _timeLastPaused
                * @private
                * @type Number
                * @default null
                * @private
                */
                this._timeLastPaused = null;
                /**
                * Time the clock was most recently unpaused relative to the
                * master clock.
                * @property _timeLastUnpaused
                * @private
                * @type Number
                * @default null
                * @private
                */
                this._timeLastUnpaused = null;
                /**
                * Total number of milliseconds the clock has been paused
                * since it was last started
                * @property _totalPaused
                * @private
                * @type Number
                * @default 0
                * @private
                */
                this._totalPaused = 0;
                /**
                * Whether the clock is in a running state
                * @property _isRunning
                * @type boolean
                * @default false
                * @private
                */
                this._isRunning = false;
                /**
                * Whether the clock is in a stopped state
                * @property _isStopped
                * @type boolean
                * @default true
                * @private
                */
                this._isStopped = true;
                /**
                * Whether the clock is in a paused state
                * @property _isPaused
                * @type boolean
                * @default false
                * @private
                */
                this._isPaused = false;
                /**
                * Internal reference to the state of the elapsed timer
                * @property _elapsedState
                * @type Number
                * @private
                */
                this._elapsedState = Kiwi.Time.Clock._RUNNING;
                /**
                * Time manager that this clock belongs to
                * @property manager
                * @type ClockManager
                * @public
                */
                this.manager = null;
                /**
                * Master clock from which time is derived
                * @property master
                * @type Kiwi.Time.MasterClock
                * @public
                */
                this.master = null;
                /**
                * The time it takes for the time to update. Using this you can calculate the fps.
                * @property delta
                * @type number
                * @since 1.3.0
                * @readOnly
                * @public
                */
                this.delta = 0;
                /**
                * Name of the clock
                * @property name
                * @type string
                * @public
                */
                this.name = null;
                /**
                * Number of milliseconds counted as one unit of time by the clock
                * @property units
                * @type Number
                * @default 0
                * @public
                */
                this.units = 0;
                this.manager = manager;
                this.master = master;
                this.name = name;
                this.units = units;
                this.timers = [];
                if (this.units < 1) {
                    this.units = 1;
                }
                this._lastMasterElapsed = this.master.elapsed();
                this._currentMasterElapsed = this.master.elapsed();
            }
            /**
            * The type of object that this is
            * @method objType
            * @return {String} "Clock"
            * @public
            */
            Clock.prototype.objType = function () {
                return "Clock";
            };
            /**
            * Number of clock units elapsed since the clock was first started
            * @method elapsedSinceFirstStarted
            * @return {Number} Number of clock units elapsed
            * @public
            */
            Clock.prototype.elapsedSinceFirstStarted = function () {
                return (this._timeLastStarted) ? (this.master.elapsed() - this._timeFirstStarted) / this.units : null;
            };
            /**
            * Most recent time the clock was started relative to the master clock
            * @method started
            * @return {Number} Milliseconds
            * @public
            */
            Clock.prototype.started = function () {
                return this._timeLastStarted;
            };
            Object.defineProperty(Clock.prototype, "maxFrameDuration", {
                /**
                * Maximum frame duration. If a frame takes longer than this to render,
                * the clock will only advance this far, in effect slowing down time.
                * If this value is 0 or less, it will not be checked and frames can
                * take any amount of time to render.
                * @property maxFrameDuration
                * @type number
                * @default -1
                * @public
                */
                get: function () {
                    return this._maxFrameDuration;
                },
                set: function (value) {
                    this._maxFrameDuration = value;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Number of clock units elapsed since the clock was most recently
            * started (not including time spent paused)
            * @method elapsed
            * @return {Number} Number of clock units
            * @public
            */
            Clock.prototype.elapsed = function () {
                return this._elapsed;
            };
            /**
            * Number of clock units elapsed since the clock was most recently
            * stopped.
            * @method elapsedSinceLastStopped
            * @return {Number} Number of clock units
            * @public
            */
            Clock.prototype.elapsedSinceLastStopped = function () {
                return (this._timeLastStarted) ? (this.master.elapsed() - this._timeLastStopped) / this.units : null;
            };
            /**
            * Number of clock units elapsed since the clock was most recently paused.
            * @method elapsedSinceLastPaused
            * @return {Number} Number of clock units
            * @public
            */
            Clock.prototype.elapsedSinceLastPaused = function () {
                return (this._timeLastStarted) ? (this.master.elapsed() - this._timeLastPaused) / this.units : null;
            };
            /**
            * Number of clock units elapsed since the clock was most recently
            * unpaused.
            * @method elapsedSinceLastUnpaused
            * @return {Number} Number of clock units
            * @public
            */
            Clock.prototype.elapsedSinceLastUnpaused = function () {
                return (this._timeLastStarted) ? (this.master.elapsed() - this._timeLastUnpaused) / this.units : null;
            };
            /**
            * Check if the clock is currently running
            * @method isRunning
            * @return {boolean} `true` if running
            * @public
            */
            Clock.prototype.isRunning = function () {
                return this._isRunning;
            };
            /**
            * Check if the clock is in the stopped state
            * @method isStopped
            * @return {boolean} `true` if stopped
            * @public
            */
            Clock.prototype.isStopped = function () {
                return this._isStopped;
            };
            /**
            * Check if the clock is in the paused state
            * @method isPaused
            * @return {boolean} `true` if paused
            * @public
            */
            Clock.prototype.isPaused = function () {
                return this._isPaused;
            };
            /**
            * Add an existing Timer to the Clock.
            * @method addTimer
            * @param timer {Timer} Timer object instance to be added to this Clock
            * @return {Kiwi.Time.Clock} This Clock object
            * @public
            */
            Clock.prototype.addTimer = function (timer) {
                this.timers.push(timer);
                return this;
            };
            /**
            * Create a new Timer and add it to this Clock.
            * @method createTimer
            * @param name {string} Name of the Timer (must be unique on this Clock)
            * @param [delay=1] {Number} Number of clock units to wait between
            *	firing events
            * @param [repeatCount=0] {Number} Number of times to repeat the Timer
            *	(default 0)
            * @param [start=true] {Boolean} If the timer should start
            * @return {Kiwi.Time.Timer} The newly created Timer
            * @public
            */
            Clock.prototype.createTimer = function (name, delay, repeatCount, start) {
                if (delay === void 0) { delay = 1; }
                if (repeatCount === void 0) { repeatCount = 0; }
                if (start === void 0) { start = true; }
                this.timers.push(new Time.Timer(name, this, delay, repeatCount));
                if (start === true) {
                    this.timers[this.timers.length - 1].start();
                }
                return this.timers[this.timers.length - 1];
            };
            /**
            * Remove a Timer from this Clock based on either the Timer object
            * or its name.
            * @method removeTimer
            * @param [timer=null] {Timer} Timer object you wish to remove.
            *	If you wish to delete by Timer Name set this to null.
            * @param [timerName=''] {string} Name of the Timer object to remove
            * @return {boolean} `true` if the Timer was successfully removed
            * @public
            */
            Clock.prototype.removeTimer = function (timer, timerName) {
                if (timer === void 0) { timer = null; }
                if (timerName === void 0) { timerName = ""; }
                var index;
                //  Timer object given?
                if (timer !== null) {
                    index = this.timers.indexOf(timer);
                    if (index !== -1) {
                        this.timers.splice(index, 1);
                        return true;
                    }
                }
                else if (timerName !== "") {
                    for (index = 0; index < this.timers.length; index++) {
                        if (this.timers[index].name === timerName) {
                            this.timers.splice(index, 1);
                            return true;
                        }
                    }
                }
                return false;
            };
            /**
            * Check if the Timer already exists on this Clock.
            * @method checkExists
            * @param name {string} Name of the Timer
            * @return {boolean} `true` if the Timer exists
            * @public
            */
            Clock.prototype.checkExists = function (name) {
                if (this.timers[name]) {
                    return true;
                }
                else {
                    return false;
                }
            };
            /**
            * Stop all timers attached to the clock.
            * @method stopAllTimers
            * @return {Clock} This Clock object
            * @public
            */
            Clock.prototype.stopAllTimers = function () {
                for (var i = 0; i < this.timers.length; i++) {
                    this.timers[i].stop();
                }
                return this;
            };
            /**
            * Convert a number to milliseconds based on clock units.
            * @method toMilliseconds
            * @param time {number} Seconds
            * @return {Number} Milliseconds
            * @public
            */
            Clock.prototype.convertToMilliseconds = function (time) {
                return time * this.units;
            };
            /**
            * Update all Timers linked to this Clock.
            * @method update
            * @public
            */
            Clock.prototype.update = function () {
                var frameLength = this._currentMasterElapsed - this._lastMasterElapsed;
                if (this._maxFrameDuration > 0) {
                    frameLength = Math.min(frameLength, this._maxFrameDuration);
                }
                for (var i = 0; i < this.timers.length; i++) {
                    this.timers[i].update();
                }
                // Compute difference between last master value and this
                // If clock is running, add that value to the current time
                this._lastMasterElapsed = this._currentMasterElapsed;
                this._currentMasterElapsed = this.master.elapsed();
                this.delta = 0;
                if (this._elapsedState === Kiwi.Time.Clock._RUNNING || this._elapsedState === Kiwi.Time.Clock._RESUMED) {
                    // Scale that difference by timeScale. Set "rate" as per running type
                    this.delta = this.timeScale * frameLength / this.units;
                    this._elapsed += this.delta;
                    this.rate = this.timeScale * frameLength / this.master.idealDelta;
                }
                else if (this._elapsedState === Kiwi.Time.Clock._PAUSED) {
                    this._totalPaused += frameLength;
                    this.rate = 0;
                }
                else if (this._elapsedState === Kiwi.Time.Clock._STOPPED) {
                    this.rate = 0;
                }
            };
            /**
            * Start the clock. This resets the clock and starts it running.
            * @method start
            * @return {Clock} This Clock object
            * @public
            */
            Clock.prototype.start = function () {
                this._timeLastStarted = this.master.elapsed();
                this._totalPaused = 0;
                if (!this._timeFirstStarted) {
                    this._timeFirstStarted = this._timeLastStarted;
                }
                this._isRunning = true;
                this._isPaused = false;
                this._isStopped = false;
                this._elapsedState = Kiwi.Time.Clock._RUNNING;
                this._elapsed = 0;
                this._lastMasterElapsed = this.master.elapsed();
                this._currentMasterElapsed = this.master.elapsed();
                return this;
            };
            /**
            * Pause the clock. This can only be paused if it is already running.
            * @method pause
            * @return {Kiwi.Time.Clock} This Clock object
            * @public
            */
            Clock.prototype.pause = function () {
                if (this._isRunning === true) {
                    this._timeLastPaused = this.master.elapsed();
                    this._isRunning = false;
                    this._isPaused = true;
                    this._isStopped = false;
                    this._elapsedState = Kiwi.Time.Clock._PAUSED;
                }
                return this;
            };
            /**
            * Resume the clock. This can only be resumed if it is already paused.
            * @method resume
            * @return {Kiwi.Time.Clock} This Clock object
            * @public
            */
            Clock.prototype.resume = function () {
                if (this._isPaused === true) {
                    this._timeLastUnpaused = this.master.elapsed();
                    this._totalPaused += this._timeLastUnpaused - this._timeLastPaused;
                    this._isRunning = true;
                    this._isPaused = false;
                    this._isStopped = false;
                    this._elapsedState = Kiwi.Time.Clock._RESUMED;
                }
                return this;
            };
            /**
            * Stop the clock. This can only be stopped if it is already running
            *	or is paused.
            * @method stop
            * @return {Kiwi.Time.Clock} This Clock object
            * @public
            */
            Clock.prototype.stop = function () {
                if (this._isStopped === false) {
                    this._timeLastStopped = this.master.elapsed();
                    if (this._isPaused === true) {
                        this._totalPaused += this._timeLastStopped - this._timeLastPaused;
                    }
                    this._isRunning = false;
                    this._isPaused = false;
                    this._isStopped = true;
                    this._elapsedState = Kiwi.Time.Clock._STOPPED;
                }
                return this;
            };
            /**
            * Return a string representation of this object.
            * @method toString
            * @return {string} String representation of the instance
            * @public
            */
            Clock.prototype.toString = function () {
                return "[{Clock (name=" + this.name + " units=" + this.units + " running=" + this._isRunning + ")}]";
            };
            /**
            * Set a function to execute after a certain time interval.
            * Emulates `window.setTimeout`, except attached to a `Kiwi.Time.Clock`.
            * This allows you to pause and manipulate time, and the timeout will
            * respect the clock on which it is created.
            *
            * No `clearTimeout` is provided; you should use `Kiwi.Time.Timer`
            * functions to achieve further control.
            *
            * Any parameters after `context` will be passed as parameters to the
            * callback function. Note that you must specify `context` in order for
            * this to work. You may specify `null`, in which case it will default
            * to the global scope `window`.
            *
            * @method setTimeout
            * @param callback {function} Function to execute
            * @param timeout {number} Milliseconds before execution
            * @param [context] {object} Object to be `this` for the callback
            * @return {Kiwi.Time.Timer} Kiwi.Time.Timer object which can be used
            *	to further manipulate the timer
            * @public
            */
            Clock.prototype.setTimeout = function (callback, timeout, context) {
                var args = [];
                for (var _i = 3; _i < arguments.length; _i++) {
                    args[_i - 3] = arguments[_i];
                }
                var clock = this, timer = this.createTimer("timeoutTimer", timeout / this.units);
                if (!context) {
                    context = this;
                }
                timer.createTimerEvent(Time.TimerEvent.TIMER_STOP, function () {
                    callback.apply(context, args);
                    clock.removeTimer(timer);
                }, context);
                timer.start();
                return timer;
            };
            /**
            * Set a function to repeatedly execute at fixed time intervals.
            * Emulates `window.setInterval`, except attached to a `Kiwi.Time.Clock`.
            * This allows you to pause and manipulate time, and the timeout will
            * respect the clock on which it is created.
            *
            * No `clearInterval` is provided; you should use `Kiwi.Time.Timer`
            * functions to achieve further control.
            *
            * Any parameters after `context` will be passed as parameters to the
            * callback function. Note that you must specify `context` in order for
            * this to work. You may specify `null`, in which case it will default
            * to the global scope `window`.
            *
            * @method setInterval
            * @param callback {function} Function to execute
            * @param timeout {number} Milliseconds between executions
            * @param [context=window] {object} Object to be `this` for the callback
            * @return {Kiwi.Time.Timer} Kiwi.Time.Timer object
            *   which can be used to further manipulate the timer
            * @public
            */
            Clock.prototype.setInterval = function (callback, timeout, context) {
                var args = [];
                for (var _i = 3; _i < arguments.length; _i++) {
                    args[_i - 3] = arguments[_i];
                }
                var timer = this.createTimer("intervalTimer", timeout / this.units, -1);
                if (!context) {
                    context = this;
                }
                timer.createTimerEvent(Time.TimerEvent.TIMER_COUNT, function () {
                    callback.apply(context, args);
                }, context);
                timer.start();
                return timer;
            };
            /**
            * Constant indicating that the Clock is running
            * (and has not yet been paused and resumed)
            * @property _RUNNING
            * @static
            * @type number
            * @default 0
            * @private
            */
            Clock._RUNNING = 0;
            /**
            * Constant indicating that the Clock is paused
            * @property _PAUSED
            * @static
            * @type number
            * @default 1
            * @private
            */
            Clock._PAUSED = 1;
            /**
            * Constant indicating that the Clock is running
            * (and has been paused then resumed)
            * @property _RESUMED
            * @static
            * @type number
            * @default 2
            * @private
            */
            Clock._RESUMED = 2;
            /**
            * Constant indicating that the Clock is stopped
            * @property _STOPPED
            * @static
            * @type number
            * @default 3
            * @private
            */
            Clock._STOPPED = 3;
            return Clock;
        })();
        Time.Clock = Clock;
    })(Time = Kiwi.Time || (Kiwi.Time = {}));
})(Kiwi || (Kiwi = {}));
/**
* Contains ways of tracking time within a game or application. Each game will have a ClockManager, MasterClock and a single Clock automatically generated for them upon game creation.
*
* @module Kiwi
* @submodule Time
* @main Time
*/
var Kiwi;
(function (Kiwi) {
    var Time;
    (function (Time) {
        /**
        * Handles the generation and tracking of `Clock` and time related
        * applications for a single game.
        *
        * An instance of `ClockManager` is automatically created as part of
        * `Kiwi.Game`. This is accessible as the `time` property of any `Game`
        * object. You should not need to create additional `ClockManager` objects.
        *
        * If you do want to create additional `ClockManager` objects, be sure to
        * call `boot()` after creation to set up properties like the master clock.
        * You will also need to update this manager every frame.
        *
        * @class ClockManager
        * @namespace Kiwi.Time
        * @constructor
        * @param {Kiwi.Game} game.
        * @return {Kiwi.Time.ClockManager} This Object.
        *
        */
        var ClockManager = (function () {
            function ClockManager(game) {
                /**
                * An array containing all of the clocks that exist on this manager.
                * @property _clocks
                * @type Array
                * @private
                */
                this._clocks = [];
                /**
                * Frame rate factor, derived from master clock
                * @property rate
                * @type Number
                * @public
                * @since 1.1.10
                */
                this.rate = 1;
                this._game = game;
            }
            /**
            * The type of object this is.
            * @method objType
            * @return {String} "ClockManager"
            * @public
            */
            ClockManager.prototype.objType = function () {
                return "ClockManager";
            };
            /**
            * When all of the DOM elements that the game requires have loaded successfully then this object will 'boot'.
            * @method boot
            * @public
            */
            ClockManager.prototype.boot = function () {
                this.master = new Kiwi.Time.MasterClock();
                this.clock = new Time.Clock(this, this.master, 'default', 1000);
                this.clock.start();
            };
            /**
            * Creates a Clock class for keeping time relative to the MasterClock.
            * @method addClock
            * @param name {string} The name of the Clock.
            * @param [units=1000] {Number} The number of milliseconds that make up one unit of time on this clock. Default 1000.
            * @return {Kiwi.Time.Clock} A reference to the newly created Clock object.
            * @public
            */
            ClockManager.prototype.addClock = function (name, units) {
                if (units === void 0) { units = 1000; }
                this._clocks.push(new Time.Clock(this, this.master, name, units));
                return this._clocks[this._clocks.length - 1];
            };
            /**
            * Returns the Clock with the matching name.
            * Throws an error if no Clock with that name exists
            * @method getClock
            * @param name {string} The name of the Clock to be returned.
            * @return {Kiwi.Time.Clock} The clock which matches the name given.
            * @public
            */
            ClockManager.prototype.getClock = function (name) {
                for (var i = 0; i < this._clocks.length; i++) {
                    if (this._clocks[i].name === name) {
                        return this._clocks[i];
                    }
                }
            };
            /**
            * Is executed every frame and updates all of the clocks that exist on this manager.
            * @method update
            * @public
            */
            ClockManager.prototype.update = function () {
                this.master.update();
                this.clock.update();
                for (var i = 0; i < this._clocks.length; i++) {
                    this._clocks[i].update();
                }
                this.rate = this.master.rate;
            };
            /**
            * Returns the current time. Based on the master clock.
            * @method now
            * @return {Number}
            * @public
            */
            ClockManager.prototype.now = function () {
                return this.master.now;
            };
            /**
            * Returns the elapsed time. Based on the master clock.
            * @method elapsed
            * @return {Number}
            * @public
            * @since 1.1.0
            */
            ClockManager.prototype.elapsed = function () {
                return this.master.elapsed();
            };
            /**
            * Returns the delta of the master clock.
            * @method delta
            * @return {Number}
            * @public
            */
            ClockManager.prototype.delta = function () {
                return this.master.delta;
            };
            /**
            * Sets the interval on the master clock.
            * @method setMasterInterval
            * @param interval {Number} The ideal frame interval in milliseconds.
            * @public
            * @since 1.1.0
            */
            ClockManager.prototype.setMasterInterval = function (interval) {
                this.master.idealDelta = interval;
            };
            return ClockManager;
        })();
        Time.ClockManager = ClockManager;
    })(Time = Kiwi.Time || (Kiwi.Time = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Time
*
*/
var Kiwi;
(function (Kiwi) {
    var Time;
    (function (Time) {
        /**
        * The MasterClock tracks time elapsed since the application started.
        * Each ClockManager has only one MasterClock which is automatically generated when the game initially booted.
        * You should not access it directly, use the Clock and Timer classes instead.
        *
        * @class MasterClock
        * @namespace Kiwi.Time
        * @constructor
        * @return {Kiwi.Time.MasterClock} This Object.
        *
        */
        var MasterClock = (function () {
            function MasterClock() {
                /**
                * The current time. This is updated every frame but AFTER the delta is calculated.
                * @property time
                * @type Number
                * @public
                */
                this.time = 0;
                /**
                * The current time, this is straight from the Date.now() method and is updated every frame BEFORE the delta.
                * @property now
                * @type Number
                * @public
                */
                this.now = 0;
                /**
                * The time it takes for the time to update. Using this you can calculate the fps.
                * @property delta
                * @type Number
                * @public
                */
                this.delta = 0;
                /**
                * The rate at which ideal frames are passing. Multiply per-frame iterations by this factor to create smooth movement. For example, if the ideal fps is 60, but you're only getting 45, rate will equal 1.333.
                * @property rate
                * @type Number
                * @public
                * @since 1.1.0
                */
                this.rate = 1;
                /**
                * The ideal frame delta in milliseconds. This is automatically adjusted when the game sets a new frameRate.
                * @property idealDelta
                * @type Number
                * @public
                * @since 1.1.0
                */
                this.idealDelta = 1000 / 60.0;
                this._started = Date.now();
                this.now = Date.now();
                this.time = this._started;
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String} "MasterClock"
            * @public
            */
            MasterClock.prototype.objType = function () {
                return "MasterClock";
            };
            /**
            * The time that has elapsed since the game started. In milliseconds.
            * @method elapsed
            * @return {Number}
            * @public
            */
            MasterClock.prototype.elapsed = function () {
                return this.now - this._started;
            };
            /**
            * The time that has elapsed since the game started but in seconds.
            * @method totalElapsedSeconds
            * @return {Number}
            * @public
            */
            MasterClock.prototype.totalElapsedSeconds = function () {
                return (this.now - this._started) * 0.001;
            };
            /**
            * The update loop that should be executed every frame. Used to update the time.
            * @method update
            * @public
            */
            MasterClock.prototype.update = function () {
                //  Not in < IE8 (fixed via polyfill)
                this.now = Date.now();
                this.delta = this.now - this.time;
                this.time = this.now;
                this.rate = this.delta / this.idealDelta;
                //  Apply time scaling
            };
            /**
            * Used to calculate the elapsed time from a point that is specified. This is returned in Milliseconds.
            * @method elapsedSince
            * @param since {Number} The point in time in which you would like to see how many milliseconds have passed. In milliseconds.
            * @return {Number}
            * @public
            */
            MasterClock.prototype.elapsedSince = function (since) {
                return this.now - since;
            };
            /**
            * Used to calculate the elapsed time from a point that is specified BUT this is in seconds.
            * @method elapsedSecondsSince
            * @param since {Number} The point in time in which you would like to see how many seconds have passed. In milliseconds.
            * @return {Number }
            * @public
            */
            MasterClock.prototype.elapsedSecondsSince = function (since) {
                return (this.now - since) * 0.001;
            };
            /**
            * Resets the MasterClocks time.
            * @method reset
            * @public
            */
            MasterClock.prototype.reset = function () {
                this._started = this.now;
            };
            return MasterClock;
        })();
        Time.MasterClock = MasterClock;
    })(Time = Kiwi.Time || (Kiwi.Time = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Time
*
*/
var Kiwi;
(function (Kiwi) {
    var Time;
    (function (Time) {
        /**
        * The Timer class hooks into a game Clock and allows you run code at a specified point in game time.
        * Use the start() method to start a timer. Add TimerEvents to set-up code to be run on the timer interval.
        * Timer objects can run once or repeat at specified intervals to execute code on a schedule.
        *
        * @class Timer
        * @namespace Kiwi.Time
        * @constructor
        * @param name {string} The name of the timer.
        * @param clock {Kiwi.Time.Clock} The game clock instance this Timer is based on.
        * @param delay {Number} The number of clock units to wait between firing events.
        * @param [repeatCount=0] {Number} The number of times to repeat the timer before it is expired. If you don't want it to ever expire, set a value of -1.
        * @return {Kiwi.Time.Timer} This object.
        *
        */
        var Timer = (function () {
            function Timer(name, clock, delay, repeatCount) {
                if (repeatCount === void 0) { repeatCount = 0; }
                /**
                * The number of times the timer has repeated so far.
                * @property _currentCount
                * @type Number
                * @default 0
                * @private
                */
                this._currentCount = 0;
                /**
                * A collection of the TimerEvents associated with TimerEvent.TIMER_START
                * @property _startEvents
                * @type Array
                * @private
                */
                this._startEvents = null;
                /**
                * A collection of the TimerEvents associated with TimerEvent.TIMER_COUNT
                * @property _countEvents
                * @private
                * @type Array
                */
                this._countEvents = null;
                /**
                * A collection of the TimerEvents associated with TimerEvent.TIMER_STOP
                * @property _stopEvents
                * @private
                * @type Array
                */
                this._stopEvents = null;
                /**
                * The clock which this timer bases its timing on.
                * @property _clock
                * @type Kiwi.Time.Clock
                * @private
                */
                this._clock = null;
                /**
                * The time the last repeat occurred in clock units.
                * @property _timeLastCount
                * @type Number
                * @private
                * @deprecated Better time handling in 1.2.0 deprecates this data.
                */
                this._timeLastCount = null;
                /**
                * Whether the timer is in a running state.
                * @property _isRunning
                * @type boolean
                * @default false
                * @private
                */
                this._isRunning = false;
                /**
                * Whether the timer is in a stopped state.
                * @property _isStopped
                * @type boolean
                * @default true
                * @private
                */
                this._isStopped = true;
                /**
                * Whether the timer is in a paused state.
                * @property _isPaused
                * @type boolean
                * @default false
                * @private
                */
                this._isPaused = false;
                /**
                * The name of the timer.
                * @property name
                * @type String
                * @default null
                * @public
                */
                this.name = null;
                /**
                * The delay, in game clock units, that the timer will wait before firing the event
                * @property _delay
                * @type Number
                * @default 0.016
                * @private
                */
                this._delay = 0.016;
                /**
                * The number of times the timer will repeat before stopping.
                * @property repeatCount
                * @type Number
                * @default 0
                * @public
                */
                this.repeatCount = 0;
                /**
                * Time elapsed on the current repetition
                * @property _elapsed
                * @type number
                * @private
                * @since 1.2.0
                */
                this._elapsed = 0;
                this._clock = clock;
                this._startEvents = [];
                this._countEvents = [];
                this._stopEvents = [];
                this.name = name;
                this.delay = delay;
                this.repeatCount = repeatCount;
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String} "Timer"
            * @public
            */
            Timer.prototype.objType = function () {
                return "Timer";
            };
            /**
            * Get the number of times the timer has repeated.
            * @method getCurrentCount
            * @return {Number}
            * @public
            */
            Timer.prototype.currentCount = function () {
                return this._currentCount;
            };
            /**
            * The Timers current state. True if the Timer is running, otherwise false.
            * @method running
            * @return {boolean}
            * @public
            */
            Timer.prototype.isRunning = function () {
                return this._isRunning;
            };
            /**
            * Whether the timer is in a stopped state.
            * @method stopped
            * @return {boolean}
            * @public
            */
            Timer.prototype.isStopped = function () {
                return this._isStopped;
            };
            /**
            * Whether the timer is in a paused state.
            * @method paused
            * @return {boolean}
            * @public
            */
            Timer.prototype.isPaused = function () {
                return this._isPaused;
            };
            Object.defineProperty(Timer.prototype, "delay", {
                /**
                * The delay, in game clock units, that the timer will wait before firing the event
                *
                * This property must be greater than 0.
                * @property delay
                * @type Number
                * @default 0.016
                * @public
                */
                get: function () {
                    return this._delay;
                },
                set: function (value) {
                    if (value > 0) {
                        this._delay = value;
                    }
                    else {
                        Kiwi.Log.error("Attempted to set timer delay", value, "but value must be greater than 0", "#timer");
                    }
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Checks the list of TimerEvents added and processes them based on their type.
            * @method processEvents
            * @param type {Number} The type of events to dispatch
            * @private
            */
            Timer.prototype.processEvents = function (type) {
                if (type === Time.TimerEvent.TIMER_START) {
                    for (var i = 0; i < this._startEvents.length; i++) {
                        this._startEvents[i].run();
                    }
                }
                else if (type === Time.TimerEvent.TIMER_COUNT) {
                    for (var i = 0; i < this._countEvents.length; i++) {
                        this._countEvents[i].run();
                    }
                }
                else if (type === Time.TimerEvent.TIMER_STOP) {
                    for (var i = 0; i < this._stopEvents.length; i++) {
                        this._stopEvents[i].run();
                    }
                }
            };
            /**
            * Internal update loop called by the Clock that this Timer belongs to.
            * @method update
            * @public
            */
            Timer.prototype.update = function () {
                var frameLength = this._clock.elapsed() - this._lastElapsed;
                this._lastElapsed = this._clock.elapsed();
                if (this._isRunning) {
                    this._elapsed += frameLength;
                }
                while (this._elapsed >= this.delay) {
                    this._currentCount++;
                    this.processEvents(Time.TimerEvent.TIMER_COUNT);
                    this._elapsed -= this.delay;
                    if (this.repeatCount !== -1 && this._currentCount >= this.repeatCount) {
                        this.stop();
                    }
                }
                while (this._elapsed < 0) {
                    this._currentCount--;
                    this._elapsed += this.delay;
                    // Do not process events; they can happen when time flows forwards
                    if (this._currentCount < 0) {
                        // Timer has regressed before its creation.
                        // When time flows forward again, the Timer will probably
                        // be restarted and repopulated.
                        // There is a potential memory leak: if a Timer is created
                        // for a single task, and has a TimerEvent that will
                        // remove it upon completion, but the Timer is rewound to
                        // before its creation, that removal will never fire.
                        this.clear();
                        this.stop();
                    }
                }
            };
            /**
            * Start the Timer. This will reset the timer and start it. The timer can only be started if it is in a stopped state.
            * @method start
            * @return {Kiwi.Time.Timer} this object.
            * @public
            */
            Timer.prototype.start = function () {
                if (this._isStopped === true) {
                    this._isRunning = true;
                    this._isPaused = false;
                    this._isStopped = false;
                    this._currentCount = 0;
                    this._elapsed = 0;
                    this._lastElapsed = this._clock.elapsed() || 0;
                    this.processEvents(Time.TimerEvent.TIMER_START);
                }
                return this;
            };
            /**
            * Stop the Timer. Only possible when the timer is running or paused.
            * @method stop
            * @return {Kiwi.Time.Timer} this object.
            * @public
            */
            Timer.prototype.stop = function () {
                if (this._isRunning === true || this._isPaused === true) {
                    this._isRunning = false;
                    this._isPaused = false;
                    this._isStopped = true;
                    this.processEvents(Time.TimerEvent.TIMER_STOP);
                }
                return this;
            };
            /**
            * Pause the Timer. Only possible when the timer is running.
            * @method pause
            * @return {Kiwi.Time.Timer} this object.
            * @public
            */
            Timer.prototype.pause = function () {
                if (this._isRunning === true) {
                    this._isRunning = false;
                    this._isPaused = true;
                }
                return this;
            };
            /**
            * Resume the Timer. Only possible if the timer has been paused.
            * @method resume
            * @return {Kiwi.Time.Timer} this object.
            * @public
            */
            Timer.prototype.resume = function () {
                if (this._isPaused === true) {
                    this._isRunning = true;
                    this._isPaused = false;
                }
                return this;
            };
            /**
            * Adds an existing TimerEvent object to this Timer.
            * @method addTimerEvent
            * @param {Kiwi.Time.TimerEvent} A TimerEvent object
            * @return {Kiwi.Time.TimerEvent} The TimerEvent object
            * @public
            */
            Timer.prototype.addTimerEvent = function (event) {
                if (event.type === Time.TimerEvent.TIMER_START) {
                    this._startEvents.push(event);
                }
                else if (event.type === Time.TimerEvent.TIMER_COUNT) {
                    this._countEvents.push(event);
                }
                else if (event.type === Time.TimerEvent.TIMER_STOP) {
                    this._stopEvents.push(event);
                }
                return event;
            };
            /**
            * Creates a new TimerEvent and adds it to this Timer
            * @method createTimerEvent
            * @param type {Number} The type of TimerEvent to create (TIMER_START, TIMER_COUNT or TIMER_STOP).
            * @param callback {Function} The function to call when the TimerEvent fires.
            * @param context {Function} The context in which the given function will run (usually 'this')
            * @return {Kiwi.Time.TimerEvent} The newly created TimerEvent.
            * @public
            */
            Timer.prototype.createTimerEvent = function (type, callback, context) {
                if (type === Time.TimerEvent.TIMER_START) {
                    this._startEvents.push(new Time.TimerEvent(type, callback, context));
                    return this._startEvents[this._startEvents.length - 1];
                }
                else if (type === Time.TimerEvent.TIMER_COUNT) {
                    this._countEvents.push(new Time.TimerEvent(type, callback, context));
                    return this._countEvents[this._countEvents.length - 1];
                }
                else if (type === Time.TimerEvent.TIMER_STOP) {
                    this._stopEvents.push(new Time.TimerEvent(type, callback, context));
                    return this._stopEvents[this._stopEvents.length - 1];
                }
                return null;
            };
            /**
            * Removes a TimerEvent object from this Timer
            * @method removeTimerEvent
            * @param {Kiwi.Time.TimerEvent} The TimerEvent to remove
            * @return {boolean} True if the event was removed, otherwise false.
            * @public
            */
            Timer.prototype.removeTimerEvent = function (event) {
                var removed = [];
                if (event.type === Time.TimerEvent.TIMER_START) {
                    removed = this._startEvents.splice(this._startEvents.indexOf(event), 1);
                }
                else if (event.type === Time.TimerEvent.TIMER_COUNT) {
                    removed = this._countEvents.splice(this._countEvents.indexOf(event), 1);
                }
                else if (event.type === Time.TimerEvent.TIMER_STOP) {
                    removed = this._stopEvents.splice(this._stopEvents.indexOf(event), 1);
                }
                if (removed.length === 1) {
                    return true;
                }
                else {
                    return false;
                }
            };
            /**
            * Removes all TimerEvent objects from this Timer
            * @method clear
            * @param type {Number} The type of TimerEvents to remove. Set to zero to remove them all.
            * @return {boolean} True if the event was removed, otherwise false.
            * @public
            */
            Timer.prototype.clear = function (type) {
                if (type === void 0) { type = 0; }
                if (type === 0) {
                    this._startEvents.length = 0;
                    this._countEvents.length = 0;
                    this._stopEvents.length = 0;
                }
                else if (type === Time.TimerEvent.TIMER_START) {
                    this._startEvents.length = 0;
                }
                else if (type === Time.TimerEvent.TIMER_COUNT) {
                    this._countEvents.length = 0;
                }
                else if (type === Time.TimerEvent.TIMER_STOP) {
                    this._stopEvents.length = 0;
                }
            };
            /**
            * Returns a string representation of this object.
            * @method toString
            * @return {string} a string representation of the instance.
            * @public
            */
            Timer.prototype.toString = function () {
                return "[{Timer (name=" + this.name + " delay=" + this.delay + " repeatCount=" + this.repeatCount + " running=" + this._isRunning + ")}]";
            };
            return Timer;
        })();
        Time.Timer = Timer;
    })(Time = Kiwi.Time || (Kiwi.Time = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Time
*
*/
var Kiwi;
(function (Kiwi) {
    var Time;
    (function (Time) {
        /**
        * A TimerEvent hooks into a Timer and is an object that is generated when you are wanting to executed a callback at a specific point in time.
        *
        * @class TimerEvent
        * @namespace Kiwi.Time
        * @constructor
        * @param type {Number} The type of TimerEvent that this is.
        * @param callback {Any} The method that is to be executed when the event occurs.
        * @param context {Any} The context that the callback is to be called in.
        * @return {Kiwi.Time.TimerEvent} This Object.
        */
        var TimerEvent = (function () {
            function TimerEvent(type, callback, context) {
                /**
                * The callback to be called when this TimerEvent triggers
                * @property _callback
                * @type Function
                * @private
                */
                this._callback = null;
                /**
                * The type of TimerEvent
                * @property type
                * @type Function
                * @public
                */
                this.type = 0;
                this.type = type;
                this._callback = callback;
                this._callbackContext = context;
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String} "TimerEvent"
            * @public
            */
            TimerEvent.prototype.objType = function () {
                return "TimerEvent";
            };
            /**
            * Fires the callback associated with this TimerEvent
            * @method run
            * @public
            */
            TimerEvent.prototype.run = function () {
                if (this._callback) {
                    this._callback.apply(this._callbackContext);
                }
            };
            /**
            * Name for the event fired when a timer starts.
            * @property TIMER_START
            * @type number
            * @final
            * @static
            * @public
            * @default 1
            */
            TimerEvent.TIMER_START = 1;
            /**
            * Name for the event fired when a timer repeats.
            * @property TIMER_COUNT
            * @public
            * @type string
            * @final
            * @static
            * @default 2
            */
            TimerEvent.TIMER_COUNT = 2;
            /**
            * Name for the event fired when a timer stops.
            * @property TIMER_STOP
            * @type string
            * @final
            * @static
            * @public
            * @default 3
            */
            TimerEvent.TIMER_STOP = 3;
            return TimerEvent;
        })();
        Time.TimerEvent = TimerEvent;
    })(Time = Kiwi.Time || (Kiwi.Time = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Utils
*/
var Kiwi;
(function (Kiwi) {
    var Utils;
    (function (Utils) {
        /**
        * Creates and the manages a Canvas DOMElement.
        *
        * @class Canvas
        * @namespace Kiwi.Utils
        * @constructor
        * @param width {Number} The width of the canvas.
        * @param height {Number} The height of the canvas.
        * @param [visible=true] {boolean} If the canvas is visible or not.
        * @param [offScreen=false] {boolean} If the canvas is designed to be offscreen or not.
        * @return {Kiwi.Utils.Canvas}
        *
        */
        var Canvas = (function () {
            function Canvas(width, height, visible, offScreen) {
                if (visible === void 0) { visible = true; }
                if (offScreen === void 0) { offScreen = false; }
                /**
                * The canvas DOM element.
                * @property domElement
                * @type HTMLCanvasElement
                * @public
                */
                this.domElement = null;
                /**
                * The 2D rendering context that is used to render anything to this canvas.
                * @property _context
                * @type CanvasRenderingContext2D
                * @public
                */
                this.context = null;
                /**
                * If the canvas element is visible or not.
                * @property _visible
                * @type boolean
                * @private
                */
                this._visible = true;
                /**
                * If the canvas is offscreen or not.
                * @property _offScreen
                * @type boolean
                * @private
                */
                this._offScreen = false;
                /**
                * The method to use when clearing the canvas.
                * @property _clearMode
                * @type Number
                * @private
                */
                this._clearMode = 1;
                this.domElement = document.createElement("canvas");
                this.domElement.width = width;
                this.domElement.height = height;
                this._width = width;
                this._height = height;
                this.context = this.domElement.getContext("2d");
                this._offScreen = offScreen;
                this._visible = visible;
                if (visible === false) {
                    this.domElement.style.display = "none";
                }
                this._bgColor = new Kiwi.Utils.Color(0, 0, 0);
            }
            Object.defineProperty(Canvas.prototype, "width", {
                get: function () {
                    return this._width;
                },
                /**
                * The width of this canvas.
                * @property width
                * @type number
                * @public
                */
                set: function (value) {
                    this._width = value;
                    this._updatedSize();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Canvas.prototype, "height", {
                get: function () {
                    return this._height;
                },
                /**
                * The height of this canvas.
                * @property height
                * @type number
                * @private
                */
                set: function (value) {
                    this._height = value;
                    this._updatedSize();
                },
                enumerable: true,
                configurable: true
            });
            /**
            * The type of object that this is.
            * @method objType
            * @return {String} "Canvas"
            * @public
            */
            Canvas.prototype.objType = function () {
                return "Canvas";
            };
            Object.defineProperty(Canvas.prototype, "bgColor", {
                /**
                * The background color to use clearing the canvas using a filled rectangle approach.
                * You may set this with any valid Kiwi.Utils.Color parameter.
                * If you set with multiple parameters, place them inside an array.
                * @property bgColor
                * @type String
                * @default "#000000"
                * @public
                */
                get: function () {
                    return "#" + this._bgColor.getHex();
                },
                set: function (value) {
                    if (!Kiwi.Utils.Common.isArray(value)) {
                        value = [value];
                    }
                    this._bgColor.set.apply(this._bgColor, value);
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Updates the width/height on the canvas DOM element when either one of its sizes are updated.
            * @method _updatedSize
            * @private
            */
            Canvas.prototype._updatedSize = function () {
                this.domElement.width = this._width;
                this.domElement.height = this._height;
            };
            /**
            * Used to remove the canvas element completely along with this class. [NEEDS IMPLEMENTATION]
            * @method destroy
            * @public
            */
            Canvas.prototype.destroy = function () {
                if (this._offScreen === false) {
                    this.domElement.style.display = "none";
                }
            };
            Object.defineProperty(Canvas.prototype, "visible", {
                get: function () {
                    return this._visible;
                },
                /**
                * If the canvas element is visible or not.
                * @property visible
                * @type boolean
                * @default true
                * @public
                */
                set: function (value) {
                    if (value !== null && value !== this._visible) {
                        this._visible = value;
                        if (value === true) {
                            this.domElement.style.display = "block";
                        }
                        else {
                            this.domElement.style.display = "none";
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Canvas.prototype, "clearMode", {
                get: function () {
                    return this._clearMode;
                },
                /**
                * The clearmode the is to be used when clearing the canvas.
                * @property clearMode
                * @type Number
                * @default 1
                * @public
                */
                set: function (value) {
                    if (value !== null && value !== this._clearMode && value >= Kiwi.Utils.Canvas.CLEARMODE_NONE && value <= Kiwi.Utils.Canvas.CLEARMODE_FILLRECT_ALPHA) {
                        this._clearMode = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Clears the canvas using the method specified by the clearMode property.
            * @method clear
            * @public
            */
            Canvas.prototype.clear = function () {
                if (this._clearMode === Canvas.CLEARMODE_NONE) {
                }
                else if (this._clearMode === Canvas.CLEARMODE_CLEARRECT) {
                    //  Clear Rect
                    this.context.clearRect(0, 0, this.domElement.width, this.domElement.height);
                }
                else if (this._clearMode === Canvas.CLEARMODE_FILLRECT) {
                    //  Fill Rect Solid
                    this.context.fillStyle = this.bgColor;
                    this.context.fillRect(0, 0, this.domElement.width, this.domElement.height);
                }
                else if (this._clearMode === Canvas.CLEARMODE_FILLRECT_ALPHA) {
                    //  Clear Rect + Fill Rect (only use if bgColor contains alpha < 255)
                    this.context.clearRect(0, 0, this.domElement.width, this.domElement.height);
                    this.context.fillStyle = this.bgColor;
                    this.context.fillRect(0, 0, this.domElement.width, this.domElement.height);
                }
            };
            /**
            * Returns the canvas current image data as PNG.
            * @method saveAsPNG
            * @return String
            * @public
            */
            Canvas.prototype.saveAsPNG = function () {
                return this.domElement.toDataURL();
            };
            /**
            * Returns a string representation of this object.
            * @method toString
            * @return {string} a string representation of the instance.
            * @public
            */
            Canvas.prototype.toString = function () {
                return "[{Canvas (width=" + this.width + " height=" + this.height + " visible=" + this.visible + " offScreen=" + this._offScreen + " clearMode=" + this.clearMode + ")}]";
            };
            /**
            * A STATIC property that holds the number associated with no clear mode.
            * @property CLEARMODE_NONE
            * @type Number
            * @static
            * @final
            * @default 0
            * @public
            */
            Canvas.CLEARMODE_NONE = 0;
            /**
            * A STATIC property that holds the number associated with the clear mode that uses the clearRect method to clear the canvas.
            * @property CLEARMODE_CLEARRECT
            * @type Number
            * @static
            * @final
            * @public
            * @default 1
            */
            Canvas.CLEARMODE_CLEARRECT = 1;
            /**
            * A STATIC property that holds the number associated with the clear mode that uses a filled rectangle to clear the canvas.
            * @property CLEARMODE_FILLRECT
            * @type Number
            * @static
            * @final
            * @public
            * @default 2
            */
            Canvas.CLEARMODE_FILLRECT = 2;
            /**
            * A STATIC property that holds the number associated with the clear mode that uses the filled alpha rectangle method.
            * @property CLEARMODE_FILLRECT_ALPHA
            * @type Number
            * @static
            * @final
            * @public
            * @default 3
            */
            Canvas.CLEARMODE_FILLRECT_ALPHA = 3;
            return Canvas;
        })();
        Utils.Canvas = Canvas;
    })(Utils = Kiwi.Utils || (Kiwi.Utils = {}));
})(Kiwi || (Kiwi = {}));
/**
* @module Kiwi
* @submodule Utils
* @namespace Kiwi.Utils
*/
var Kiwi;
(function (Kiwi) {
    var Utils;
    (function (Utils) {
        /**
        * Utility class used to make color management more transparent.
        * Color objects hold color and alpha values, and can get or set them
        * in a variety of ways.
        *
        * Construct this object in one of the following ways.
        *
        * - Pass 3 or 4 numbers to determine RGB or RGBA. If the numbers are in
        * the range 0-1, they will be parsed as normalized numbers.
        * If they are in the range 1-255, they will be parsed as 8-bit channels.
        *
        * - Pass 3 or 4 numbers followed by the string "hsv" or "hsl"
        * (lowercase) to parse HSV or HSL color space (with optional alpha).
        * HSV and HSL colors may be specified as normalized parameters (0-1),
        * or as an angle (0-360) and two percentages (0-100).
        *
        * - Pass a string containing a hexadecimal color with or without alpha
        * (such as "ff8040ff" or "4080ff"). You may prepend "#" or "0x", but
        * they are not necessary and will be stripped.
        *
        * - Pass a string containing a CSS color function, such as
        * "rgb(255,255,255)", "rgba( 192, 127, 64, 32 )",
        * "hsl(180, 100, 100)", or "hsla(360, 50, 50, 50)".
        *
        * - Pass 1 number to set a grayscale value, or 2 numbers to set grayscale
        * with alpha. These are interpreted as with RGB values.
        *
        * The color object stores its internal values as normalized RGBA channels.
        * This is the most mathematically useful format, and corresponds
        * with the WebGL color paradigm. When you query the color object's values,
        * such as with "r" or "red" properties, it will return normalized values.
        * You can get values in the 0-255 8-bit range by calling the
        * corresponding x255 value. For example, if r = 1, then r255 = 255.
        *
        * We advise that you work with normalized colors wherever possible.
        * While the Color object is smart enough to recognise non-normalized
        * ranges in most cases, it cannot tell the difference between 0.5 on a
        * 0-1 scale, and 0.5 on a 0-255 scale. Try to reduce ambiguity by working
        * in normalized color space.
        *
        * You can get HSV, HSL, and hexadecimal values with the functions
        * "getHsva", "getHsla", and "getHex". By default, these all include an
        * alpha term. You can omit alpha from the getHex result by calling the
        * function with the parameter "false". As getHsva and getHsla return objects
        * rather than strings, you can freely ignore the provided alpha.
        *
        * You can modify a Color object once created using its properties, methods,
        * or the "set" method as you would use the constructor.
        *
        * @class Color
        * @constructor
        * @param [...args] Any number of arguments
        * @since 1.2.0
        */
        var Color = (function () {
            function Color() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                /**
                * Red channel, stored as a normalized value between 0 and 1.
                * This is most compatible with graphics hardware.
                * @property _r
                * @type number
                * @default 0.5
                * @private
                */
                this._r = 0.5;
                /**
                * Green channel, stored as a normalized value between 0 and 1.
                * This is most compatible with graphics hardware.
                * @property _g
                * @type number
                * @default 0.5
                * @private
                */
                this._g = 0.5;
                /**
                * Blue channel, stored as a normalized value between 0 and 1.
                * This is most compatible with graphics hardware.
                * @property _b
                * @type number
                * @default 0.5
                * @private
                */
                this._b = 0.5;
                /**
                * Alpha channel, stored as a normalized value between 0 and 1.
                * This is most compatible with graphics hardware.
                * @property _a
                * @type number
                * @default 0.5
                * @private
                */
                this._a = 1;
                this.set.apply(this, args);
                return this;
            }
            /**
            * Set colors from parameters, as in the class description.
            * If you supply invalid parameters, the color will be unchanged.
            * @method set
            * @param params {object} Composite parameter object
            * @return {Kiwi.Utils.Color} This object with the new color set
            * @public
            */
            Color.prototype.set = function () {
                var params = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    params[_i - 0] = arguments[_i];
                }
                if (params.length === 3) {
                    // RGB
                    this.r = params[0];
                    this.g = params[1];
                    this.b = params[2];
                }
                else if (params.length === 4) {
                    if (!isNaN(params[3])) {
                        // RGBA
                        this.r = params[0];
                        this.g = params[1];
                        this.b = params[2];
                        this.a = params[3];
                    }
                    else if (params[3] === "hsv") {
                        // HSV
                        this.parseHsv(params[0], params[1], params[2]);
                    }
                    else if (params[3] === "hsl") {
                        // HSL
                        this.parseHsl(params[0], params[1], params[2]);
                    }
                }
                else if (params.length === 5) {
                    if (params[4] === "hsv") {
                        // HSVA
                        this.parseHsv(params[0], params[1], params[2], params[3]);
                    }
                    else if (params[4] === "hsl") {
                        // HSLA
                        this.parseHsl(params[0], params[1], params[2], params[3]);
                    }
                }
                else if (params.length === 1) {
                    if (typeof params[0] === "string") {
                        // String format
                        this.parseString(params[0]);
                    }
                    else if (!isNaN(params[0])) {
                        // Grayscale
                        this.r = params[0];
                        this.g = params[0];
                        this.b = params[0];
                    }
                }
                else if (params.length === 2) {
                    // Grayscale and alpha
                    this.r = params[0];
                    this.g = params[0];
                    this.b = params[0];
                    this.a = params[1];
                }
                return this;
            };
            Object.defineProperty(Color.prototype, "rNorm", {
                /**
                * Red channel, stored as a normalized value between 0 and 1.
                * @property rNorm
                * @type number
                * @public
                */
                get: function () {
                    return this._r;
                },
                set: function (value) {
                    if (!isNaN(value)) {
                        this._r = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color.prototype, "gNorm", {
                /**
                * Green channel, stored as a normalized value between 0 and 1.
                * @property gNorm
                * @type number
                * @public
                */
                get: function () {
                    return this._g;
                },
                set: function (value) {
                    if (!isNaN(value)) {
                        this._g = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color.prototype, "bNorm", {
                /**
                * Blue channel, stored as a normalized value between 0 and 1.
                * @property bNorm
                * @type number
                * @public
                */
                get: function () {
                    return this._b;
                },
                set: function (value) {
                    if (!isNaN(value)) {
                        this._b = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color.prototype, "aNorm", {
                /**
                * Alpha channel, stored as a normalized value between 0 and 1.
                * @property aNorm
                * @type number
                * @public
                */
                get: function () {
                    return this._a;
                },
                set: function (value) {
                    if (!isNaN(value)) {
                        this._a = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color.prototype, "r", {
                /**
                * Red channel.
                * If set to a number in the range 0-1, is interpreted as a
                * normalized color (see rNorm).
                * If set to a number above 1, is interpreted as an 8-bit channel
                * (see r255).
                * If queried, returns a normalized number in the range 0-1.
                * @property r
                * @type number
                * @public
                */
                get: function () {
                    return this._r;
                },
                set: function (value) {
                    if (value > 1) {
                        this.r255 = value;
                    }
                    else {
                        this.rNorm = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color.prototype, "g", {
                /**
                * Green channel.
                * If set to a number in the range 0-1, is interpreted as a
                * normalized color (see gNorm).
                * If set to a number above 1, is interpreted as an 8-bit channel
                * (see g255).
                * If queried, returns a normalized number in the range 0-1.
                * @property g
                * @type number
                * @public
                */
                get: function () {
                    return this._g;
                },
                set: function (value) {
                    if (value > 1) {
                        this.g255 = value;
                    }
                    else {
                        this.gNorm = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color.prototype, "b", {
                /**
                * Blue channel.
                * If set to a number in the range 0-1, is interpreted as a
                * normalized color (see bNorm).
                * If set to a number above 1, is interpreted as an 8-bit channel
                * (see b255).
                * If queried, returns a normalized number in the range 0-1.
                * @property b
                * @type number
                * @public
                */
                get: function () {
                    return this._b;
                },
                set: function (value) {
                    if (value > 1) {
                        this.b255 = value;
                    }
                    else {
                        this.bNorm = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color.prototype, "a", {
                /**
                * Alpha channel.
                * If set to a number in the range 0-1, is interpreted as a
                * normalized color (see aNorm).
                * If set to a number above 1, is interpreted as an 8-bit channel
                * (see a255).
                * If queried, returns a normalized number in the range 0-1.
                * @property a
                * @type number
                * @public
                */
                get: function () {
                    return this._a;
                },
                set: function (value) {
                    if (value > 1) {
                        this.a255 = value;
                    }
                    else {
                        this.aNorm = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color.prototype, "r255", {
                /**
                * Red channel, specified as an 8-bit channel in the range 0-255.
                * @property r255
                * @type number
                * @public
                */
                get: function () {
                    return Math.round(this._r * 255);
                },
                set: function (value) {
                    if (!isNaN(value)) {
                        this._r = value / 255;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color.prototype, "g255", {
                /**
                * Green channel, specified as an 8-bit channel in the range 0-255.
                * @property g255
                * @type number
                * @public
                */
                get: function () {
                    return Math.round(this._g * 255);
                },
                set: function (value) {
                    if (!isNaN(value)) {
                        this._g = value / 255;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color.prototype, "b255", {
                /**
                * Blue channel, specified as an 8-bit channel in the range 0-255.
                * @property b255
                * @type number
                * @public
                */
                get: function () {
                    return Math.round(this._b * 255);
                },
                set: function (value) {
                    if (!isNaN(value)) {
                        this._b = value / 255;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color.prototype, "a255", {
                /**
                * Alpha channel, specified as an 8-bit channel in the range 0-255.
                * @property a255
                * @type number
                * @public
                */
                get: function () {
                    return Math.round(this._a * 255);
                },
                set: function (value) {
                    if (!isNaN(value)) {
                        this._a = value / 255;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color.prototype, "red", {
                /**
                * Red channel, alias of r
                * @property red
                * @type number
                * @public
                */
                get: function () {
                    return this.r;
                },
                set: function (value) {
                    this.r = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color.prototype, "green", {
                /**
                * Green channel, alias of g
                * @property green
                * @type number
                * @public
                */
                get: function () {
                    return this.g;
                },
                set: function (value) {
                    this.g = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color.prototype, "blue", {
                /**
                * Blue channel, alias of b
                * @property blue
                * @type number
                * @public
                */
                get: function () {
                    return this.b;
                },
                set: function (value) {
                    this.b = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Color.prototype, "alpha", {
                /**
                * Alpha channel, alias of a
                * @property alpha
                * @type number
                * @public
                */
                get: function () {
                    return this.a;
                },
                set: function (value) {
                    this.a = value;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Parse colors from strings
            * @method parseString
            * @param color {string} A CSS color specification
            * @return {Kiwi.Utils.Color} This object with the new color set
            * @public
            */
            Color.prototype.parseString = function (color) {
                var colArray;
                color = color.toLowerCase();
                // RGBA notation
                if (color.slice(0, 4) === "rgba") {
                    color = color.replace("rgba", "");
                    color = color.replace("(", "");
                    color = color.replace(")", "");
                    colArray = color.split(",");
                    this.r = +colArray[0];
                    this.g = +colArray[1];
                    this.b = +colArray[2];
                    this.a = +colArray[3];
                }
                else if (color.slice(0, 3) === "rgb") {
                    color = color.replace("rgb", "");
                    color = color.replace("(", "");
                    color = color.replace(")", "");
                    colArray = color.split(",");
                    this.r = +colArray[0];
                    this.g = +colArray[1];
                    this.b = +colArray[2];
                }
                else if (color.slice(0, 4) === "hsla") {
                    color = color.replace("hsla", "");
                    color = color.replace("(", "");
                    color = color.replace(")", "");
                    colArray = color.split(",");
                    this.parseHsl(+colArray[0], +colArray[1], +colArray[2], +colArray[3]);
                }
                else if (color.slice(0, 3) === "hsl") {
                    color = color.replace("hsl", "");
                    color = color.replace("(", "");
                    color = color.replace(")", "");
                    colArray = color.split(",");
                    this.parseHsl(+colArray[0], +colArray[1], +colArray[2]);
                }
                else {
                    this.parseHex(color);
                }
                return this;
            };
            /**
            * Parse hexadecimal colors from strings
            * @method parseHex
            * @param color {string} A hexadecimal color such as "ffffff" (no alpha)
            *	or "ffffffff" (with alpha). Also supports "fff" and "ffff"
            *	with 4-bit channels.
            * @return {Kiwi.Utils.Color} This object with the new color set
            * @public
            */
            Color.prototype.parseHex = function (color) {
                var bigint, r = this.r255, g = this.g255, b = this.b255, a = this.a255;
                // Strip leading signifiers
                if (color.charAt(0) === "#") {
                    color = color.slice(1);
                }
                if (color.slice(0, 2) === "0x") {
                    color = color.slice(2);
                }
                bigint = parseInt(color, 16);
                if (color.length === 3) {
                    r = 17 * ((bigint >> 8) & 15);
                    g = 17 * ((bigint >> 4) & 15);
                    b = 17 * (bigint & 15);
                }
                else if (color.length === 4) {
                    r = 17 * ((bigint >> 12) & 15);
                    g = 17 * ((bigint >> 8) & 15);
                    b = 17 * ((bigint >> 4) & 15);
                    a = 17 * (bigint & 15);
                }
                else if (color.length === 6) {
                    r = (bigint >> 16) & 255;
                    g = (bigint >> 8) & 255;
                    b = bigint & 255;
                    a = 255;
                }
                else if (color.length === 8) {
                    r = (bigint >> 24) & 255;
                    g = (bigint >> 16) & 255;
                    b = (bigint >> 8) & 255;
                    a = bigint & 255;
                }
                this.r255 = r;
                this.g255 = g;
                this.b255 = b;
                this.a255 = a;
                return this;
            };
            /**
            * Returns color as a hexadecimal string
            * @method getHex
            * @param [alpha=true] {boolean} Whether to include the alpha
            * @return {string} A hexadecimal color such as "13579bdf"
            * @public
            */
            Color.prototype.getHex = function (alpha) {
                if (alpha === void 0) { alpha = true; }
                var subStr, str = "";
                subStr = this.r255.toString(16);
                while (subStr.length < 2) {
                    subStr = "0" + subStr;
                }
                str += subStr;
                subStr = this.g255.toString(16);
                while (subStr.length < 2) {
                    subStr = "0" + subStr;
                }
                str += subStr;
                subStr = this.b255.toString(16);
                while (subStr.length < 2) {
                    subStr = "0" + subStr;
                }
                str += subStr;
                if (alpha) {
                    subStr = this.a255.toString(16);
                    while (subStr.length < 2) {
                        subStr = "0" + subStr;
                    }
                    str += subStr;
                }
                return str;
            };
            /**
            * Parses normalized HSV values into the Color.
            * Interprets either normalized values, or H in degrees (0-360)
            * and S and V in % (0-100).
            *
            * Based on algorithms at
            * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
            * @method parseHsv
            * @param h {number} Hue
            * @param s {number} Saturation
            * @param v {number} Value
            * @param a {number} Alpha
            * @return {Kiwi.Utils.Color} This object with the new color set
            * @public
            */
            Color.prototype.parseHsv = function (h, s, v, a) {
                if (a === void 0) { a = 1; }
                var r, g, b, i, f, p, q, t;
                if (isNaN(h) || isNaN(s) || isNaN(v) || isNaN(a)) {
                    return this;
                }
                if (h > 1) {
                    h /= 360;
                }
                if (s > 1) {
                    s /= 100;
                }
                if (v > 1) {
                    v /= 100;
                }
                if (a > 1) {
                    a /= 255;
                }
                i = Math.floor(h * 6);
                f = h * 6 - i;
                p = v * (1 - s);
                q = v * (1 - f * s);
                t = v * (1 - (1 - f) * s);
                switch (i % 6) {
                    case 0:
                        r = v;
                        g = t;
                        b = p;
                        break;
                    case 1:
                        r = q;
                        g = v;
                        b = p;
                        break;
                    case 2:
                        r = p;
                        g = v;
                        b = t;
                        break;
                    case 3:
                        r = p;
                        g = q;
                        b = v;
                        break;
                    case 4:
                        r = t;
                        g = p;
                        b = v;
                        break;
                    case 5:
                        r = v;
                        g = p;
                        b = q;
                        break;
                }
                this._r = r;
                this._g = g;
                this._b = b;
                this._a = a;
                return this;
            };
            /**
            * Returns HSV value of the Color.
            * Based on algorithms at
            * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
            * @method getHsva
            * @return {object} Object with normalized h, s, v, a properties.
            */
            Color.prototype.getHsva = function () {
                var h, s, v, d, r = this._r, g = this._g, b = this._b, max = Math.max(r, g, b), min = Math.min(r, g, b);
                h = max;
                s = max;
                v = max;
                d = max - min;
                s = max === 0 ? 0 : d / max;
                if (max === min) {
                    // Achromatic
                    h = 0;
                }
                else {
                    switch (max) {
                        case r:
                            h = (g - b) / d + (g < b ? 6 : 0);
                            break;
                        case g:
                            h = (b - r) / d + 2;
                            break;
                        case b:
                            h = (r - g) / d + 4;
                            break;
                    }
                    h /= 6;
                }
                return { h: h, s: s, v: v, a: this._a };
            };
            /**
            * Parses HSL value onto the Color.
            * Interprets either normalized values, or H in degrees (0-360)
            * and S and L in % (0-100).
            *
            * Based on algorithms at
            * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
            * @method parseHsl
            * @param h {number} Hue
            * @param s {number} Saturation
            * @param l {number} Lightness
            * @param a {number} Alpha
            * @return {Kiwi.Utils.Color} This object with the new color set
            * @public
            */
            Color.prototype.parseHsl = function (h, s, l, a) {
                if (a === void 0) { a = 1; }
                var q, p, r = this._r, g = this._g, b = this._b;
                // Sanitize values
                if (isNaN(h) || isNaN(s) || isNaN(l) || isNaN(a)) {
                    return this;
                }
                if (h > 1) {
                    h /= 360;
                }
                if (s > 1) {
                    s /= 100;
                }
                if (l > 1) {
                    l /= 100;
                }
                if (a > 1) {
                    a /= 255;
                }
                if (s === 0) {
                    // Achromatic
                    r = l;
                    g = l;
                    b = l;
                }
                else {
                    q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    p = 2 * l - q;
                    r = this._hue2rgb(p, q, h + 1 / 3);
                    g = this._hue2rgb(p, q, h);
                    b = this._hue2rgb(p, q, h - 1 / 3);
                }
                this._r = r;
                this._g = g;
                this._b = b;
                this._a = a;
                return this;
            };
            /**
            * Returns HSL value of the Color.
            * Based on algorithms at
            * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
            * @method getHsla
            * @return {object} Object with normalized h, s, l, a properties.
            * @public
            */
            Color.prototype.getHsla = function () {
                var d, r = this._r, g = this._g, b = this._b, max = Math.max(r, g, b), min = Math.min(r, g, b), h = (max + min) / 2, s = (max + min) / 2, l = (max + min) / 2;
                if (max == min) {
                    // Achromatic
                    h = 0;
                    s = 0;
                }
                else {
                    d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r:
                            h = (g - b) / d + (g < b ? 6 : 0);
                            break;
                        case g:
                            h = (b - r) / d + 2;
                            break;
                        case b:
                            h = (r - g) / d + 4;
                            break;
                    }
                    h /= 6;
                }
                return { h: h, s: s, l: l, a: this._a };
            };
            /**
            * Method used for computing HSL values.
            * Based on algorithms at
            * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
            * @method _hue2rgb
            * @param p {number}
            * @param q {number}
            * @param t {number}
            * @return number
            * @private
            */
            Color.prototype._hue2rgb = function (p, q, t) {
                if (t < 0) {
                    t += 1;
                }
                if (t > 1) {
                    t -= 1;
                }
                if (t < 1 / 6) {
                    return p + (q - p) * 6 * t;
                }
                if (t < 1 / 2) {
                    return q;
                }
                if (t < 2 / 3) {
                    return p + (q - p) * (2 / 3 - t) * 6;
                }
                return p;
            };
            return Color;
        })();
        Utils.Color = Color;
    })(Utils = Kiwi.Utils || (Kiwi.Utils = {}));
})(Kiwi || (Kiwi = {}));
/**
* Utils is a space that holds a wide varity of useful methods.
*
* @module Kiwi
* @submodule Utils
* @main Utils
*/
var Kiwi;
(function (Kiwi) {
    var Utils;
    (function (Utils) {
        /**
        * Methods to assist in working with Structs.
        * A lot of the functions in this class are Copyright 2012 Mauricio Santos and used with permission.
        * His work is licensed under the Apache License, Version 2.0 (the "License")
        *
        * @class Common
        * @namespace Kiwi.Utils
        * @static
        *
        * @author Mauricio Santos
        */
        var Common = (function () {
            function Common() {
            }
            /**
            * Default function to compare element order.
            * @method defaultCompare
            * @param {Any} a.
            * @param {Any} b.
            * @return {Number}
            * @static
            */
            Common.defaultCompare = function (a, b) {
                if (a < b) {
                    return -1;
                }
                else if (a === b) {
                    return 0;
                }
                else {
                    return 1;
                }
            };
            /**
            * The type of object that this is.
            * @method objType
            * @return {String} "Common"
            * @public
            */
            Common.prototype.objType = function () {
                return "Common";
            };
            /**
            * Default function to test equality.
            * @method defaultEquals
            * @param {Any} a
            * @param {Any} b
            * @return {boolean}
            * @static
            * @public
            */
            Common.defaultEquals = function (a, b) {
                return a === b;
            };
            /**
            * Default function to convert an object to a string.
            * @method defaultToString
            * @param item {Any}
            * @return {Any}
            * @static
            * @public
            */
            Common.defaultToString = function (item) {
                if (item === null) {
                    return 'KIWI_NULL';
                }
                else if (Kiwi.Utils.Common.isUndefined(item)) {
                    return 'KIWI_UNDEFINED';
                }
                else if (Kiwi.Utils.Common.isString(item)) {
                    return item;
                }
                else {
                    return item.toString();
                }
            };
            /**
            * Returns a boolean indicating whether x is between two parameters passed.
            *
            * @method isBetween
            * @param x {Number} The values to be checked
            * @param min {Number} The minimum value
            * @param max {Number} The maximum value
            * @return {Boolean}
            * @static
            * @public
            */
            Common.isBetween = function (x, min, max) {
                return (x > min && x < max);
            };
            /**
            * Checks if the given argument is a function.
            * @method isFunction
            * @param {Any} func.
            * @return {boolean}
            * @static
            * @public
            */
            Common.isFunction = function (func) {
                return (typeof func) === 'function';
            };
            /**
            * Checks if the given value is numeric.
            * @method isNumeric
            * @param value {Any}
            * @return {Boolean}
            * @static
            * @public
            */
            Common.isNumeric = function (value) {
                return !isNaN(value);
            };
            /**
            * Checks if the given argument is undefined.
            * @method isUndefined
            * @param {Any} obj
            * @return {boolean}
            * @static
            * @public
            */
            Common.isUndefined = function (obj) {
                return (typeof obj) === 'undefined';
            };
            /**
            * Checks if the given argument is a string.
            * @method isString
            * @param {Any} obj
            * @return {boolean}
            * @static
            * @public
            */
            Common.isString = function (obj) {
                return Object.prototype.toString.call(obj) === '[object String]';
            };
            /**
            * Checks if the given argument is a array.
            * @method isArray
            * @param {Any} obj
            * @return {boolean}
            * @static
            * @public
            */
            Common.isArray = function (obj) {
                return Object.prototype.toString.call(obj) === "[object Array]";
            };
            /**
            * Checks if the given argument is an object.
            * @method isObject
            * @param {Any} obj
            * @return {boolean}
            * @static
            * @public
            */
            Common.isObject = function (obj) {
                return Object.prototype.toString.call(obj) === "[object Object]";
            };
            /**
            * Reverses a compare function.
            * @method reverseCompareFunction
            * @param {Any} compareFunction
            * @return {Number}
            * @static
            * @public
            */
            Common.reverseCompareFunction = function (compareFunction) {
                if (!Kiwi.Utils.Common.isFunction(compareFunction)) {
                    return function (a, b) {
                        if (a < b) {
                            return 1;
                        }
                        else if (a === b) {
                            return 0;
                        }
                        else {
                            return -1;
                        }
                    };
                }
                else {
                    return function (d, v) {
                        return compareFunction(d, v) * -1;
                    };
                }
            };
            /**
            * Returns an equal function given a compare function.
            * @method compareToEquals
            * @param {Any} compareFunction
            * @return {boolean}
            * @static
            * @public
            */
            Common.compareToEquals = function (compareFunction) {
                return function (a, b) {
                    return compareFunction(a, b) === 0;
                };
            };
            /**
            * Shuffles the contents of an array given into a random order.
            * @method shuffleArray
            * @param array {Any}
            * @return {Any} What you passed but the with the contents in a new order.
            * @static
            * @public
            */
            Common.shuffleArray = function (array) {
                for (var i = array.length - 1; i > 0; i--) {
                    var j = Math.floor(Math.random() * (i + 1));
                    var temp = array[i];
                    array[i] = array[j];
                    array[j] = temp;
                }
                return array;
            };
            /**
            * A method that checks to see if an Image or Canvas that is passed has base2 proportions.
            * If it doesn't the image is created on a Canvas and that Canvas is returned.
            * Used mainly when creating TextureAtlases for WebGL.
            * @method convertToBase2
            * @param imageFile {HTMLImageElement/HTMLCanvasElement} The image or canvas element that is to be converted into a base2size.
            * @return {HTMLImageElement/HTMLCanvasElement} The image that was passed (if it was already at base2 dimensions) or a new canvas element if it wasn't.
            * @static
            * @public
            */
            Common.convertToBase2 = function (image) {
                //Get the width/height
                var width = image.width;
                var height = image.height;
                //Check to see if the width is base2
                if (this.base2Sizes.indexOf(width) == -1) {
                    var i = 0;
                    while (width > this.base2Sizes[i])
                        i++;
                    width = this.base2Sizes[i];
                }
                //Check to see if the height is base2
                if (this.base2Sizes.indexOf(height) == -1) {
                    var i = 0;
                    while (height > this.base2Sizes[i])
                        i++;
                    height = this.base2Sizes[i];
                }
                //If either of them did not have a base2 size then create a canvas and create a new canvas.
                if (image.width !== width || image.height !== height) {
                    //Is it already a canvas?
                    var canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    canvas.getContext("2d").drawImage(image, 0, 0);
                    return canvas;
                }
                return image;
            };
            /**
            * An array containing all of the base2sizes that are allowed.
            * This is used when creating a new TextureAtlas/or resizing a Image to be rendered in WebGL.
            * @property base2Sizes
            * @type number[]
            * @public
            * @static
            */
            Common.base2Sizes = [2, 4, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096];
            return Common;
        })();
        Utils.Common = Common;
    })(Utils = Kiwi.Utils || (Kiwi.Utils = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Utils
*/
var Kiwi;
(function (Kiwi) {
    var Utils;
    (function (Utils) {
        /**
        * Adds a set of extra Math functions and extends a few commonly used ones.
        * Includes some methods written by Dylan Engelman.
        *
        * @class GameMath
        * @namespace Kiwi.Utils
        * @static
        *
        * @author Richard Davey
        * @author Dylan Engelman
        */
        var GameMath = (function () {
            function GameMath() {
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String} "GameMath"
            * @public
            */
            GameMath.prototype.objType = function () {
                return "GameMath";
            };
            /**
            * Computes the maximum relative error for this machine.
            * @method computeMachineEpsilon
            * @return {Number}
            * @static
            * @public
            */
            GameMath.computeMachineEpsilon = function () {
                // Machine epsilon ala Eispack
                var fourThirds = 4.0 / 3.0;
                var third = fourThirds - 1.0;
                var one = third + third + third;
                return Math.abs(1.0 - one);
            };
            /**
            * Computes whether two numbers are identical to the limits of the computer's precision, as specified by the epsilon value.
            * @method fuzzyEqual
            * @param a {number}
            * @param b {number}
            * @param [epsilon=0.0001] {number}
            * @return {boolean}
            * @static
            * @public
            */
            GameMath.fuzzyEqual = function (a, b, epsilon) {
                if (epsilon === void 0) { epsilon = 0.0001; }
                return Math.abs(a - b) < epsilon;
            };
            /**
            * Computes whether the first parameter is less than the second parameter, to the limits of the computer's precision, as specified by the epsilon value.
            * @method fuzzyLessThan
            * @param a {number}
            * @param b {number}
            * @param [epsilon=0.0001] {number}
            * @return {boolean}
            * @static
            * @public
            */
            GameMath.fuzzyLessThan = function (a, b, epsilon) {
                if (epsilon === void 0) { epsilon = 0.0001; }
                return a < b + epsilon;
            };
            /**
            * Computes whether the first parameter is greater than the second parameter, to the limits of the computer's precision, as specified by the epsilon value.
            * @method fuzzyGreaterThan
            * @param a {number}
            * @param b {number}
            * @param [epsilon=0.0001] {number}
            * @return {boolean}
            * @static
            * @public
            */
            GameMath.fuzzyGreaterThan = function (a, b, epsilon) {
                if (epsilon === void 0) { epsilon = 0.0001; }
                return a > b - epsilon;
            };
            /**
            * Computes the integer ceiling of the first parameter, minus a rounding margin defined by epsilon.
            * @method fuzzyCeil
            * @param val {number}
            * @param [epsilon=0.0001] {number}
            * @return {Number}
            * @static
            * @public
            */
            GameMath.fuzzyCeil = function (val, epsilon) {
                if (epsilon === void 0) { epsilon = 0.0001; }
                return Math.ceil(val - epsilon);
            };
            /**
            * Computes the integer floor of the first parameter, plus a rounding margin defined by epsilon.
            * @method fuzzyFloor
            * @param val {number}
            * @param [epsilion=0.0001] {number}
            * @return {Number}
            * @static
            * @public
            */
            GameMath.fuzzyFloor = function (val, epsilon) {
                if (epsilon === void 0) { epsilon = 0.0001; }
                return Math.floor(val + epsilon);
            };
            /**
            * Computes the mean of any number of parameters. For example, average(1,2,3) returns 2.
            * @method average
            * @param [args]* {Any[]}
            * @return {Number}
            * @static
            * @public
            */
            GameMath.average = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                var avg = 0;
                for (var i = 0; i < args.length; i++) {
                    avg += args[i];
                }
                return avg / args.length;
            };
            /**
            * Computes whether value and target are sufficiently close as to be within the computer's margin of error, as defined by epsilon. Returns the target if they are sufficiently close; returns the value if they are not.
            *
            * In other words, slam prevents the target from exceeding epsilon.
            * @method slam
            * @param value {number}
            * @param target {number}
            * @param [epsilon=0.0001] {number}
            * @return {Number}
            * @static
            * @public
            */
            GameMath.slam = function (value, target, epsilon) {
                if (epsilon === void 0) { epsilon = 0.0001; }
                return (Math.abs(value - target) < epsilon) ? target : value;
            };
            /**
            * Ratio of value to a range.
            * @method percentageMinMax
            * @param val {number}
            * @param max {number}
            * @param [min=0] {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.percentageMinMax = function (val, max, min) {
                if (min === void 0) { min = 0; }
                val -= min;
                max -= min;
                if (!max)
                    return 0;
                else
                    return val / max;
            };
            /**
            * A value representing the sign of the value.
            * -1 for negative, +1 for positive, 0 if value is 0
            * @method sign
            * @param n {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.sign = function (n) {
                if (n)
                    return n / Math.abs(n);
                else
                    return 0;
            };
            /**
            * Truncates a value by removing all decimal data.
            * @method truncate
            * @param n {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.truncate = function (n) {
                return (n > 0) ? Math.floor(n) : Math.ceil(n);
            };
            /**
            * Removes all non-decimal data from the value.
            * @method shear
            * @param n {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.shear = function (n) {
                return n % 1;
            };
            /**
            * Wrap a value around a range, similar to modulus with a floating minimum
            * @method wrap
            * @param val {number}
            * @param max {number}
            * @param [min=0] {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.wrap = function (val, max, min) {
                if (min === void 0) { min = 0; }
                val -= min;
                max -= min;
                if (max == 0)
                    return min;
                val %= max;
                val += min;
                while (val < min)
                    val += max;
                return val;
            };
            /**
            * Arithmetic version of wrap.
            * @method arithWrap
            * @param val {number}
            * @param max {number}
            * @param [min=0] {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.arithWrap = function (value, max, min) {
                if (min === void 0) { min = 0; }
                max -= min;
                if (max == 0)
                    return min;
                return value - max * Math.floor((value - min) / max);
            };
            /**
            * Force a value within the boundaries of two values
            * If max < min, min is returned.
            * @method clamp
            * @param input {number}
            * @param max {number}
            * @param [min=0] {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.clamp = function (input, max, min) {
                if (min === void 0) { min = 0; }
                return Math.max(min, Math.min(max, input));
            };
            /**
            * Snap a value to nearest grid slice, using rounding.
            * Example if you have an interval gap of 5 and a position of 12... you will snap to 10. Where as 14 will snap to 15
            *
            * @method snapTo
            * @param input {number} The value to snap
            * @param gap {number} The interval gap of the grid
            * @param [start=0] {number} Optional starting offset for gap
            * @return {number}
            * @static
            * @public
            */
            GameMath.snapTo = function (input, gap, start) {
                if (start === void 0) { start = 0; }
                if (gap == 0)
                    return input;
                input -= start;
                input = gap * Math.round(input / gap);
                return start + input;
            };
            /**
            * Snap a value to nearest grid slice, using floor.
            * Example if you have an interval gap of 5 and a position of 12... you will snap to 10. As will 14 snap to 10... but 16 will snap to 15
            *
            * @method snapToFloor
            * @param input {number} The value to snap
            * @param gap {number} The interval gap of the grid
            * @param [start=0] {number} Optional starting offset for gap
            * @return {number}
            * @static
            * @public
            */
            GameMath.snapToFloor = function (input, gap, start) {
                if (start === void 0) { start = 0; }
                if (gap == 0)
                    return input;
                input -= start;
                input = gap * Math.floor(input / gap);
                return start + input;
            };
            /**
            * Snap a value to nearest grid slice, using ceil.
            * Example if you have an interval gap of 5 and a position of 12... you will snap to 15. As will 14 will snap to 15... but 16 will snap to 20
            *
            * @method snapToCeil
            * @param input {number} The value to snap
            * @param gap {number} The interval gap of the grid
            * @param [start=0] {number} optional starting offset for gap
            * @return {number}
            * @static
            * @public
            */
            GameMath.snapToCeil = function (input, gap, start) {
                if (start === void 0) { start = 0; }
                if (gap == 0)
                    return input;
                input -= start;
                input = gap * Math.ceil(input / gap);
                return start + input;
            };
            /**
            * Snaps a value to the nearest value in an array.
            * @method snapToInArray
            * @param input {number}
            * @param arr {number[]}
            * @param [sort=true] {boolean}
            * @return {number}
            * @static
            * @public
            */
            GameMath.snapToInArray = function (input, arr, sort) {
                if (sort === void 0) { sort = true; }
                if (sort)
                    arr.sort();
                if (input < arr[0])
                    return arr[0];
                var i = 1;
                while (arr[i] < input)
                    i++;
                var low = arr[i - 1];
                var high = (i < arr.length) ? arr[i] : Number.POSITIVE_INFINITY;
                return ((high - input) <= (input - low)) ? high : low;
            };
            /**
            * Round to some place comparative to a 'base', default is 10 for decimal place.
            * 'place' is represented by the power applied to 'base' to get that place
            *
            * @method roundTo
            * @param value {number} The value to round
            * @param [place=0] {number} The place to round to
            * @param [base=10] {number} The base to round in... default is 10 for decimal
            * @return {number}
            * @static
            * @public
            */
            GameMath.roundTo = function (value, place, base) {
                if (place === void 0) { place = 0; }
                if (base === void 0) { base = 10; }
                var p = Math.pow(base, -place);
                return Math.round(value * p) / p;
            };
            /*
            * E.g.
            *
            * 2000/7 ~= 285.714285714285714285714 ~= (bin)100011101.1011011011011011
            *
            * roundTo(2000/7,3) == 0
            * roundTo(2000/7,2) == 300
            * roundTo(2000/7,1) == 290
            * roundTo(2000/7,0) == 286
            * roundTo(2000/7,-1) == 285.7
            * roundTo(2000/7,-2) == 285.71
            * roundTo(2000/7,-3) == 285.714
            * roundTo(2000/7,-4) == 285.7143
            * roundTo(2000/7,-5) == 285.71429
            *
            * roundTo(2000/7,3,2)  == 288       -- 100100000
            * roundTo(2000/7,2,2)  == 284       -- 100011100
            * roundTo(2000/7,1,2)  == 286       -- 100011110
            * roundTo(2000/7,0,2)  == 286       -- 100011110
            * roundTo(2000/7,-1,2) == 285.5     -- 100011101.1
            * roundTo(2000/7,-2,2) == 285.75    -- 100011101.11
            * roundTo(2000/7,-3,2) == 285.75    -- 100011101.11
            * roundTo(2000/7,-4,2) == 285.6875  -- 100011101.1011
            * roundTo(2000/7,-5,2) == 285.71875 -- 100011101.10111
            *
            * Note what occurs when we round to the 3rd space (8ths place), 100100000, this is to be assumed
            * because we are rounding 100011.1011011011011011 which rounds up.
            */
            /**
            * Round down to some place comparative to a 'base', default is 10 for decimal place.
            * 'place' is represented by the power applied to 'base' to get that place
            * @method floorTo
            * @param value {number}
            * @param [place=0] {number}
            * @param [base=10] {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.floorTo = function (value, place, base) {
                if (place === void 0) { place = 0; }
                if (base === void 0) { base = 10; }
                var p = Math.pow(base, -place);
                return Math.floor(value * p) / p;
            };
            /**
            * Round down to some place comparative to a 'base', default is 10 for decimal place.
            * 'place' is represented by the power applied to 'base' to get that place
            * @method ceilTo
            * @param value {number}
            * @param [place=0] {number}
            * @param [base=10] {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.ceilTo = function (value, place, base) {
                if (place === void 0) { place = 0; }
                if (base === void 0) { base = 10; }
                var p = Math.pow(base, -place);
                return Math.ceil(value * p) / p;
            };
            /**
            * A one dimensional linear interpolation of a value.
            * @method interpolateFloat
            * @param a {number}
            * @param b {number}
            * @param weight {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.interpolateFloat = function (a, b, weight) {
                return (b - a) * weight + a;
            };
            /**
            * Convert radians to degrees
            * @method radiansToDegrees
            * @param angle {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.radiansToDegrees = function (angle) {
                return angle * GameMath.RAD_TO_DEG;
            };
            /**
            * Convert degrees to radians
            * @method degreesToRadians
            * @param angle {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.degreesToRadians = function (angle) {
                return angle * GameMath.DEG_TO_RAD;
            };
            /**
            * Find the angle of a segment from (x1, y1) -> (x2, y2 )
            * @method angleBetween
            * @param x1 {number}
            * @param y1 {number}
            * @param x2 {number}
            * @param y2 {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.angleBetween = function (x1, y1, x2, y2) {
                return Math.atan2(y2 - y1, x2 - x1);
            };
            /**
            * Returns an equivalent angle within the bounds of -PI (inclusive)
            * to PI (exclusive).
            * @method normalizeAngle
            * @param angle {number}
            * @param [radians=true] {boolean}
            * @return {number}
            * @static
            * @public
            */
            GameMath.normalizeAngle = function (angle, radians) {
                if (radians === void 0) { radians = true; }
                var rd = (radians) ? GameMath.PI : 180;
                return GameMath.wrap(angle, rd, -rd);
            };
            /**
            * Closest angle between two angles a1 and a2. In other words, the angle
            * you must turn to go from facing a1 to facing a2.
            * This will be a normalized angle between -PI and PI.
            * @method nearestAngleBetween
            * @param a1 {number}
            * @param a2 {number}
            * @param [radians=true] {boolean}
            * @return {number}
            * @static
            * @public
            */
            GameMath.nearestAngleBetween = function (a1, a2, radians) {
                if (radians === void 0) { radians = true; }
                var rd = (radians) ? GameMath.PI : 180;
                a1 = GameMath.normalizeAngle(a1, radians);
                a2 = GameMath.normalizeAngle(a2, radians);
                if (a1 < -rd / 2 && a2 > rd / 2)
                    a1 += rd * 2;
                if (a2 < -rd / 2 && a1 > rd / 2)
                    a2 += rd * 2;
                return GameMath.normalizeAngle(a2 - a1, radians);
            };
            /**
            * Normalizes independent and then sets dep to the nearest value respective to independent.
            * For instance if dep=-170 and ind=170 then 190 will be returned as an alternative to -170
            * @method normalizeAngleToAnother
            * @param dep {number}
            * @param ind {number}
            * @param [radians=true] {boolean}
            * @return {number}
            * @static
            * @public
            */
            GameMath.normalizeAngleToAnother = function (dep, ind, radians) {
                if (radians === void 0) { radians = true; }
                return ind + Kiwi.Utils.GameMath.nearestAngleBetween(ind, dep, radians);
            };
            /**
            * Normalize independent and dependent and then set dependent to an angle relative to 'after/clockwise' independent.
            * For instance dep=-170 and ind=170, then 190 will be reutrned as alternative to -170
            * @method normalizeAngleAfterAnother
            * @param dep {number}
            * @param ind {number}
            * @param [radians=true] {boolean}
            * @return {number}
            * @static
            * @public
            */
            GameMath.normalizeAngleAfterAnother = function (dep, ind, radians) {
                if (radians === void 0) { radians = true; }
                dep = Kiwi.Utils.GameMath.normalizeAngle(dep - ind, radians);
                return ind + dep;
            };
            /**
            * Normalizes indendent and dependent and then sets dependent to an angle relative to 'before/counterclockwise' independent.
            * For instance dep = 190 and ind = 170, then -170 will be returned as an alternative to 190
            * @method normalizeAngleBeforeAnother
            * @param dep {number}
            * @param ind {number}
            * @param [radians=true] {boolean}
            * @return {number}
            * @static
            * @public
            */
            GameMath.normalizeAngleBeforeAnother = function (dep, ind, radians) {
                if (radians === void 0) { radians = true; }
                dep = Kiwi.Utils.GameMath.normalizeAngle(ind - dep, radians);
                return ind - dep;
            };
            /**
            * Interpolate across the shortest arc between two angles.
            * @method interpolateAngles
            * @param a1 {number}
            * @param a2 {number}
            * @param weight {number}
            * @param [radians=true] {boolean}
            * @param [ease=null] {any}
            * @return {number}
            * @static
            * @public
            */
            GameMath.interpolateAngles = function (a1, a2, weight, radians, ease) {
                if (radians === void 0) { radians = true; }
                if (ease === void 0) { ease = null; }
                a1 = Kiwi.Utils.GameMath.normalizeAngle(a1, radians);
                a2 = Kiwi.Utils.GameMath.normalizeAngleToAnother(a2, a1, radians);
                return (typeof ease === 'function') ? ease(weight, a1, a2 - a1, 1) : Kiwi.Utils.GameMath.interpolateFloat(a1, a2, weight);
            };
            /**
            * Compute the logarithm of any value of any base.
            * A logarithm is the exponent that some constant (base) would have to be raised to
            * to be equal to value.
            * @method logBaseOf
            * @param value {number}
            * @param base {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.logBaseOf = function (value, base) {
                return Math.log(value) / Math.log(base);
            };
            /*
            * i.e.
            * 4 ^ x = 16
            * can be rewritten as to solve for x
            * logB4(16) = x
            * which with this function would be
            * LoDMath.logBaseOf(16,4)
            *
            * which would return 2, because 4^2 = 16
            */
            /**
            * Greatest Common Denominator using Euclid's algorithm.
            * @method GCD
            * @param m {number}
            * @param n {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.GCD = function (m, n) {
                var r;
                //make sure positive, GCD is always positive
                m = Math.abs(m);
                n = Math.abs(n);
                //m must be >= n
                if (m < n) {
                    r = m;
                    m = n;
                    n = r;
                }
                //now start loop
                while (true) {
                    r = m % n;
                    if (!r)
                        return n;
                    m = n;
                    n = r;
                }
                return 1;
            };
            /**
            * Lowest Common Multiple
            * @method LCM
            * @param m {number}
            * @param n {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.LCM = function (m, n) {
                return (m * n) / Kiwi.Utils.GameMath.GCD(m, n);
            };
            /**
            * Factorial - N! Simple product series. By definition:
            * 0! == 1
            * @method factorial
            * @param value {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.factorial = function (value) {
                if (value == 0)
                    return 1;
                var res = value;
                while (--value) {
                    res *= value;
                }
                return res;
            };
            /**
            * Gamma function. Defined: gamma(N) == (N - 1)!
            * @method gammaFunction
            * @param value {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.gammaFunction = function (value) {
                return Kiwi.Utils.GameMath.factorial(value - 1);
            };
            /**
            * Falling factorial. Defined: (N)! / (N - x)!
            * Written subscript: (N)x OR (base)exp
            * @method fallingFactorial
            * @param base {number}
            * @param exp {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.fallingFactorial = function (base, exp) {
                return Kiwi.Utils.GameMath.factorial(base) / Kiwi.Utils.GameMath.factorial(base - exp);
            };
            /**
            * Rising factorial. Defined: (N + x - 1)! / (N - 1)!
            * Written superscript N^(x) OR base^(exp)
            * @method risingFactorial
            * @param base {number}
            * @param exp {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.risingFactorial = function (base, exp) {
                //expanded from gammaFunction for speed
                return Kiwi.Utils.GameMath.factorial(base + exp - 1) / Kiwi.Utils.GameMath.factorial(base - 1);
            };
            /**
            * Binomial coefficient.
            * @method binCoef
            * @param n {number}
            * @param k {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.binCoef = function (n, k) {
                return Kiwi.Utils.GameMath.fallingFactorial(n, k) / Kiwi.Utils.GameMath.factorial(k);
            };
            /*
            * defined: N! / (k!(N-k)!)
            * reduced: N! / (N-k)! == (N)k (fallingfactorial)
            * reduced: (N)k / k!
            */
            /**
            * Rising binomial coefficient.
            * As one can notice in the analysis of binCoef(...) that
            * binCoef is the (N)k divided by k!. Similarly rising binCoef
            * is merely N^(k) / k!
            * @method risingBinCoef
            * @param n {number}
            * @param k {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.risingBinCoef = function (n, k) {
                return Kiwi.Utils.GameMath.risingFactorial(n, k) / Kiwi.Utils.GameMath.factorial(k);
            };
            /**
            * Generate a random boolean result based on the chance value.
            * Returns true or false based on the chance value (default 50%). For example if you wanted a player to have a 30% chance
            * of getting a bonus, call chanceRoll(30) - true means the chance passed, false means it failed.
            *
            * @method changeRoll
            * @param [chance=50] {number} The chance of receiving the value. A number between 0 and 100 (effectively 0% to 100%)
            * @return {boolean} true if the roll passed, or false
            * @static
            * @public
            */
            GameMath.chanceRoll = function (chance) {
                if (chance === void 0) { chance = 50; }
                if (chance <= 0) {
                    return false;
                }
                else if (chance >= 100) {
                    return true;
                }
                else {
                    if (Math.random() * 100 >= chance) {
                        return false;
                    }
                    else {
                        return true;
                    }
                }
            };
            /**
            * Adds the given amount to the value, but never lets the value go over the specified maximum.
            *
            * @method maxAdd
            * @param value {number} The value to add the amount to
            * @param amount {number} The amount to add to the value
            * @param max {number} The maximum the value is allowed to be
            * @return {number}
            * @static
            * @public
            */
            GameMath.maxAdd = function (value, amount, max) {
                value += amount;
                if (value > max) {
                    value = max;
                }
                return value;
            };
            /**
            * Subtracts the given amount from the value, but never lets the value go below the specified minimum.
            *
            * @method minSub
            * @param value {number} The base value
            * @param amount {number} The amount to subtract from the base value
            * @param min {number} The minimum the value is allowed to be
            * @return {number}
            * @static
            * @public
            */
            GameMath.minSub = function (value, amount, min) {
                value -= amount;
                if (value < min) {
                    value = min;
                }
                return value;
            };
            /**
            * Adds value to amount and ensures that the result always stays between 0 and max, by wrapping the value around.
            * Values must be positive integers, and are passed through Math.abs
            *
            * @method wrapValue
            * @param value {number} The value to add the amount to
            * @param amount {number} The amount to add to the value
            * @param max {number} The maximum the value is allowed to be
            * @return {number} The wrapped value
            * @static
            * @public
            */
            GameMath.wrapValue = function (value, amount, max) {
                var diff;
                value = Math.abs(value);
                amount = Math.abs(amount);
                max = Math.abs(max);
                diff = (value + amount) % max;
                return diff;
            };
            /**
            * Randomly returns either a 1 or -1
            * @method randomSign
            * @return {number} Either 1 or -1.
            * @static
            * @public
            */
            GameMath.randomSign = function () {
                return (Math.random() > 0.5) ? 1 : -1;
            };
            /**
            * Returns true if the number given is odd.
            * @method isOdd
            * @param n {number} The number to check
            * @return {boolean} True if the given number is odd. False if the given number is even.
            * @static
            * @public
            */
            GameMath.isOdd = function (n) {
                if (n & 1) {
                    return true;
                }
                else {
                    return false;
                }
            };
            /**
            * Returns true if the number given is even.
            * @method isEven
            * @param n {number} The number to check
            * @return {boolean} True if the given number is even. False if the given number is odd.
            * @static
            * @public
            */
            GameMath.isEven = function (n) {
                if (n & 1) {
                    return false;
                }
                else {
                    return true;
                }
            };
            /**
            * Keeps an angle value between -180 and +180.
            * Should be called whenever the angle is updated on the Sprite to stop it from going insane.
            * @method wrapAngle
            * @param angle {number} The angle value to check
            * @return {number} The new angle value, returns the same as the input angle if it was within bounds
            * @static
            * @public
            */
            GameMath.wrapAngle = function (angle) {
                var result = angle;
                //  Nothing needs to change
                if (angle >= -180 && angle <= 180) {
                    return angle;
                }
                //  Else normalise it to -180, 180
                result = (angle + 180) % 360;
                if (result < 0) {
                    result += 360;
                }
                return result - 180;
            };
            /**
            * Keeps an angle value between the given min and max values.
            * @method angleLimit
            * @param angle {number} The angle value to check. Must be between -180 and +180
            * @param min {number} The minimum angle that is allowed (must be -180 or greater)
            * @param max {number} The maximum angle that is allowed (must be 180 or less)
            * @return {number} The new angle value, returns the same as the input angle if it was within bounds
            * @static
            * @public
            */
            GameMath.angleLimit = function (angle, min, max) {
                var result = angle;
                if (angle > max) {
                    result = max;
                }
                else if (angle < min) {
                    result = min;
                }
                return result;
            };
            /**
            * Interpolates between neighbouring values in an array using linear interpolation only. For example, linearInterpolation( [ 1,5,4 ], 0.5 ) = 5, and linearInterpolation( [ 1, 2 ], 0.3 ) = 1.3.
            * @method linearInterpolation
            * @param v {Array} An array of values through which to interpolate
            * @param k {number} The position to interpolate, in the range 0-1
            * @return {number}
            * @static
            * @public
            */
            GameMath.linearInterpolation = function (v, k) {
                var m = v.length - 1;
                var f = m * k;
                var i = Math.floor(f);
                if (k < 0)
                    return Kiwi.Utils.GameMath.linear(v[0], v[1], f);
                if (k > 1)
                    return Kiwi.Utils.GameMath.linear(v[m], v[m - 1], m - f);
                return Kiwi.Utils.GameMath.linear(v[i], v[i + 1 > m ? m : i + 1], f - i);
            };
            /**
            * Interpolates between values in an array using Bezier curves. This treats the values in the array as control points on a spline. Unlike Catmull-Rom splines, the value is not guaranteed to intersect precisely with these points.
            * @method bezierInterpolation
            * @param v {Array} An array of values through which to interpolate
            * @param k {number} The position to interpolate, in the range 0-1
            * @return {number}
            * @static
            * @public
            */
            GameMath.bezierInterpolation = function (v, k) {
                var b = 0;
                var n = v.length - 1;
                for (var i = 0; i <= n; i++) {
                    b += Math.pow(1 - k, n - i) * Math.pow(k, i) * v[i] * Kiwi.Utils.GameMath.bernstein(n, i);
                }
                return b;
            };
            /**
            * Interpolates between values in an array using Catmull-Rom splines. This treats the values in the array as control points on a spline. Unlike Bezier curves, the value will intersect with every point in the array.
            * @method catmullRomInterpolation
            * @param v {Array} An array of values through which to interpolate
            * @param k {Number} The position to interpolate, in the range 0-1
            * @return {number}
            * @static
            * @public
            */
            GameMath.catmullRomInterpolation = function (v, k) {
                var m = v.length - 1;
                var f = m * k;
                var i = Math.floor(f);
                if (v[0] === v[m]) {
                    if (k < 0)
                        i = Math.floor(f = m * (1 + k));
                    return Kiwi.Utils.GameMath.catmullRom(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
                }
                else {
                    if (k < 0)
                        return v[0] - (Kiwi.Utils.GameMath.catmullRom(v[0], v[0], v[1], v[1], -f) - v[0]);
                    if (k > 1)
                        return v[m] - (Kiwi.Utils.GameMath.catmullRom(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
                    return Kiwi.Utils.GameMath.catmullRom(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
                }
            };
            /**
            * Simple linear interpolation, identical to interpolateFloat.
            * @method linear
            * @param {Any} p0
            * @param {Any} p1
            * @param {Any} t
            * @return {number}
            * @static
            * @public
            */
            GameMath.linear = function (p0, p1, t) {
                return (p1 - p0) * t + p0;
            };
            /**
            * Bernstein polynomial for constructing Bezier curves. Returns n! / i! / (n-i)!
            * @method bernstein
            * @param {Any} n
            * @param {Any} i
            * @return {number}
            * @static
            * @public
            */
            GameMath.bernstein = function (n, i) {
                return Kiwi.Utils.GameMath.factorial(n) / Kiwi.Utils.GameMath.factorial(i) / Kiwi.Utils.GameMath.factorial(n - i);
            };
            /**
            * Function used to construct a Catmull-Rom interpolation: see catmullRomInterpolation()
            * @method catmullRom
            * @param {Any} p0
            * @param {Any} p1
            * @param {Any} p2
            * @param {Any} p3
            * @param {Any} t
            * @return {number}
            * @static
            * @public
            */
            GameMath.catmullRom = function (p0, p1, p2, p3, t) {
                var v0 = (p2 - p0) * 0.5, v1 = (p3 - p1) * 0.5, t2 = t * t, t3 = t * t2;
                return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
            };
            /**
            * Returns the difference between a and b.
            * @method difference
            * @param a {number}
            * @param b {number}
            * @return {number}
            * @static
            * @public
            */
            GameMath.difference = function (a, b) {
                return Math.abs(a - b);
            };
            /**
            * Holds the value for PI. Only up to 16 significant figures.
            * @property PI
            * @type number
            * @default 3.141592653589793
            * @static
            * @final
            * @public
            */
            GameMath.PI = 3.141592653589793; //number pi
            /**
            * Holds the value for PI / 2 OR 90 degrees. Only up to 17 significant figures.
            * @property PI_2
            * @type number
            * @default 1.5707963267948965
            * @static
            * @final
            * @public
            */
            GameMath.PI_2 = 1.5707963267948965; //PI / 2 OR 90 deg
            /**
            * Holds the value for PI / 4 OR 45 degrees. Only up to 16 significant figures.
            * @property PI_4
            * @type number
            * @default 0.7853981633974483
            * @static
            * @final
            * @public
            */
            GameMath.PI_4 = 0.7853981633974483; //PI / 4 OR 45 deg
            /**
            * Holds the value for PI / 8 OR 22.5 degrees. Only up to 17 significant figures.
            * @property PI_8
            * @type number
            * @default 0.39269908169872413
            * @static
            * @final
            * @public
            */
            GameMath.PI_8 = 0.39269908169872413; //PI / 8 OR 22.5 deg
            /**
            * Holds the value for PI / 16 OR 11.25 degrees. Only up to 17 significant figures.
            * @property PI_16
            * @type number
            * @default 0.19634954084936206
            * @static
            * @final
            * @public
            */
            GameMath.PI_16 = 0.19634954084936206; //PI / 16 OR 11.25 deg
            /**
            * Holds the value for 2 * PI OR 180 degrees. Only up to 15 significant figures.
            * @property TWO_PI
            * @type number
            * @default 6.283185307179586
            * @static
            * @final
            * @public
            */
            GameMath.TWO_PI = 6.283185307179586; //2 * PI OR 180 deg
            /**
            * Holds the value for 3 * PI_2 OR 270 degrees. Only up to 17 significant figures.
            * @property THREE_PI_2
            * @type number
            * @default 4.7123889803846895
            * @static
            * @final
            * @public
            */
            GameMath.THREE_PI_2 = 4.7123889803846895; //3 * PI_2 OR 270 deg
            /**
            * Holds the value for "e": Euler's number or Napier's constant, to 15 significant figures. This is a mathematically useful number.
            * @property E
            * @type number
            * @default 2.71828182845905
            * @static
            * @final
            * @public
            */
            GameMath.E = 2.71828182845905; //number e
            /**
            * Holds the value for the natural logarithm of 10: ln(10). Accurate to 16 significant figures.
            * @property LN10
            * @type number
            * @default 2.302585092994046
            * @static
            * @final
            * @public
            */
            GameMath.LN10 = 2.302585092994046; //ln(10)
            /**
            * Holds the value for the natural logarithm of 2: ln(10). Accurate to 16 significant figures.
            * @property LN2
            * @type number
            * @default 0.6931471805599453
            * @static
            * @final
            * @public
            */
            GameMath.LN2 = 0.6931471805599453; //ln(2)
            /**
            * Holds the value for the base 10 logarithm of e (Euler's number). Accurate to 16 significant figures.
            * @property LOG10E
            * @type number
            * @default 0.4342944819032518
            * @static
            * @final
            * @public
            */
            GameMath.LOG10E = 0.4342944819032518; //logB10(e)
            /**
            * Holds the value for the base 2 logarithm of e (Euler's number). Accurate to 19 significant figures.
            * @property LOG2E
            * @type number
            * @default 1.442695040888963387
            * @static
            * @final
            * @public
            */
            GameMath.LOG2E = 1.442695040888963387; //logB2(e)
            /**
            * Holds the value for the square root of 0.5 (1/2). Accurate to 16 significant figures.
            * @property SQRT1_2
            * @type number
            * @default 0.7071067811865476
            * @static
            * @final
            * @public
            */
            GameMath.SQRT1_2 = 0.7071067811865476; //sqrt( 1 / 2 )
            /**
            * Holds the value for the square root of 2. Accurate to 17 significant figures. This is the diagonal distance across a square with side length of 1.
            * @property SQRT2
            * @type number
            * @default 1.4142135623730951
            * @static
            * @final
            * @public
            */
            GameMath.SQRT2 = 1.4142135623730951; //sqrt( 2 )
            /**
            * Holds the value for PI / 180 which is used to convert degrees to radians.
            * @property DEG_TO_RAD
            * @type  number
            * @default 0.017453292519943294444444444444444
            * @static
            * @final
            * @public
            */
            GameMath.DEG_TO_RAD = 0.017453292519943294444444444444444; //PI / 180;
            /**
            * Holds the value for 180 / PI which is used to convert radians to degrees.
            * @property RAD_TO_DEG
            * @type number
            * @default 57.295779513082325225835265587527
            * @static
            * @final
            * @public
            */
            GameMath.RAD_TO_DEG = 57.295779513082325225835265587527; // 180.0 / PI;
            /**
            * Holds the value for 2 to the power of 16 (2^16 = 65536). This is the number of values available in 2 bytes.
            * @property B_16
            * @type number
            * @default 65536
            * @static
            * @final
            * @public
            */
            GameMath.B_16 = 65536; //2^16
            /**
            * Holds the value for 2 to the power of 31 (2^31 = 2147483648). This is the number of values available to 31-bit memory addressing.
            * @property B_31
            * @type number
            * @default 2147483648
            * @static
            * @final
            * @public
            */
            GameMath.B_31 = 2147483648; //2^31
            /**
            * Holds the value for 2 to the power of 32 (2^32 = 4294967296). This is the number of values available in 4 bytes, such as certain forms of RGBA colour.
            * @property B_32
            * @type number
            * @default 4294967296
            * @static
            * @final
            * @public
            */
            GameMath.B_32 = 4294967296; //2^32
            /**
            * Holds the value for 2 to the power of 48 (2^48 = 281474976710656). 48-bit colour has 16 bits per channel.
            * @property B_48
            * @type number
            * @default 281474976710656
            * @static
            * @final
            * @public
            */
            GameMath.B_48 = 281474976710656; //2^48
            /**
            * Holds the value for 2 to the power of 53 (2^53 = 9007199254740992). This is the largest accurate double-precision floating point whole number.
            * @property B_53
            * @type number
            * @default 9007199254740992
            * @static
            * @final
            * @public
            */
            GameMath.B_53 = 9007199254740992; //2^53 !!NOTE!! largest accurate double floating point whole value
            /**
            * Holds the value for 2 to the power of 64 (2^64 = 18446744073709551616). This number cannot be accurately represented as a double-precision floating point whole number as it is greater than Kiwi.Utils.GameMath.B_53. It is represented as 18446744073709552000 in memory.
            * @property B_64
            * @type number
            * @default 18446744073709551616
            * @static
            * @final
            * @public
            */
            GameMath.B_64 = 18446744073709551616; //2^64 !!NOTE!! Not accurate see B_53
            /**
            * Holds the value for the fraction 1 / 3 as a number.
            * @property ONE_THIRD
            * @type number
            * @default 0.333333333333333333333333333333333
            * @static
            * @final
            * @public
            */
            GameMath.ONE_THIRD = 0.333333333333333333333333333333333; // 1.0/3.0;
            /**
            * Holds the value for the fraction 2 / 3 as a number.
            * @property TWO_THIRDS
            * @type number
            * @default 0.666666666666666666666666666666666
            * @static
            * @final
            * @public
            */
            GameMath.TWO_THIRDS = 0.666666666666666666666666666666666; // 2.0/3.0;
            /**
            * Holds the value for the fraction 1 / 6 as a number
            * @property ONE_SIXTH
            * @type number
            * @default 0.166666666666666666666666666666666
            * @static
            * @final
            * @public
            */
            GameMath.ONE_SIXTH = 0.166666666666666666666666666666666; // 1.0/6.0;
            /**
            * Holds the value of cos(pi / 3). This is the length of the shortest side of a triangle with angles in degrees 30, 60, and 90.
            * @property COS_PI_3
            * @type number
            * @default 0.86602540378443864676372317075294
            * @static
            * @final
            * @public
            */
            GameMath.COS_PI_3 = 0.86602540378443864676372317075294; //COS( PI / 3 )
            /**
            * Holds the value of sin(2 * pi / 3). This is the length of the second-shortest side of a triangle with andles in degrees 30, 60, and 90.
            * @property SIN_2PI_3
            * @type number
            * @default 0.03654595
            * @static
            * @final
            * @public
            */
            GameMath.SIN_2PI_3 = 0.03654595; // SIN( 2*PI/3 )
            /**
            * Holds the value for 4 * (Math.sqrt(2) - 1) / 3.0 (approximately 0.5522847).
            *
            * This is useful for making circular arcs with Bezier curves. For an arc segment of 90 degrees (PI / 2 radians) or less, you can construct a nice approximation using CIRCLE_ALPHA. If the magic number k = CIRCLE_ALPHA, construct an arc using the following points: [1,0], [1,k], [k,1], [0,1].
            *
            * For angles that are smaller by scale n, scale k by n, and displace k along tangents of the arc. For more information, see this article by Hans Muller: http://hansmuller-flex.blogspot.com/2011/04/approximating-circular-arc-with-cubic.html
            * @property CIRCLE_ALPHA
            * @type number
            * @default 0.5522847498307933984022516322796
            * @static
            * @final
            * @public
            */
            GameMath.CIRCLE_ALPHA = 0.5522847498307933984022516322796; //4*(Math.sqrt(2)-1)/3.0;
            /**
            * A boolean that is true.
            * @property ON
            * @type boolean
            * @default true
            * @static
            * @final
            * @public
            */
            GameMath.ON = true;
            /**
            * A boolean that is false.
            * @property OFF
            * @type boolean
            * @default false
            * @static
            * @final
            * @public
            */
            GameMath.OFF = false;
            /**
            * Maximum relative error for integers.
            * @property SHORT_EPSILON
            * @type number
            * @default 0.1
            * @static
            * @final
            * @public
            */
            GameMath.SHORT_EPSILON = 0.1; //round integer epsilon
            /**
            * Maximum relative error for percentages (where 1% == 0.01).
            * @property PERC_EPSILON
            * @type number
            * @default 0.001
            * @static
            * @final
            * @public
            */
            GameMath.PERC_EPSILON = 0.001; //percentage epsilon
            /**
            * Average relative error for single float values.
            * @property EPSILON
            * @type number
            * @default 0.0001
            * @static
            * @final
            * @public
            */
            GameMath.EPSILON = 0.0001; //single float average epsilon
            /**
            * Maximum relative error for 8-digit decimal values.
            * @property LONG_EPSILON
            * @type number
            * @default 0.00000001
            * @static
            * @final
            * @public
            */
            GameMath.LONG_EPSILON = 0.00000001; //arbitrary 8 digit epsilon
            return GameMath;
        })();
        Utils.GameMath = GameMath;
    })(Utils = Kiwi.Utils || (Kiwi.Utils = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Utils
*/
var Kiwi;
(function (Kiwi) {
    var Utils;
    (function (Utils) {
        /**
        * Manages the creation of unique internal game IDs.
        * Based on Nonsense by Josh Faul https://github.com/jocafa/Nonsense
        * Random number generator from http://baagoe.org/en/wiki/Better_random_numbers_for_javascript
        *
        * @class RandomDataGenerator
        * @constructor
        * @namespace Kiwi.Utils
        * @param [seeds=[]] {String[]}
        * @return {RandomDataGenerator}
        *
        * @author Josh Faul
        */
        var RandomDataGenerator = (function () {
            function RandomDataGenerator(seeds) {
                if (seeds === void 0) { seeds = []; }
                /**
                * [DESCRIPTION REQUIRED]
                * @property c
                * @type Number
                * @default 1
                * @private
                */
                this.c = 1;
                /**
                * Used to contain various arrays of data that can be used when randomly generating blocks of text.
                * @property _data
                * @type Object
                * @private
                */
                this._data = {
                    lipsum: [
                        "lorem", "ipsum", "dolor", "sit", "amet", "consectetur",
                        "adipiscing", "elit", "nunc", "sagittis", "tortor", "ac", "mi",
                        "pretium", "sed", "convallis", "massa", "pulvinar", "curabitur",
                        "non", "turpis", "velit", "vitae", "rutrum", "odio", "aliquam",
                        "sapien", "orci", "tempor", "sed", "elementum", "sit", "amet",
                        "tincidunt", "sed", "risus", "etiam", "nec", "lacus", "id", "ante",
                        "hendrerit", "malesuada", "donec", "porttitor", "magna", "eget",
                        "libero", "pharetra", "sollicitudin", "aliquam", "mattis", "mattis",
                        "massa", "et", "porta", "morbi", "vitae", "magna", "augue",
                        "vestibulum", "at", "lectus", "sed", "tellus", "facilisis",
                        "tincidunt", "suspendisse", "eros", "magna", "consequat", "at",
                        "sollicitudin", "ac", "vestibulum", "vel", "dolor", "in", "egestas",
                        "lacus", "quis", "lacus", "placerat", "et", "molestie", "ipsum",
                        "scelerisque", "nullam", "sit", "amet", "tortor", "dui", "aenean",
                        "pulvinar", "odio", "nec", "placerat", "fringilla", "neque", "dolor"
                    ]
                };
                this.sow(seeds);
            }
            /**
            * The type of object that this is.
            * @method objType
            * @return {String} "RandomDataGenerator"
            * @public
            */
            RandomDataGenerator.prototype.objType = function () {
                return "RandomDataGenerator";
            };
            /**
            * [DESCRIPTION REQUIRED]
            * @method uint32
            * @return {Any}
            * @private
            */
            RandomDataGenerator.prototype.uint32 = function () {
                return this.rnd.apply(this) * 0x100000000; // 2^32
            };
            /**
            * [DESCRIPTION REQUIRED]
            * @method fract32
            * @return {Any}
            * @private
            */
            RandomDataGenerator.prototype.fract32 = function () {
                return this.rnd.apply(this) + (this.rnd.apply(this) * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
            };
            // private random helper
            /**
            * [DESCRIPTION REQUIRED]
            * @method rnd
            * @return {Any}
            * @private
            */
            RandomDataGenerator.prototype.rnd = function () {
                var t = 2091639 * this.s0 + this.c * 2.3283064365386963e-10; // 2^-32
                this.c = t | 0;
                this.s0 = this.s1;
                this.s1 = this.s2;
                this.s2 = t - this.c;
                return this.s2;
            };
            /**
            * [DESCRIPTION REQUIRED]
            * @method hash
            * @param data {Any}
            * @private
            */
            RandomDataGenerator.prototype.hash = function (data) {
                var h, i, n;
                n = 0xefc8249d;
                data = data.toString();
                for (i = 0; i < data.length; i++) {
                    n += data.charCodeAt(i);
                    h = 0.02519603282416938 * n;
                    n = h >>> 0;
                    h -= n;
                    h *= n;
                    n = h >>> 0;
                    h -= n;
                    n += h * 0x100000000; // 2^32
                }
                return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
            };
            /**
            * Reset the seed of the random data generator
            * @method sow
            * @param [seeds=[]] {String[]}
            * @public
            */
            RandomDataGenerator.prototype.sow = function (seeds) {
                if (seeds === void 0) { seeds = []; }
                this.s0 = this.hash(' ');
                this.s1 = this.hash(this.s0);
                this.s2 = this.hash(this.s1);
                var seed;
                for (var i = 0; seed = seeds[i++];) {
                    this.s0 -= this.hash(seed);
                    this.s0 += ~~(this.s0 < 0);
                    this.s1 -= this.hash(seed);
                    this.s1 += ~~(this.s1 < 0);
                    this.s2 -= this.hash(seed);
                    this.s2 += ~~(this.s2 < 0);
                }
            };
            /**
            * Returns a random integer between 0 and 2^32
            * @method integer
            * @return {Number}
            * @public
            */
            RandomDataGenerator.prototype.integer = function () {
                return this.uint32();
            };
            /**
            * Returns a random real number between 0 and 1
            * @method frac
            * @return {Number}
            * @public
            */
            RandomDataGenerator.prototype.frac = function () {
                return this.fract32();
            };
            /**
            * Returns a random real number between 0 and 2^32
            * @method real
            * @return {Number}
            * @public
            */
            RandomDataGenerator.prototype.real = function () {
                return this.uint32() + this.fract32();
            };
            /**
            * Returns a random integer between min and max
            * @method integerInRange
            * @param min {Number}
            * @param max {Number}
            * @return {Number}
            * @public
            */
            RandomDataGenerator.prototype.integerInRange = function (min, max) {
                return Math.floor(this.realInRange(min, max));
            };
            /**
            * Returns a random real number between min and max
            * @method realInRange
            * @param min {Number}
            * @param max {Number}
            * @return {Number}
            * @public
            */
            RandomDataGenerator.prototype.realInRange = function (min, max) {
                min = min || 0;
                max = max || 0;
                return this.frac() * (max - min) + min;
            };
            /**
            * Returns a random real number between -1 and 1
            * @method normal
            * @return {Number}
            * @public
            */
            RandomDataGenerator.prototype.normal = function () {
                return 1 - 2 * this.frac();
            };
            /**
            * Returns a valid v4 UUID hex string (from https://gist.github.com/1308368)
            * @method uuid
            * @return {String}
            * @public
            */
            RandomDataGenerator.prototype.uuid = function () {
                var a, b;
                for (b = a = ''; a++ < 36; b += ~a % 5 | a * 3 & 4 ? (a ^ 15 ? 8 ^ this.frac() * (a ^ 20 ? 16 : 4) : 4).toString(16) : '-')
                    ;
                return b;
            };
            /**
            * Returns a random member of `array`
            * @method pick
            * @param {Any} array
            * @return {Any}
            * @public
            */
            RandomDataGenerator.prototype.pick = function (array) {
                return array[this.integerInRange(0, array.length)];
            };
            /**
            * Returns a random member of `array`, favoring the earlier entries
            * @method weightedPick
            * @param {Any} array
            * @return {Any}
            * @public
            */
            RandomDataGenerator.prototype.weightedPick = function (array) {
                return array[~~(Math.pow(this.frac(), 2) * array.length)];
            };
            /**
            * Returns a random word of lipsum
            * @method word
            * @return {String}
            * @public
            */
            RandomDataGenerator.prototype.word = function () {
                return this.pick(this._data.lipsum);
            };
            /**
            * Returns `n` random words of lipsum, 3 if not specified
            * @method words
            * @param {Number} [quantity=3] Amount of random words to get.
            * @return {String}
            * @public
            */
            RandomDataGenerator.prototype.words = function (quantity) {
                if (quantity === void 0) { quantity = 3; }
                var ret = [];
                for (var i = 0; i < quantity; i++) {
                    ret.push(this.pick(this._data.lipsum));
                }
                return ret.join(' ');
            };
            /**
            * Returns a random lipsum sentence
            * @method sentence
            * @return {String}
            * @public
            */
            RandomDataGenerator.prototype.sentence = function () {
                var ret;
                ret = this.words(this.integerInRange(2, 16)).replace(/[a-z]/, function (m) {
                    return m.toUpperCase();
                });
                return ret + '.';
            };
            /**
            * Returns `n` random lipsum sentences, 3 if not specified
            * @method sentences
            * @param {Number} [quantity=3] The number of sentences to grab.
            * @return {String}
            * @public
            */
            RandomDataGenerator.prototype.sentences = function (quantity) {
                if (quantity === void 0) { quantity = 3; }
                var ret = [];
                for (var i = 0; i < quantity; i++) {
                    ret.push(this.sentence());
                }
                return ret.join(' ');
            };
            /**
            * Returns a random timestamp between min and max, or between the beginning of 2000 and the end of 2020 if min and max aren't specified
            * @method timestamp
            * @param [min=946684800000] {Number} The lowest timestamp.
            * @param [max=1577862000000] {Number} The highest timestamp.
            * @return {Number}
            * @public
            */
            RandomDataGenerator.prototype.timestamp = function (min, max) {
                if (min === void 0) { min = 946684800000; }
                if (max === void 0) { max = 1577862000000; }
                return this.realInRange(min, max);
            };
            /**
            * Returns a random angle between -180 and 180
            * @method angle
            * @return {Number}
            * @public
            */
            RandomDataGenerator.prototype.angle = function () {
                return this.integerInRange(-180, 180);
            };
            return RandomDataGenerator;
        })();
        Utils.RandomDataGenerator = RandomDataGenerator;
    })(Utils = Kiwi.Utils || (Kiwi.Utils = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Utils
*/
var Kiwi;
(function (Kiwi) {
    var Utils;
    (function (Utils) {
        /**
        * Abstracts away the use of RAF or setTimeout for the core game update loop. The callback can be re-mapped on the fly.
        *
        * @class RequestAnimationFrame
        * @constructor
        * @namespace Kiwi.Utils
        * @param callback {Any}
        * @return {RequestAnimationFrame} This object.
        *
        */
        var RequestAnimationFrame = (function () {
            function RequestAnimationFrame(callback) {
                /**
                * A boolean indicating whether or not we are using setTimeout for the RequestAnimationFrame or not.
                * @property _isSetTimeOut
                * @type boolean
                * @default false
                * @private
                */
                this._isSetTimeOut = false;
                /**
                * The last time at which the RAF was called. This is given a value at the end of the RAF loop.
                * @property lastTime
                * @type Number
                * @public
                */
                this.lastTime = 0;
                /**
                * A timestamp that has the current time. This is updated each time the RAF loop is executed. Is updated before the last time in the loop.
                * @property currentTime
                * @type Number
                * @public
                */
                this.currentTime = 0;
                /**
                * A boolean indicating whether or not the RAF is running.
                * @property isRunning
                * @type boolean
                * @default false
                * @public
                */
                this.isRunning = false;
                /**
                * ID of the RAF, used to stop the RAF
                * @property _rafId
                * @type ???
                * @default null
                * @private
                */
                this._rafId = null;
                this._callback = callback;
                var vendors = ['ms', 'moz', 'webkit', 'o'];
                for (var x = 0; x < vendors.length && !window.requestAnimationFrame; x++) {
                    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
                    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'];
                }
            }
            /**
            * The type of obect that this is.
            * @method objType
            * @return {String} "RequestAnimationFrame"
            * @public
            */
            RequestAnimationFrame.prototype.objType = function () {
                return "RequestAnimationFrame";
            };
            /**
            * Sets the callback method that is to be executed each time the RAF is.
            * @method setCallback
            * @param {Any} callback
            * @public
            */
            RequestAnimationFrame.prototype.setCallback = function (callback) {
                this._callback = callback;
            };
            /**
            * Returns a boolean indicating whether or not setTimeout is being used instead of RAF.
            * @method usingSetTimeOut
            * @return {boolean}
            * @public
            */
            RequestAnimationFrame.prototype.isUsingSetTimeOut = function () {
                return this._isSetTimeOut;
            };
            /**
            * Returns a boolean indicating wheather or not we are using the RAF. If false it means we are using setTimeout for our update loop.
            * @method usingRAF
            * @return {boolean}
            * @public
            */
            RequestAnimationFrame.prototype.isUsingRAF = function () {
                if (this._isSetTimeOut === true) {
                    return false;
                }
                else {
                    return true;
                }
            };
            /**
            * Starts the RequestAnimationFrame (or setTimeout if RAF not supported).
            * @method start
            * @param [callback] {Any} A callback to be executed everyframe. Overrides the callback set at instantiation if passed.
            * @public
            */
            RequestAnimationFrame.prototype.start = function (callback) {
                var _this = this;
                if (callback === void 0) { callback = null; }
                if (callback) {
                    this._callback = callback;
                }
                if (!window.requestAnimationFrame) {
                    this._isSetTimeOut = true;
                    this._timeOutID = window.setTimeout(function () { return _this.SetTimeoutUpdate(); }, 0);
                }
                else {
                    this._isSetTimeOut = false;
                    this._rafId =
                        window.requestAnimationFrame(function () { return _this.RAFUpdate(); });
                }
                this.isRunning = true;
            };
            /**
            * Stops the RAF from running.
            * @method stop
            * @public
            */
            RequestAnimationFrame.prototype.stop = function () {
                if (this._isSetTimeOut) {
                    clearTimeout(this._timeOutID);
                }
                else {
                    window.cancelAnimationFrame(this._rafId);
                }
                this.isRunning = false;
            };
            /**
            * The update loop that the RAF will continuously call.
            * @method RAFUpdate
            * @public
            */
            RequestAnimationFrame.prototype.RAFUpdate = function () {
                var _this = this;
                //  Not in IE8 (but neither is RAF) also doesn't use a high performance timer (window.performance.now)
                this.currentTime = Date.now();
                if (this._callback) {
                    this._callback();
                }
                var timeToCall = Math.max(0, 16 - (this.currentTime - this.lastTime));
                this._rafId = window.requestAnimationFrame(function () { return _this.RAFUpdate(); });
                this.lastTime = this.currentTime + timeToCall;
            };
            /**
            * The update loop that the setTimeout method will continuously call.
            * @method SetTimeoutUpdate
            * @public
            */
            RequestAnimationFrame.prototype.SetTimeoutUpdate = function () {
                var _this = this;
                //  Not in IE8
                this.currentTime = Date.now();
                if (this._callback) {
                    this._callback();
                }
                var timeToCall = Math.max(0, 16 - (this.currentTime - this.lastTime));
                this._timeOutID = window.setTimeout(function () { return _this.SetTimeoutUpdate(); }, timeToCall);
                this.lastTime = this.currentTime + timeToCall;
            };
            return RequestAnimationFrame;
        })();
        Utils.RequestAnimationFrame = RequestAnimationFrame;
    })(Utils = Kiwi.Utils || (Kiwi.Utils = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Utils.
*
*/
var Kiwi;
(function (Kiwi) {
    var Utils;
    (function (Utils) {
        /**
        * A utilty class used to add management functionality to common console methods.
        * You can use this class by either creating a new instance, or using the instance at the namespace 'Kiwi.Log'.
        *
        * log/error/warn methods contained on this class function just like their 'console' equivalents except that:
        * - You can assign a tag to message by adding a '#' symbol to the front of a parameter. Example: this.log('Hi', '#welcome');
        * - Messages can have multiple tags. Example: this.log('Hi', '#welcome', '#greeting');
        * - Messages are recorded (by default) and you can then search through any messages saved.
        *
        * You can use the 'show' commands to search through recordings and find specific messages.
        *
        *
        * @class Log
        * @namespace Kiwi.Utils
        * @constructor
        * @param [params] {Object}
        *   @param [options.recording=true] {Boolean} If the logs should be recorded.
        *   @param [options.display=true] {Boolean} If the logs should be displayed or not.
        *   @param [options.enabled=true] {Boolean} If the Logger is enabled at all.
        *   @param [options.maxRecordings=Infinity] {Number} The maximum number of recordings to have at a single time.
        */
        var Log = (function () {
            function Log(params) {
                if (params === void 0) { params = {}; }
                /**
                * If the log, warn, or error messages should function at all.
                * When set to false messages won't display or be recorded.
                *
                * @property enabled
                * @type Boolean
                * @default true
                * @public
                */
                this.enabled = true;
                /**
                * If messages should be recorded or not.
                *
                * @property record
                * @type Boolean
                * @default true
                * @public
                */
                this.recording = true;
                /**
                * If the log, warn, and error methods should display when executed or not.
                * You may want to set this to 'false' when releasing a game.
                *
                * @property display
                * @type Boolean
                * @default true
                * @public
                */
                this.display = true;
                /**
                * A list of tags which any message recorded needs to match in-order to be displayed.
                * This helps when debugging systems with lots of messages, without removing every log.
                *
                * @property tagFilters
                * @type Array
                * @since 1.3.0
                * @public
                */
                this.tagFilters = [];
                /**
                * The maximum number of recordings to be kept at once.
                *
                * @property maxRecordings
                * @type Number
                * @default Infinity
                * @public
                */
                this.maxRecordings = Infinity;
                /**
                * A list containing all messages recorded.
                *
                * @property recordings
                * @type Array
                * @private
                */
                this.recordings = [];
                this.setDefaultsFromParams(params);
            }
            /**
            * Sets the log properties based on a object passed.
            * This method is used to set the properties on the Log based on
            * gameoptions passed at game creation.
            *
            * @method setDefaultsFromParams
            * @param [params] {Object}
            *   @param [options.recording=true] {Boolean} If the logs should be recorded.
            *   @param [options.display=true] {Boolean} If the logs should be displayed or not.
            *   @param [options.enabled=true] {Boolean} If the Logger is enabled at all.
            *   @param [options.maxRecordings=Infinity] {Number} The maximum number of recordings to have at a single time.
            * @public
            */
            Log.prototype.setDefaultsFromParams = function (params) {
                if (params === void 0) { params = {}; }
                if (!Kiwi.Utils.Common.isUndefined(params.enabled)) {
                    this.enabled = params.enabled;
                }
                if (!Kiwi.Utils.Common.isUndefined(params.recording)) {
                    this.recording = params.recording;
                }
                if (!Kiwi.Utils.Common.isUndefined(params.display)) {
                    this.display = params.display;
                }
                if (!Kiwi.Utils.Common.isUndefined(params.maxRecordings)) {
                    this.maxRecordings = params.maxRecordings;
                }
                if (Kiwi.Utils.Common.isArray(params.tagFilters)) {
                    this.tagFilters = params.tagFilters;
                }
            };
            Object.defineProperty(Log.prototype, "lastMessageTime", {
                /**
                * The time (in milliseconds) of the last recording.
                *
                * @property lastMessageTime
                * @type Number
                * @readOnly
                * @public
                */
                get: function () {
                    if (this.recordings.length > 0) {
                        return this.recordings[this.recordings.length - 1].time;
                    }
                    return 0;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Log.prototype, "numRecordings", {
                /**
                * The number of recordings that have been saved.
                * Same as the recordings length, and won't go above the 'maxRecordings'.
                *
                * @property numRecordings
                * @type Number
                * @readOnly
                * @public
                */
                get: function () {
                    return this.recordings.length;
                },
                enumerable: true,
                configurable: true
            });
            /**
            * Saves a message to the 'recordings' array.
            * That message can then be retrieved later using the 'show' methods.
            *
            * @method recordMessage
            * @param message {String}
            * @param [tags=[]] {String}
            * @param [logMethod=console.log] {String}
            * @public
            */
            Log.prototype.record = function (messages, tags, logMethod) {
                if (tags === void 0) { tags = []; }
                if (logMethod === void 0) { logMethod = console.log; }
                if (this.recording) {
                    var recording = {
                        messages: messages,
                        time: Date.now(),
                        tags: tags,
                        logMethod: logMethod
                    };
                    if (this.recordings.push(recording) > this.maxRecordings) {
                        this.recordings.shift();
                    }
                }
            };
            /**
            * Removes recordings from the list. Goes from the oldest to newest.
            * By not passing any parameters, the entire log will be cleared.
            *
            * @method clearRecordings
            * @param [start=0] {Number}
            * @param [end] {Number}
            * @public
            */
            Log.prototype.clearRecordings = function (start, end) {
                if (start === void 0) { start = 0; }
                if (end === void 0) { end = this.recordings.length; }
                this.recordings.splice(start, end);
            };
            /**
            * Executes a particular array of messages using a method passed.
            * Takes into account the 'display' property before executing.
            *
            * @method _execute
            * @param method {Any} The method that should be used to log the messages. Generally a console method.
            * @param context {Any} The context that the method should be executed in. Generally set to the console.
            * @param messages {Array}
            * @param [force=false] {Array}
            * @private
            */
            Log.prototype._execute = function (method, context, messages, force) {
                if (force === void 0) { force = false; }
                if (this.display || force) {
                    method.apply(context, messages);
                }
            };
            /**
            * Accepts an array of strings and returns a new array consisting of all elements considered as a tag.
            *
            * @method getTagsFromArray
            * @param strings {Array}
            * @return {Array} Elements of the array considered as tags
            * @public
            */
            Log.prototype.getTagsFromArray = function (array) {
                var i = 0, tags = [];
                while (i < array.length) {
                    if (typeof array[i] === "string") {
                        if (array[i].charAt(0) === "#") {
                            tags.push(array[i]);
                        }
                    }
                    i++;
                }
                return tags;
            };
            /**
            * Returns true if the all of the tags passed also occur in the tag filters.
            * This is used to filter out messages by their tags.
            *
            * @method _filterTags
            * @param tags {Array} A list of tags, which need to occur in the tag filters
            * @param [tagFilters=this.tagFilters] {Array} A list of tags. Tags need to
            * @return {Boolean} Tags match the tag filters, and so if the message would be allowed to execute.
            * @since 1.3.0
            * @private
            */
            Log.prototype._filterTags = function (tags, tagFilters) {
                if (tagFilters === void 0) { tagFilters = this.tagFilters; }
                //No filters, then allow
                if (tagFilters.length === 0) {
                    return true;
                }
                if (tags.length == 0) {
                    return false;
                }
                var i = 0;
                while (i < tags.length) {
                    //If the tag does not appear in the filter list 
                    if (tagFilters.indexOf(tags[i]) === -1) {
                        return false;
                    }
                    i++;
                }
                return true;
            };
            /**
            * Logs a message using the 'console.log' method.
            * Arguments starting with a '#' symbol are given that value as a tag.
            *
            * @method log
            * @param [..args] {Any} The data you would like to log.
            * @public
            */
            Log.prototype.log = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                if (!this.enabled) {
                    return;
                }
                var tags = this.getTagsFromArray(args);
                this.record(args, tags, console.log);
                if (this._filterTags(tags)) {
                    this._execute(console.log, console, args);
                }
            };
            /**
            * Logs a message using the 'console.warn' method.
            * Arguments starting with a '#' symbol are given that value as a tag.
            *
            * @method warn
            * @param [..args] {Any} The data you would like to log.
            * @public
            */
            Log.prototype.warn = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                if (!this.enabled) {
                    return;
                }
                var tags = this.getTagsFromArray(args);
                this.record(args, tags, console.warn);
                if (this._filterTags(tags)) {
                    this._execute(console.warn, console, args);
                }
            };
            /**
            * Logs a message using the 'console.error' method.
            * Arguments starting with a '#' symbol are given that value as a tag.
            *
            * @method error
            * @param [..args] {Any} The data you would like to log.
            * @public
            */
            Log.prototype.error = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                if (!this.enabled) {
                    return;
                }
                var tags = this.getTagsFromArray(args);
                this.record(args, tags, console.error);
                if (this._filterTags(tags)) {
                    this._execute(console.error, console, args);
                }
            };
            /**
            * Method that displays a particular recording passed.
            *
            * @method _show
            * @param recording {Object}
            * @param tags {Array}
            * @return {Boolean} If the recording was displayed or not.
            * @private
            */
            Log.prototype._show = function (recording, tags) {
                if (!recording.logMethod) {
                    return false;
                }
                //Check that the tags match
                var n = tags.length;
                while (n--) {
                    if (recording.tags.indexOf(tags[n]) == -1) {
                        return false;
                    }
                }
                this._execute(recording.logMethod, console, recording.messages, true);
                return true;
            };
            /**
            * Displays the last recording matching the tags passed.
            * Ignores the tag filters.
            *
            * @method showLast
            * @param [...args] {Any} Any tags that the recordings must have.
            * @public
            */
            Log.prototype.showLast = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                var i = this.recordings.length;
                while (i--) {
                    if (this._show(this.recordings[i], args)) {
                        return;
                    }
                }
            };
            /**
            * Displays all recordings.
            * Ignores the tag filters.
            *
            * @method showAll
            * @param [...args] {Any} Any tags that the recordings must have.
            * @public
            */
            Log.prototype.showAll = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                for (var i = 0; i < this.recordings.length; i++) {
                    this._show(this.recordings[i], args);
                }
            };
            /**
            * Displays all logs recorded.
            * Ignores the tag filters.
            *
            * @method showLogs
            * @param [...args] {Any} Any tags that the recordings must have.
            * @public
            */
            Log.prototype.showLogs = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                for (var i = 0; i < this.recordings.length; i++) {
                    if (this.recordings[i].logMethod === console.log) {
                        this._show(this.recordings[i], args);
                    }
                }
            };
            /**
            * Displays all errors recorded.
            * Ignores the tag filters.
            *
            * @method showErrors
            * @param [...args] {Any} Any tags that the recordings must have.
            * @public
            */
            Log.prototype.showErrors = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                for (var i = 0; i < this.recordings.length; i++) {
                    if (this.recordings[i].logMethod === console.error) {
                        this._show(this.recordings[i], args);
                    }
                }
            };
            /**
            * Displays all warnings recorded.
            * Ignores the tag filters.
            *
            * @method showWarnings
            * @param [...args] {Any} Any tags that the recordings must have.
            * @public
            */
            Log.prototype.showWarnings = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                for (var i = 0; i < this.recordings.length; i++) {
                    if (this.recordings[i].logMethod === console.warn) {
                        this._show(this.recordings[i], args);
                    }
                }
            };
            /**
            * Displays a series of recordings within a time period passed.
            * Time recorded is in milliseconds.
            * Ignores the tag filters.
            *
            * @method showTimePeriod
            * @param [start=0] {Number}
            * @param [end=Infinity] {Number}
            * @param [tags] {Array} An tags that the recordings must have.
            * @public
            */
            Log.prototype.showTimePeriod = function (start, end, tags) {
                if (start === void 0) { start = 0; }
                if (end === void 0) { end = Infinity; }
                if (tags === void 0) { tags = []; }
                var recording;
                for (var i = 0; i < this.recordings.length; i++) {
                    recording = this.recordings[i];
                    if (start < recording.time && end > recording.time) {
                        this._show(recording, tags);
                    }
                }
            };
            /**
            * Adds a tag to the list of tag filters.
            * Any messages that do not have the tags in the tagFilters list will not be displayed.
            *
            * @method addFilter
            * @param [...args] {Any} Tags to add to the filters list.
            * @since 1.3.0
            * @public
            */
            Log.prototype.addFilter = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                this.tagFilters = this.tagFilters.concat(args);
            };
            /**
            * Removes a tag to the list of tag filters.
            * Any messages that do not have the tags in the tagFilters list will not be displayed.
            *
            * @method removeFilter
            * @param [...args] {Any} Tags to be remove from the filters list.
            * @since 1.3.0
            * @public
            */
            Log.prototype.removeFilter = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                var i = 0, index;
                while (i < args.length) {
                    index = this.tagFilters.indexOf(args[i]);
                    if (index !== -1) {
                        this.tagFilters.splice(index, 1);
                    }
                    i++;
                }
            };
            return Log;
        })();
        Utils.Log = Log;
    })(Utils = Kiwi.Utils || (Kiwi.Utils = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Utils
*/
var Kiwi;
(function (Kiwi) {
    var Utils;
    (function (Utils) {
        /**
        * Deals with parsing and comparing semver style version numbers
        * @class Version
        * @constructor
        * @namespace Kiwi.Utils
        */
        var Version = (function () {
            function Version() {
            }
            /**
            * Parses a string such as "1.2.3" and returns an oject containing numeric properties for majorVersion, minorVersion and patchVersion
            * @method parseVersion
            * @param version {String}
            * @return {Object} Object with properties majorVersion, minorVersion, patchVersion.
            * @public
            * @static
            */
            Version.parseVersion = function (version) {
                var split = version.split(".");
                return {
                    majorVersion: parseInt(split[0]),
                    minorVersion: parseInt(split[1]),
                    patchVersion: parseInt(split[2])
                };
            };
            /**
            * Compares two semver version strings such as "0.1.0" and "0.2.1".
            * Returns "greater", "less" or "equal".
            * @method compareVersions
            * @param version1 {String}
            * @param version2 {String}
            * @return {String} "greater", "less" or "equal"
            * @public
            * @static
            */
            Version.compareVersions = function (version1, version2) {
                var v1 = Version.parseVersion(version1);
                var v2 = Version.parseVersion(version2);
                if (v1.majorVersion > v2.majorVersion) {
                    return "greater";
                }
                if (v1.majorVersion < v2.majorVersion) {
                    return "less";
                }
                // major versions must be equal
                if (v1.minorVersion > v2.minorVersion) {
                    return "greater";
                }
                if (v1.minorVersion < v2.minorVersion) {
                    return "less";
                }
                //minor versions must be equal
                if (v1.patchVersion > v2.patchVersion) {
                    return "greater";
                }
                if (v1.patchVersion < v2.patchVersion) {
                    return "less";
                }
                //patch versions must be equal
                return "equal";
            };
            /**
            * Compares two semver version strings such as "0.1.0" and "0.2.1". Returns true if version1 is greater than version2.
            * @method greaterOrEqual
            * @param version1 {String}
            * @param version2 {String}
            * @return {boolean}
            * @public
            * @static
            */
            Version.greaterOrEqual = function (version1, version2) {
                var comp = Version.compareVersions(version1, version2);
                return (comp == "greater" || comp == "equal");
            };
            return Version;
        })();
        Utils.Version = Version;
    })(Utils = Kiwi.Utils || (Kiwi.Utils = {}));
})(Kiwi || (Kiwi = {}));
/// <reference path="core/Game.ts" />
/// <reference path="core/Stage.ts" />
/// <reference path="core/ComponentManager.ts" />
/// <reference path="core/PluginManager.ts" />
/// <reference path="core/CameraManager.ts" />
/// <reference path="core/StateConfig.ts" />
/// <reference path="core/StateManager.ts" />
/// <reference path="core/IChild.ts" />
/// <reference path="core/Entity.ts" />
/// <reference path="core/Component.ts" />
/// <reference path="core/Group.ts" />
/// <reference path="core/State.ts" /> //must be initialised AFTER group - typescript issue #599
/// <reference path="core/Camera.ts" />
/// <reference path="core/Signal.ts" />
/// <reference path="core/SignalBinding.ts" />
/// <reference path="gameobjects/Sprite.ts" />
/// <reference path="gameobjects/StaticImage.ts" />
/// <reference path="gameobjects/TextField.ts" />
/// <reference path="gameobjects/tilemap/TileType.ts" />
/// <reference path="gameobjects/tilemap/TileMap.ts" />
/// <reference path="gameobjects/tilemap/TileMapLayer.ts" />
/// <reference path="gameobjects/tilemap/TileMapLayerOrthogonal.ts" />
/// <reference path="gameobjects/tilemap/TileMapLayerIsometric.ts" />
/// <reference path="components/AnimationManager.ts" />
/// <reference path="components/Box.ts" />
/// <reference path="components/Input.ts" />
/// <reference path="components/Sound.ts" />
/// <reference path="components/ArcadePhysics.ts" />
/// <reference path="file/Loader.ts" />
/// <reference path="file/DataLibrary.ts" />
/// <reference path="file/File.ts" />
/// <reference path="file/FileStore.ts" />
/// <reference path="system/Bootstrap.ts" />
/// <reference path="system/Device.ts" />
/// <reference path="textures/TextureAtlas.ts" />
/// <reference path="textures/TextureLibrary.ts" />
/// <reference path="textures/SpriteSheet.ts" />
/// <reference path="textures/SingleImage.ts" />
/// <reference path="animations/tweens/easing/Back.ts" />
/// <reference path="animations/tweens/easing/Bounce.ts" />
/// <reference path="animations/tweens/easing/Circular.ts" />
/// <reference path="animations/tweens/easing/Cubic.ts" />
/// <reference path="animations/tweens/easing/Elastic.ts" />
/// <reference path="animations/tweens/easing/Exponential.ts" />
/// <reference path="animations/tweens/easing/Linear.ts" />
/// <reference path="animations/tweens/easing/Quadratic.ts" />
/// <reference path="animations/tweens/easing/Quartic.ts" />
/// <reference path="animations/tweens/easing/Quintic.ts" />
/// <reference path="animations/tweens/easing/Sinusoidal.ts" />
/// <reference path="animations/tweens/TweenManager.ts" />
/// <reference path="animations/tweens/Tween.ts" />
/// <reference path="render/CanvasRenderer.ts" />
/// <reference path="render/GLRenderManager.ts" />
/// <reference path="render/GLShaderManager.ts" />
/// <reference path="render/GLTextureWrapper.ts" />
/// <reference path="render/GLTextureManager.ts" />
/// <reference path="render/GLArrayBuffer.ts" />
/// <reference path="render/GLBlendMode.ts" />
/// <reference path="render/GLElementArrayBuffer.ts" />
/// <reference path="render/renderers/Renderer.ts" />
/// <reference path="render/renderers/TextureAtlasRenderer.ts" />
/// <reference path="render/shaders/ShaderPair.ts" />
/// <reference path="render/shaders/TextureAtlasShader.ts" />
/// <reference path="render/shaders/ShaderPair.ts" />
/// <reference path="animations/Animation.ts" />
/// <reference path="animations/Sequence.ts" />
/// <reference path="input/Key.ts" />
/// <reference path="input/Keyboard.ts" />
/// <reference path="input/Keycodes.ts" />
/// <reference path="input/InputManager.ts" />
/// <reference path="input/Mouse.ts" />
/// <reference path="input/Touch.ts" />
/// <reference path="input/Pointer.ts" />
/// <reference path="input/MouseCursor.ts" />
/// <reference path="input/Finger.ts" />
/// <reference path="geom/AABB.ts" />
/// <reference path="geom/Circle.ts" />
/// <reference path="geom/Line.ts" />
/// <reference path="geom/Ray.ts" />
/// <reference path="geom/Intersect.ts" />
/// <reference path="geom/IntersectResult.ts" />
/// <reference path="geom/Matrix.ts" />
/// <reference path="geom/Point.ts" />
/// <reference path="geom/Rectangle.ts" />
/// <reference path="geom/Transform.ts" />
/// <reference path="geom/Vector2.ts" />
/// <reference path="hud/HUDDisplay.ts" />
/// <reference path="hud/HUDManager.ts" />
/// <reference path="hud/HUDWidget.ts" />
/// <reference path="hud/widgets/TextField.ts" />
/// <reference path="hud/widgets/Bar.ts" />
/// <reference path="hud/widgets/Icon.ts" />
/// <reference path="hud/widgets/IconBar.ts" />
/// <reference path="hud/widgets/BasicScore.ts" />
/// <reference path="hud/widgets/Button.ts" />
/// <reference path="hud/widgets/Time.ts" />
/// <reference path="hud/widgets/Menu.ts" />
/// <reference path="hud/widgets/MenuItem.ts" />
/// <reference path="hud/components/Counter.ts" />
/// <reference path="hud/components/WidgetInput.ts" />
/// <reference path="hud/components/Time.ts" />
/// <reference path="sound/AudioManager.ts" />
/// <reference path="sound/Audio.ts" />
/// <reference path="sound/AudioLibrary.ts" />
/// <reference path="time/Clock.ts" />
/// <reference path="time/ClockManager.ts" />
/// <reference path="time/MasterClock.ts" />
/// <reference path="time/Timer.ts" />
/// <reference path="time/TimerEvent.ts" />
/// <reference path="utils/Canvas.ts" />
/// <reference path="utils/Color.ts" />
/// <reference path="utils/Common.ts" />
/// <reference path="utils/GameMath.ts" />
/// <reference path="utils/RandomDataGenerator.ts" />
/// <reference path="utils/RequestAnimationFrame.ts" />
/// <reference path="utils/Log.ts" />
/// <reference path="utils/Version.ts" />
/**
* Module - Kiwi (Core)
* The top level namespace in which all core classes and modules are defined.
* @module Kiwi
* @main Kiwi
*/
var Kiwi;
(function (Kiwi) {
    /**
    *
    * @property Log
    * @static
    * @type Kiwi.Utils.Log
    * @public
    */
    Kiwi.Log = new Kiwi.Utils.Log();
    /**
    * The version of Kiwi that is currently being used.
    * @property VERSION
    * @static
    * @type string
    * @public
    */
    Kiwi.VERSION = "1.4.0";
    //DIFFERENT RENDERER STATIC VARIABLES
    /**
    * A Static property that contains the number associated with the CANVAS RENDERER.
    * @property RENDERER_CANVAS
    * @static
    * @type number
    * @default 0
    * @public
    */
    Kiwi.RENDERER_CANVAS = 0;
    /**
    * A Static property that contains the number associated with the WEBGL RENDERER.
    * @property RENDERER_WEBGL
    * @static
    * @type number
    * @default 1
    * @public
    */
    Kiwi.RENDERER_WEBGL = 1;
    /**
    * A Static property that contains the number associated with RENDERER AUTODETECTION
    * @property RENDERER_AUTO
    * @static
    * @type number
    * @default 2
    * @public
    * @since 1.1.0
    */
    Kiwi.RENDERER_AUTO = 2;
    // DEVICE TARGET STATIC VARIABLES
    /**
    * Contains the number associated with the targetting of browsers.
    * @property TARGET_BROWSER
    * @static
    * @type number
    * @default 0
    * @public
    */
    Kiwi.TARGET_BROWSER = 0;
    /**
    * Contains the number associated with the targetting of CocoonJS.
    * @property TARGET_COCOON
    * @static
    * @type number
    * @default 1
    * @public
    */
    Kiwi.TARGET_COCOON = 1;
    //DEBUG OPTION STATIC VARIABLES
    /**
    * Contains the number that is used to turn the Debug options on.
    * @property DEBUG_ON
    * @static
    * @type number
    * @default 0
    * @public
    */
    Kiwi.DEBUG_ON = 0;
    /**
    * Contains the number that is used to turn the Debug options off.
    * @property DEBUG_OFF
    * @static
    * @type number
    * @default 1
    * @public
    */
    Kiwi.DEBUG_OFF = 1;
    /**
    * Contains the Device class that is used to determine which features are supported by the users browser.
    * @property DEVICE
    * @static
    * @type Device
    * @public
    */
    Kiwi.DEVICE = null;
    //STATIC PROPERTIES FOR GENERAL OBJECT TYPE DETECTION
    /**
    * Contains a number that is used to identify objects that are a State.
    * @property STATE
    * @static
    * @type number
    * @default 0
    * @public
    */
    Kiwi.STATE = 0;
    /**
    * Contains a number that is used to identify objects that are a Group.
    * @property GROUP
    * @static
    * @type number
    * @default 2
    * @public
    */
    Kiwi.GROUP = 2;
    /**
    * Contains a number that is used to identify objects that are a Entity.
    * @property ENTITY
    * @static
    * @type number
    * @default 3
    * @public
    */
    Kiwi.ENTITY = 3;
    /**
    * Contains a number that is used to identify objects that are a Camera.
    * @property CAMERA
    * @static
    * @type number
    * @default 4
    * @public
    */
    Kiwi.CAMERA = 4;
    /**
    * Contains a number that is used to identify objects that are a HUD Widget.
    * @property HUD_WIDGET
    * @static
    * @type number
    * @default 5
    * @public
    */
    Kiwi.HUD_WIDGET = 5;
    /**
    * Contains a number that is used to identify objects that are a TILE_LAYER.
    * @property TILE_LAYER
    * @static
    * @type number
    * @default 6
    * @public
    */
    Kiwi.TILE_LAYER = 6;
    /**
    * The GameManager is used to maintain mulitple instances of Kiwi games within a single document.
    *
    * @class GameManager
    * @namespace Kiwi
    * @static
    */
    var GameManager = (function () {
        function GameManager() {
        }
        /**
        * The type of object that this is.
        * @method objType
        * @return {String} "GameManager"
        * @public
        */
        GameManager.prototype.objType = function () {
            return "GameManager";
        };
        /**
        * Used to register a new Game with this manager. Returns the new number of games that have been registered.
        * @method register
        * @param game {Game} The game you are wanting to register.
        * @return {Number] The new number of games registered.
        * @public
        */
        GameManager.register = function (game) {
            return Kiwi.GameManager._games.push(game);
        };
        /**
        * Returns the total number of game that are currently registered with this GameManager.
        * @method total
        * @return {Number} Total number of registered games.
        * @public
        */
        GameManager.total = function () {
            return Kiwi.GameManager._games.length;
        };
        /**
        * A list of all of the games that are currently on this document.
        * @property _games
        * @static
        * @type Game[]
        * @private
        */
        GameManager._games = [];
        return GameManager;
    })();
    Kiwi.GameManager = GameManager;
    var Plugins;
    (function (Plugins) {
        null;
    })(Plugins = Kiwi.Plugins || (Kiwi.Plugins = {}));
    ;
    Kiwi.extend = function (d, b) {
        for (var p in b)
            if (b.hasOwnProperty(p))
                d[p] = b[p];
        function __() { this.constructor = d; }
        __.prototype = b.prototype;
        d.prototype = new __();
    };
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Files
*
*/
var Kiwi;
(function (Kiwi) {
    var Files;
    (function (Files) {
        /**
        * AudioFile which contains settings, loading, and processing details for Audio files to be used.
        *
        * Uses tag loading for devices not supporting the WebAudioAPI. Otherwise XHR + arraybuffer loading methods are used.
        *
        * @class AudioFile
        * @namespace Kiwi.Files
        * @extends Kiwi.Files.File
        * @since 1.2.0
        * @constructor
        * @param game {Kiwi.Game} The game that this file is for
        * @param params {Object} Options for this file.
        *   @param params.key {String} User defined name for this file. This would be how the user would access it in the file store.
        *   @param params.url {String} Location of the file to be loaded.
        *   @param {Object} [params.metadata={}] Any metadata to be associated with the file.
        *   @param [params.state=null] {Kiwi.State} The state that this file belongs to. Used for defining global assets vs local assets.
        *   @param [params.fileStore=null] {Kiwi.Files.FileStore} The filestore that this file should be save in automatically when loaded.
        *   @param [params.type=UNKNOWN] {Number} The type of file this is.
        *   @param [params.tags] {Array} Any tags to be associated with this file.
        * @return {Kiwi.Files.AudioFile}
        */
        var AudioFile = (function (_super) {
            __extends(AudioFile, _super);
            function AudioFile(game, params) {
                //Add support detection here...
                if (params === void 0) { params = {}; }
                _super.call(this, game, params);
                //this.dataType === File.AUDIO
                /**
                * For tag loading only. The crossOrigin value applied to loaded images. Very often this needs to be set to 'anonymous'
                * @property crossOrigin
                * @type String
                * @default ''
                * @public
                */
                this.crossOrigin = '';
                if (this.game.audio.usingAudioTag) {
                    this.useTagLoader = true;
                    this._loadInParallel = true;
                }
                else {
                    this.useTagLoader = false;
                }
                if (!Kiwi.Utils.Common.isUndefined(params.crossOrigin)) {
                    this.crossOrigin = params.crossOrigin;
                }
            }
            /**
            * Returns the type of this object
            * @method objType
            * @return {String} "AudioFile"
            * @public
            */
            AudioFile.prototype.objType = function () {
                return "AudioFile";
            };
            /**
            * Initialises a loading method depending on detected device support.
            * @method _load
            * @protected
            */
            AudioFile.prototype._load = function () {
                this.attemptCounter++;
                if (this.useTagLoader) {
                    this.tagLoader();
                }
                else {
                    this.xhrLoader('GET', 'arraybuffer');
                }
            };
            /**
            * Handles loading audio in via an audio tag.
            * @method tagLoader
            * @public
            */
            AudioFile.prototype.tagLoader = function () {
                this.data = document.createElement('audio');
                this.data.src = this.URL;
                this.data.preload = 'auto';
                if (this.crossOrigin) {
                    this.data.crossOrigin = this.crossOrigin;
                }
                if (this.game.audio.locked) {
                    //Nothing else to do...
                    this.loadSuccess();
                }
                else {
                    var _this = this;
                    var func = function (event) {
                        _this.data.removeEventListener('canplaythrough', func, false);
                        _this.data.pause();
                        _this.data.currentTime = 0;
                        _this.data.volume = 1;
                        _this.loadSuccess();
                    };
                    this.data.addEventListener('canplaythrough', func, false);
                    if (this.game.deviceTargetOption == Kiwi.TARGET_COCOON) {
                        //If targetting Cocoon we can use the load method to force the audio loading.
                        this.data.load();
                    }
                    else {
                        //Otherwise we tell the browser to play the audio in 'mute' to force loading. 
                        this.data.volume = 0;
                        this.data.play();
                    }
                }
            };
            /**
            * Handles decoding the arraybuffer into audio data.
            * @method processXhr
            * @param response
            * @protected
            */
            AudioFile.prototype.processXhr = function (response) {
                this.data = {
                    raw: response,
                    decoded: false,
                    buffer: null
                };
                this._decodeAudio();
            };
            /**
            * Attempts to decode the audio data loaded via XHR + arraybuffer.
            *
            * @method _decodeAudio
            * @private
            */
            AudioFile.prototype._decodeAudio = function () {
                var _this = this;
                this.game.audio.context.decodeAudioData(this.data.raw, function (buffer) {
                    if (buffer) {
                        _this.data.buffer = buffer;
                        _this.data.decoded = true;
                        _this.loadSuccess();
                    }
                }, function (error) {
                    Kiwi.Log.error('Kiwi.Files.AudioFile: Error decoding audio data.', '#loading', '#decoding');
                    _this.loadError(error);
                });
            };
            return AudioFile;
        })(Kiwi.Files.File);
        Files.AudioFile = AudioFile;
    })(Files = Kiwi.Files || (Kiwi.Files = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Files
*
*/
var Kiwi;
(function (Kiwi) {
    var Files;
    (function (Files) {
        /**
        * DataFile which contains settings, loading, and processing details for Data files to be used.
        * There is no tag loader support for this method of loading.
        *
        * @class DataFile
        * @namespace Kiwi.Files
        * @extends Kiwi.Files.File
        * @since 1.2.0
        * @constructor
        * @param game {Kiwi.Game} The game that this file is for
        * @param params {Object} Options for this file.
        *   @param params.key {String} User defined name for this file. This would be how the user would access it in the file store.
        *   @param params.url {String} Location of the file to be loaded.
        *   @param {Object} [params.metadata={}] Any metadata to be associated with the file.
        *   @param [params.state=null] {Kiwi.State} The state that this file belongs to. Used for defining global assets vs local assets.
        *   @param [params.fileStore=null] {Kiwi.Files.FileStore} The filestore that this file should be save in automatically when loaded.
        *   @param [params.type=UNKNOWN] {Number} The type of file this is.
        *   @param [params.tags] {Array} Any tags to be associated with this file.
        *   @param [params.parse] {Boolean} If the response should be parsed after the file is loaded. Only used with JSON and XML types of Data files.
        * @return {Kiwi.Files.DataFile}
        *
        */
        var DataFile = (function (_super) {
            __extends(DataFile, _super);
            function DataFile(game, params) {
                if (params === void 0) { params = {}; }
                _super.call(this, game, params);
                this.useTagLoader = false;
                this._loadInParallel = false;
            }
            /**
            * Sets properties for this instance based on an object literal passed. Used when the class is being created.
            *
            * @method parseParams
            * @param [params] {Object}
            *   @param [params.metadata={}] {Object} Any metadata to be associated with the file.
            *   @param [params.state=null] {Kiwi.State} The state that this file belongs to. Used for defining global assets vs local assets.
            *   @param [params.fileStore=null] {Kiwi.Files.FileStore} The filestore that this file should be save in automatically when loaded.
            *   @param [params.type=UNKNOWN] {Number} The type of file this is.
            *   @param [params.tags] {Array} Any tags to be associated with this file.
            *   @param [params.parse] {Boolean} If the response should be parsed after the file is loaded.
            * @protected
            */
            DataFile.prototype.parseParams = function (params) {
                _super.prototype.parseParams.call(this, params);
                if (!Kiwi.Utils.Common.isUndefined(params.parse)) {
                    this.parse = params.parse;
                }
                else {
                    this.parse = false;
                }
            };
            //this.dataType === File.XML || this.dataType === File.JSON || this.dataType === File.TEXT_DATA || this.dataType === File.BINARY_DATA
            /**
            * Returns the type of this object
            * @method objType
            * @return {String} "DataFile"
            * @public
            */
            DataFile.prototype.objType = function () {
                return "DataFile";
            };
            /**
            * Increments the counter, and calls the approprate loading method.
            * @method _load
            * @protected
            */
            DataFile.prototype._load = function () {
                this.attemptCounter++;
                //Special check for binary data. Change the loading type
                if (this.dataType === Kiwi.Files.File.BINARY_DATA) {
                    this.xhrLoader('GET', 'arraybuffer');
                }
                else {
                    this.xhrLoader('GET', 'text');
                }
            };
            /**
            * Handles decoding the arraybuffer into audio data.
            * @method processXhr
            * @param response
            * @protected
            */
            DataFile.prototype.processXhr = function (response) {
                if (!this.parse) {
                    this.data = response;
                    this.loadSuccess();
                    return;
                }
                switch (this.dataType) {
                    case Kiwi.Files.File.JSON:
                        this.processJSON(response);
                        break;
                    case Kiwi.Files.File.XML:
                        this.parseXML(response);
                        break;
                    case Kiwi.Files.File.TEXT_DATA:
                    case Kiwi.Files.File.BINARY_DATA:
                    default:
                        this.data = response;
                        break;
                }
            };
            /**
            * Attempts to parse a string which is assumed to be XML. Called when 'parse' is set to true.
            * If valid 'loadSuccess' is called, otherwise 'loadError' is executed
            *
            * @method parseXML
            * @param data {String}
            * @private
            */
            DataFile.prototype.parseXML = function (data) {
                Kiwi.Log.log('Kiwi.Files.DataFile: Data loaded is being parsed as XML.', '#loading', '#parsing');
                if (window['DOMParser']) {
                    var parser = new DOMParser();
                    this.data = parser.parseFromString(data, "text/xml");
                }
                else {
                    this.data = new ActiveXObject("Microsoft.XMLDOM");
                    this.data.async = "false";
                    this.data.loadXML(data);
                }
                if (!this.data || !this.data.documentElement || this.data.getElementsByTagName("parsererror").length) {
                    this.loadError('XML parse error.');
                }
                else {
                    this.loadSuccess();
                }
            };
            /**
            * Attempts to parse a string which is assumed to be JSON. Called when 'parse' is set to true.
            * If valid 'loadSuccess' is called, otherwise 'loadError' is executed
            *
            * @method processJSON
            * @param data {String}
            * @private
            */
            DataFile.prototype.processJSON = function (data) {
                Kiwi.Log.log('Kiwi.Files.DataFile: Data loaded is being parsed as JSON.', '#loading', '#parsing');
                try {
                    this.data = JSON.parse(data);
                }
                catch (e) {
                    this.loadError(e);
                    return;
                }
                this.loadSuccess();
            };
            return DataFile;
        })(Kiwi.Files.File);
        Files.DataFile = DataFile;
    })(Files = Kiwi.Files || (Kiwi.Files = {}));
})(Kiwi || (Kiwi = {}));
/**
*
* @module Kiwi
* @submodule Files
*
*/
var Kiwi;
(function (Kiwi) {
    var Files;
    (function (Files) {
        /**
        * TextureFile which contains settings, loading, and processing information for textures/images in Kiwi.
        *
        * Contains two methods of loading. XHR + arraybuffer and also tag loading.
        *
        * @class TextureFile
        * @namespace Kiwi.Files
        * @extends Kiwi.Files.File
        * @since 1.2.0
        * @constructor
        * @param game {Kiwi.Game} The game that this file is for
        * @param params {Object} Options for this file.
        *   @param params.key {String} User defined name for this file. This would be how the user would access it in the file store.
        *   @param params.url {String} Location of the file to be loaded.
        *   @param {Object} [params.metadata={}] Any metadata to be associated with the file.
        *   @param [params.state=null] {Kiwi.State} The state that this file belongs to. Used for defining global assets vs local assets.
        *   @param [params.fileStore=null] {Kiwi.Files.FileStore} The filestore that this file should be save in automatically when loaded.
        *   @param [params.type=UNKNOWN] {Number} The type of file this is.
        *   @param [params.tags] {Array} Any tags to be associated with this file.
        *   @param [params.xhrLoading=false] {Boolean} If xhr + arraybuffer loading should be used instead of tag loading.
        * @return {Kiwi.Files.TextureFile}
        *
        */
        var TextureFile = (function (_super) {
            __extends(TextureFile, _super);
            function TextureFile(game, params) {
                if (params === void 0) { params = {}; }
                _super.call(this, game, params);
                /**
                * For tag loading only. The crossOrigin value applied to loaded images. Very often this needs to be set to 'anonymous'
                * @property crossOrigin
                * @type String
                * @default ''
                * @public
                */
                this.crossOrigin = '';
                if (params.xhrLoading) {
                    this.useTagLoader = false;
                    this._loadInParallel = false;
                }
                else {
                    this.useTagLoader = true;
                    this._loadInParallel = true;
                }
                if (!Kiwi.Utils.Common.isUndefined(params.crossOrigin)) {
                    this.crossOrigin = params.crossOrigin;
                }
            }
            /**
            * Returns the type of this object
            * @method objType
            * @return {String} "TextureFile"
            * @public
            */
            TextureFile.prototype.objType = function () {
                return "TextureFile";
            };
            //this.dataType === File.IMAGE || this.dataType === File.SPRITE_SHEET || this.dataType === File.TEXTURE_ATLAS
            /**
            * Initialises the loading method.
            * Tagloading is the default but also supports XHR + arraybuffer.
            * @method _load
            * @protected
            */
            TextureFile.prototype._load = function () {
                this.attemptCounter++;
                if (this.useTagLoader) {
                    this.tagLoader();
                }
                else {
                    this.xhrLoader('GET', 'arraybuffer');
                }
            };
            /**
            * Contains the functionality for tag loading
            * @method tagLoader
            * @private
            */
            TextureFile.prototype.tagLoader = function () {
                var _this = this;
                this.data = new Image();
                this.data.src = this.URL;
                if (this.crossOrigin) {
                    this.data.crossOrigin = this.crossOrigin;
                }
                this.data.onload = function () { return _this.loadSuccess(); };
                this.data.onerror = function (event) { return _this.loadError(event); };
            };
            /**
            * Gets the response data (which is an arraybuffer), creates a Blob from it
            * and creates an objectURL from it.
            *
            * @method processXhr
            * @param response {Any} The data stored in the 'xhr.response' tag
            * @protected
            */
            TextureFile.prototype.processXhr = function (response) {
                //Careful, Blobs are not supported on CocoonJS Canvas+
                this.data = document.createElement('img');
                var blob = new Blob([response], { type: this.type });
                var that = this;
                this.data.addEventListener('load', function (event) {
                    that.loadSuccess();
                });
                if (window['URL']) {
                    this.data.src = window['URL'].createObjectURL(blob);
                }
                else if (window['webkitURL']) {
                    this.data.src = window['webkitURL'].createObjectURL(blob);
                }
            };
            /**
            * Revokes the object url that was added to the window when creating the image.
            * Also tells the File that the loading is now complete.
            *
            * @method revoke
            * @private
            */
            TextureFile.prototype.revoke = function () {
                if (window['URL']) {
                    window['URL'].revokeObjectURL(this.data.src);
                }
                else if (window['webkitURL']) {
                    window['webkitURL'].revokeObjectURL(this.data.src);
                }
            };
            /**
            * Destroys all external object references on this object.
            * @method destroy
            * @since 1.2.0
            * @public
            */
            TextureFile.prototype.destroy = function () {
                if (!this.useTagLoader) {
                    this.revoke();
                }
                _super.prototype.destroy.call(this);
            };
            return TextureFile;
        })(Kiwi.Files.File);
        Files.TextureFile = TextureFile;
    })(Files = Kiwi.Files || (Kiwi.Files = {}));
})(Kiwi || (Kiwi = {}));
