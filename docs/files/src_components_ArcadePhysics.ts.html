<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/components/ArcadePhysics.ts - Kiwi.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Kiwi.js"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.1.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Kiwi.Animations.Animation.html">Kiwi.Animations.Animation</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Sequence.html">Kiwi.Animations.Sequence</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tween.html">Kiwi.Animations.Tween</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Back.html">Kiwi.Animations.Tweens.Easing.Back</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Bounce.html">Kiwi.Animations.Tweens.Easing.Bounce</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Circular.html">Kiwi.Animations.Tweens.Easing.Circular</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Cubic.html">Kiwi.Animations.Tweens.Easing.Cubic</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Elastic.html">Kiwi.Animations.Tweens.Easing.Elastic</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Exponential.html">Kiwi.Animations.Tweens.Easing.Exponential</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Linear.html">Kiwi.Animations.Tweens.Easing.Linear</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Quadratic.html">Kiwi.Animations.Tweens.Easing.Quadratic</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Quartic.html">Kiwi.Animations.Tweens.Easing.Quartic</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Quintic.html">Kiwi.Animations.Tweens.Easing.Quintic</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Sinusoidal.html">Kiwi.Animations.Tweens.Easing.Sinusoidal</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.TweenManager.html">Kiwi.Animations.Tweens.TweenManager</a></li>
            
                <li><a href="../classes/Kiwi.Camera.html">Kiwi.Camera</a></li>
            
                <li><a href="../classes/Kiwi.CameraManager.html">Kiwi.CameraManager</a></li>
            
                <li><a href="../classes/Kiwi.Component.html">Kiwi.Component</a></li>
            
                <li><a href="../classes/Kiwi.ComponentManager.html">Kiwi.ComponentManager</a></li>
            
                <li><a href="../classes/Kiwi.Components.AnimationManager.html">Kiwi.Components.AnimationManager</a></li>
            
                <li><a href="../classes/Kiwi.Components.ArcadePhysics.html">Kiwi.Components.ArcadePhysics</a></li>
            
                <li><a href="../classes/Kiwi.Components.Box.html">Kiwi.Components.Box</a></li>
            
                <li><a href="../classes/Kiwi.Components.Input.html">Kiwi.Components.Input</a></li>
            
                <li><a href="../classes/Kiwi.Components.Sound.html">Kiwi.Components.Sound</a></li>
            
                <li><a href="../classes/Kiwi.Entity.html">Kiwi.Entity</a></li>
            
                <li><a href="../classes/Kiwi.Files.DataLibrary.html">Kiwi.Files.DataLibrary</a></li>
            
                <li><a href="../classes/Kiwi.Files.File.html">Kiwi.Files.File</a></li>
            
                <li><a href="../classes/Kiwi.Files.FileStore.html">Kiwi.Files.FileStore</a></li>
            
                <li><a href="../classes/Kiwi.Files.Loader.html">Kiwi.Files.Loader</a></li>
            
                <li><a href="../classes/Kiwi.Game.html">Kiwi.Game</a></li>
            
                <li><a href="../classes/Kiwi.GameManager.html">Kiwi.GameManager</a></li>
            
                <li><a href="../classes/Kiwi.GameObjects.Sprite.html">Kiwi.GameObjects.Sprite</a></li>
            
                <li><a href="../classes/Kiwi.GameObjects.StaticImage.html">Kiwi.GameObjects.StaticImage</a></li>
            
                <li><a href="../classes/Kiwi.GameObjects.Textfield.html">Kiwi.GameObjects.Textfield</a></li>
            
                <li><a href="../classes/Kiwi.GameObjects.Tilemap.TileMap.html">Kiwi.GameObjects.Tilemap.TileMap</a></li>
            
                <li><a href="../classes/Kiwi.GameObjects.Tilemap.TileMapLayer.html">Kiwi.GameObjects.Tilemap.TileMapLayer</a></li>
            
                <li><a href="../classes/Kiwi.GameObjects.Tilemap.TileType.html">Kiwi.GameObjects.Tilemap.TileType</a></li>
            
                <li><a href="../classes/Kiwi.Geom.AABB.html">Kiwi.Geom.AABB</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Circle.html">Kiwi.Geom.Circle</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Intersect.html">Kiwi.Geom.Intersect</a></li>
            
                <li><a href="../classes/Kiwi.Geom.IntersectResult.html">Kiwi.Geom.IntersectResult</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Line.html">Kiwi.Geom.Line</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Matrix.html">Kiwi.Geom.Matrix</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Point.html">Kiwi.Geom.Point</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Ray.html">Kiwi.Geom.Ray</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Rectangle.html">Kiwi.Geom.Rectangle</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Transform.html">Kiwi.Geom.Transform</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Vector2.html">Kiwi.Geom.Vector2</a></li>
            
                <li><a href="../classes/Kiwi.Group.html">Kiwi.Group</a></li>
            
                <li><a href="../classes/Kiwi.HUD.HUDComponents.Counter.html">Kiwi.HUD.HUDComponents.Counter</a></li>
            
                <li><a href="../classes/Kiwi.HUD.HUDComponents.Time.html">Kiwi.HUD.HUDComponents.Time</a></li>
            
                <li><a href="../classes/Kiwi.HUD.HUDComponents.WidgetInput.html">Kiwi.HUD.HUDComponents.WidgetInput</a></li>
            
                <li><a href="../classes/Kiwi.HUD.HUDDisplay.html">Kiwi.HUD.HUDDisplay</a></li>
            
                <li><a href="../classes/Kiwi.HUD.HUDManager.html">Kiwi.HUD.HUDManager</a></li>
            
                <li><a href="../classes/Kiwi.HUD.HUDWidget.html">Kiwi.HUD.HUDWidget</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.Bar.html">Kiwi.HUD.Widget.Bar</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.BasicScore.html">Kiwi.HUD.Widget.BasicScore</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.Button.html">Kiwi.HUD.Widget.Button</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.Icon.html">Kiwi.HUD.Widget.Icon</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.IconBar.html">Kiwi.HUD.Widget.IconBar</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.Menu.html">Kiwi.HUD.Widget.Menu</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.MenuItem.html">Kiwi.HUD.Widget.MenuItem</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.TextField.html">Kiwi.HUD.Widget.TextField</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.Time.html">Kiwi.HUD.Widget.Time</a></li>
            
                <li><a href="../classes/Kiwi.IChild.html">Kiwi.IChild</a></li>
            
                <li><a href="../classes/Kiwi.Input.Finger.html">Kiwi.Input.Finger</a></li>
            
                <li><a href="../classes/Kiwi.Input.InputManager.html">Kiwi.Input.InputManager</a></li>
            
                <li><a href="../classes/Kiwi.Input.Key.html">Kiwi.Input.Key</a></li>
            
                <li><a href="../classes/Kiwi.Input.Keyboard.html">Kiwi.Input.Keyboard</a></li>
            
                <li><a href="../classes/Kiwi.Input.Keycodes.html">Kiwi.Input.Keycodes</a></li>
            
                <li><a href="../classes/Kiwi.Input.Mouse.html">Kiwi.Input.Mouse</a></li>
            
                <li><a href="../classes/Kiwi.Input.MouseCursor.html">Kiwi.Input.MouseCursor</a></li>
            
                <li><a href="../classes/Kiwi.Input.Pointer.html">Kiwi.Input.Pointer</a></li>
            
                <li><a href="../classes/Kiwi.Input.Touch.html">Kiwi.Input.Touch</a></li>
            
                <li><a href="../classes/Kiwi.PluginManager.html">Kiwi.PluginManager</a></li>
            
                <li><a href="../classes/Kiwi.Renderers.CanvasRenderer.html">Kiwi.Renderers.CanvasRenderer</a></li>
            
                <li><a href="../classes/Kiwi.Renderers.GLArrayBuffer.html">Kiwi.Renderers.GLArrayBuffer</a></li>
            
                <li><a href="../classes/Kiwi.Renderers.GLBlendMode.html">Kiwi.Renderers.GLBlendMode</a></li>
            
                <li><a href="../classes/Kiwi.Renderers.GLElementArrayBuffer.html">Kiwi.Renderers.GLElementArrayBuffer</a></li>
            
                <li><a href="../classes/Kiwi.Renderers.GLRenderManager.html">Kiwi.Renderers.GLRenderManager</a></li>
            
                <li><a href="../classes/Kiwi.Renderers.GLTextureManager.html">Kiwi.Renderers.GLTextureManager</a></li>
            
                <li><a href="../classes/Kiwi.Renderers.GLTextureWrapper.html">Kiwi.Renderers.GLTextureWrapper</a></li>
            
                <li><a href="../classes/Kiwi.Renderers.Renderer.html">Kiwi.Renderers.Renderer</a></li>
            
                <li><a href="../classes/Kiwi.Renderers.TextureAtlasRenderer.html">Kiwi.Renderers.TextureAtlasRenderer</a></li>
            
                <li><a href="../classes/Kiwi.Shaders.ShaderManager.html">Kiwi.Shaders.ShaderManager</a></li>
            
                <li><a href="../classes/Kiwi.Shaders.ShaderPair.html">Kiwi.Shaders.ShaderPair</a></li>
            
                <li><a href="../classes/Kiwi.Shaders.TextureAtlasShader.html">Kiwi.Shaders.TextureAtlasShader</a></li>
            
                <li><a href="../classes/Kiwi.Signal.html">Kiwi.Signal</a></li>
            
                <li><a href="../classes/Kiwi.SignalBinding.html">Kiwi.SignalBinding</a></li>
            
                <li><a href="../classes/Kiwi.Sound.Audio.html">Kiwi.Sound.Audio</a></li>
            
                <li><a href="../classes/Kiwi.Sound.AudioLibrary.html">Kiwi.Sound.AudioLibrary</a></li>
            
                <li><a href="../classes/Kiwi.Sound.AudioManager.html">Kiwi.Sound.AudioManager</a></li>
            
                <li><a href="../classes/Kiwi.Stage.html">Kiwi.Stage</a></li>
            
                <li><a href="../classes/Kiwi.State.html">Kiwi.State</a></li>
            
                <li><a href="../classes/Kiwi.StateConfig.html">Kiwi.StateConfig</a></li>
            
                <li><a href="../classes/Kiwi.StateManager.html">Kiwi.StateManager</a></li>
            
                <li><a href="../classes/Kiwi.System.Bootstrap.html">Kiwi.System.Bootstrap</a></li>
            
                <li><a href="../classes/Kiwi.System.Device.html">Kiwi.System.Device</a></li>
            
                <li><a href="../classes/Kiwi.Textures.SingleImage.html">Kiwi.Textures.SingleImage</a></li>
            
                <li><a href="../classes/Kiwi.Textures.SpriteSheet.html">Kiwi.Textures.SpriteSheet</a></li>
            
                <li><a href="../classes/Kiwi.Textures.TextureAtlas.html">Kiwi.Textures.TextureAtlas</a></li>
            
                <li><a href="../classes/Kiwi.Textures.TextureLibrary.html">Kiwi.Textures.TextureLibrary</a></li>
            
                <li><a href="../classes/Kiwi.Time.Clock.html">Kiwi.Time.Clock</a></li>
            
                <li><a href="../classes/Kiwi.Time.ClockManager.html">Kiwi.Time.ClockManager</a></li>
            
                <li><a href="../classes/Kiwi.Time.MasterClock.html">Kiwi.Time.MasterClock</a></li>
            
                <li><a href="../classes/Kiwi.Time.Timer.html">Kiwi.Time.Timer</a></li>
            
                <li><a href="../classes/Kiwi.Time.TimerEvent.html">Kiwi.Time.TimerEvent</a></li>
            
                <li><a href="../classes/Kiwi.Utils.Canvas.html">Kiwi.Utils.Canvas</a></li>
            
                <li><a href="../classes/Kiwi.Utils.Common.html">Kiwi.Utils.Common</a></li>
            
                <li><a href="../classes/Kiwi.Utils.GameMath.html">Kiwi.Utils.GameMath</a></li>
            
                <li><a href="../classes/Kiwi.Utils.RandomDataGenerator.html">Kiwi.Utils.RandomDataGenerator</a></li>
            
                <li><a href="../classes/Kiwi.Utils.RequestAnimationFrame.html">Kiwi.Utils.RequestAnimationFrame</a></li>
            
                <li><a href="../classes/Kiwi.Utils.Version.html">Kiwi.Utils.Version</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/Animations.html">Animations</a></li>
            
                <li><a href="../modules/Components.html">Components</a></li>
            
                <li><a href="../modules/Easing.html">Easing</a></li>
            
                <li><a href="../modules/Files.html">Files</a></li>
            
                <li><a href="../modules/GameObjects.html">GameObjects</a></li>
            
                <li><a href="../modules/Geom.html">Geom</a></li>
            
                <li><a href="../modules/HUD.html">HUD</a></li>
            
                <li><a href="../modules/HUDComponents.html">HUDComponents</a></li>
            
                <li><a href="../modules/Input.html">Input</a></li>
            
                <li><a href="../modules/Kiwi.html">Kiwi</a></li>
            
                <li><a href="../modules/Renderers.html">Renderers</a></li>
            
                <li><a href="../modules/Shaders.html">Shaders</a></li>
            
                <li><a href="../modules/Sound.html">Sound</a></li>
            
                <li><a href="../modules/System.html">System</a></li>
            
                <li><a href="../modules/Textures.html">Textures</a></li>
            
                <li><a href="../modules/Tilemap.html">Tilemap</a></li>
            
                <li><a href="../modules/Time.html">Time</a></li>
            
                <li><a href="../modules/Tweens.html">Tweens</a></li>
            
                <li><a href="../modules/Utils.html">Utils</a></li>
            
                <li><a href="../modules/Widget.html">Widget</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/components/ArcadePhysics.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
* 
* @module Kiwi
* @submodule Components 
* 
*/ 

module Kiwi.Components {
     
    /**
    * Arcade Physics is an Optional Component that can be used when you are wanting to do basic physics collisions. 
    * These have been ported from Flixel, so most function operate identically to the original flixel functions, though some
    * have been split into multiple functions. Generally where functions originally accepted
    * either groups or gameobjects within the same argument, the ported functions one or the other.
    * http://www.flixel.org/
    * http://www.adamatomic.com/
    *
    * @class ArcadePhysics
    * @constructor
    * @namespace Kiwi.Components
    * @param entity {Kiwi.Entity} The Entity that this ArcadePhysics should be used on.
    * @param box {Kiwi.Components.Box} The box component that holds the hitbox that should be used when resolving and calculating collisions.
    * @return {Kiwi.Components.ArcadePhysics}
    * @extends Kiwi.Component
    *
    * @author Adam &#x27;Atomic&#x27; Saltsman, Flixel
    *
    */
    export class ArcadePhysics extends Kiwi.Component {

        constructor(entity:Kiwi.Entity, box?: Kiwi.Components.Box) {
            super(entity,&#x27;ArcadePhysics&#x27;);

            this.parent = entity;
            this.box = box;
            this.transform = this.parent.transform;

            this.last = new Kiwi.Geom.Point(this.transform.worldX, this.transform.worldY);
            this.mass = 1.0;
            this.elasticity = 0.0;

            this.immovable = false;
            this.moves = true;

            this.touching = ArcadePhysics.NONE;
            this.wasTouching = ArcadePhysics.NONE;
            this.allowCollisions = ArcadePhysics.ANY;

            this.velocity = new Kiwi.Geom.Point();
            this.acceleration = new Kiwi.Geom.Point();
            this.drag = new Kiwi.Geom.Point();
            this.maxVelocity = new Kiwi.Geom.Point(10000, 10000);

            this.angularVelocity = 0;
            this.angularAcceleration = 0;
            this.angularDrag = 0;
            this.maxAngular = 10000;
        }


        /**
        * The transform component of the entity that the ArcadePhysics is a part of.
        * @property transform
        * @type Kiwi.Geom.Transform
        * @public
        */
        public transform: Kiwi.Geom.Transform;


        /**
        * The bounding box component that the collisions are going to be based off.
        * You can modify the &#x27;hitbox&#x27; of that component to modify the collision area.
        *
        * @property box
        * @type Kiwi.Components.Box
        * @public
        */
        public box: Kiwi.Components.Box;


        /**
		* Whether an object will move/alter position after a collision.
        * @property immovable
        * @type boolean
        * @public
		*/
        public immovable: boolean;


        /**
        * The basic speed of this object.
        * You can modify the values contained inside this Object to change the speed.
        *
        * @property velocity
        * @type Kiwi.Geom.Point
        * @public
        */
        public velocity: Kiwi.Geom.Point;


        /**
		* The virtual mass of the object. Default value is 1.
		* Currently only used with &lt;code&gt;elasticity&lt;/code&gt; during collision resolution.
		* Change at your own risk; effects seem crazy unpredictable so far!
        * @property mass
        * @type number
        * @public
		*/
        public mass: number;
        

        /**
        * The bounciness of this object.  Only affects collisions.  Default value is 0, or &quot;not bouncy at all.&quot;
        * @property elasticity
        * @type number
        * @public
        */
        public elasticity: number;


        /**
        * How fast the speed of this object is changing.
        * Useful for smooth movement and gravity.
        *
        * @property acceleration
        * @type Kiwi.Geom.Point
        * @public
        */
        public acceleration: Kiwi.Geom.Point;


        /**
        * This isn&#x27;t drag exactly, more like deceleration that is only applied
        * when acceleration is not affecting the sprite.
        * @property drag
        * @type Kiwi.Geom.Point
        * @public
        */
        public drag: Kiwi.Geom.Point;


        /**
        * If you are using &lt;code&gt;acceleration&lt;/code&gt;, you can use &lt;code&gt;maxVelocity&lt;/code&gt; with it
        * to cap the speed automatically (very useful!).
        * @property maxVelocity
        * @type Kiwi.Geom.Point
        * @public
        */
        public maxVelocity: Kiwi.Geom.Point;


        /**
		* This is how fast you want this sprite to spin.
		* @property angularVelocity
        * @type number
        * @public
        */
        public angularVelocity: number;
        

        /**
		* How fast the spin speed should change.
        * @property angularAcceleration
        * @type number
        * @public
		*/
        public angularAcceleration: number;
        

        /**
		* Like &lt;code&gt;drag&lt;/code&gt; but for spinning.
        * @property angularDrag
        * @type number
        * @public
		*/
        public angularDrag: number;
        

        /**
        * Use in conjunction with &lt;code&gt;angularAcceleration&lt;/code&gt; for fluid spin speed control.
        * @property maxAngular
        * @type number
        * @public
        */
        public maxAngular: number;


        /**
        * If the Entity that this component is a part of &#x27;moves&#x27; or not, and thus if the physics should update the motion should update each frame.
        * @property moves
        * @type boolean
        * @default true
        * @public
        */
        public moves: boolean;


        /**
        * Bit field of flags (use with UP, DOWN, LEFT, RIGHT, etc) indicating surface contacts.
        * Use bitwise operators to check the values stored here, or use touching(), justStartedTouching(), etc.
        * You can even use them broadly as boolean values if you&#x27;re feeling saucy!
        * @property touching
        * @type number
        * @public
        */
        public touching: number;


        /**
        * Bit field of flags (use with UP, DOWN, LEFT, RIGHT, etc) indicating surface contacts from the previous game loop step.
        * Use bitwise operators to check the values stored here, or use isTouching().
        * You can even use them broadly as boolean values if you&#x27;re feeling saucy!
        * @property wasTouching
        * @type number
        * @public
        */
        public wasTouching: number;


        /**
		* Bit field of flags (use with UP, DOWN, LEFT, RIGHT, etc) indicating collision directions.
		* Use bitwise operators to check the values stored here.
		* Useful for things like one-way platforms (e.g. allowCollisions = UP)
		* The accessor &quot;solid&quot; just flips this variable between NONE and ANY.
		* @property allowCollisions
        * @type number
        * @public
        */
        public allowCollisions: number;


        /**
		* Important variable for collision processing.
		* Tracks the last location of the Entity. This is set during the time this method &#x27;updates&#x27;.
		* @property last
        * @type Kiwi.Geom.Point
        * @public
        */
        public last: Kiwi.Geom.Point;


        /**
        * A boolean to indicate if this object is solid or not.
        * @property _solid
        * @type boolean
        * @private
        */
        private _solid: boolean;


        /**
        * A function that is to execute when this object overlaps with another.
        * @property _callbackFunction
        * @type Function
        * @default null
        * @private
        */
        private _callbackFunction: any = null;


        /**
        * The context that the callback method should have when it executes.
        * @property _callbackContext
        * @type Any
        * @private
        */
        private _callbackContext: any = null;


        /**
        * Returns a boolean indicating whether the or not the object is currently colliding on a particular side that is passed.
        * Use the collision constants (like LEFT, FLOOR, e.t.c) when passing sides.
        * @method touching
        * @param value [number] The collision constant of the side you want to check against.
        * @return {boolean} If the Object is currently colliding on that side or not.
        * @public
        */
        public isTouching(value: number): boolean {
            return (this.touching &amp; value) == value;
        }


        /**
		* Whether the object should collide with other objects or not.  
        * For more control over what directions the object will collide from, use collision constants (like LEFT, FLOOR, etc)
		* and set the value of allowCollisions directly.
        * @method solid
        * @param [value] {boolean} If left empty, this will then just toggle between ANY and NONE.
        * @return {boolean} If Object is currently solid or not.
        * @public
		*/
        public solid(value?: boolean): boolean {
            if (value !== undefined) {
                if (value)
                    this.allowCollisions = ArcadePhysics.ANY;
                else
                    this.allowCollisions = ArcadePhysics.NONE;
            }

             return (this.allowCollisions &amp; ArcadePhysics.ANY) &gt; ArcadePhysics.NONE;
        }


        /**
        * Sets up a callback function that will run when this object overlaps with another.
        * When the method is dispatched it will have TWO arguments.
        * One - The parent / entity of this ArcadePhysics.
        * Two - The GameObject that the collision occured with.
        * 
        * @method setCallback
        * @param callbackFunction {Function} The method that is to be executed whe a overlap occurs.
        * @param callbackContext {Any} The context that the method is to be called in.
        * @public
        */
        public setCallback(callbackFunction, callbackContext) {
            this._callbackFunction = callbackFunction;
            this._callbackContext = callbackContext;
        }


        /**
        * Returns the parent of this entity. Mainly used for executing callbacks.
        * @property parent
        * @type Kiwi.Entity
        * @public
        */
        public parent: Kiwi.Entity;


        /*
        *---------------
        * Seperation Code
        *---------------
        */


        /**
        * A static method for seperating two normal GameObjects on both the X and Y Axis&#x27;s. 
        * Both objects need to have both an ArcadePhysics Component and a Box component in order for the separate process to succeed.
        * This method is not recommended to be directly used but instead use a &#x27;collide/overlaps&#x27; method instead.
        * 
        * @method seperate
        * @static
        * @param object1 {Kiwi.Entity} The first GameObject you would like to seperate.
        * @param object2 {Kiwi.Entity} The second GameObject you would like to seperate from the first. 
        * @return {boolean}
        * @public
        */
        public static separate(object1: Kiwi.Entity, object2: Kiwi.Entity): boolean {
            
            var separatedX: boolean = this.separateX(object1, object2);
            var separatedY: boolean = this.separateY(object1, object2);
            return separatedX || separatedY;
        }


        /**
		* Separates two passed GameObjects on the x-axis.
        * Both objects need to have both an ArcadePhysics Component and a Box component in order for the separate process to succeed.
        * This method is not recommended to be directly used but instead use a &#x27;collide/overlaps&#x27; method instead.
        *
        * @method seperateX
		* @param object1 {Kiwi.Entity} The first GameObject.
		* @param object2 {Kiwi.Entity} The second GameObject.
		* @return {boolean} Whether the objects in fact touched and were separated along the X axis.
        * @static
        * @public
		*/
        public static separateX(object1: Kiwi.Entity, object2: Kiwi.Entity): boolean {

            //Get the Physics Components.
            var phys1: ArcadePhysics = &lt;ArcadePhysics&gt;object1.components.getComponent(&quot;ArcadePhysics&quot;);
            var phys2: ArcadePhysics = &lt;ArcadePhysics&gt;object2.components.getComponent(&quot;ArcadePhysics&quot;);


            //Can they even be sseparatated? two immovable objects
            if (phys1.immovable &amp;&amp; phys2.immovable)
                return false;


            //First, get the two object deltas
            var overlap: number = 0;
            var obj1delta: number = phys1.transform.worldX - phys1.last.x;
            var obj2delta: number = phys2.transform.worldX - phys2.last.x;


            //Are they the same?
            if (obj1delta == obj2delta) return false;


            //Check if the X hulls actually overlap
            var obj1deltaAbs: number = (obj1delta &gt; 0) ? obj1delta : -obj1delta;
            var obj2deltaAbs: number = (obj2delta &gt; 0) ? obj2delta : -obj2delta;
                

            //Get the world hitboxes.
            var box1 = phys1.box.worldHitbox;
            var box2 = phys2.box.worldHitbox;


            //Where they are now using previous y axis&#x27;s.
            var obj1rect: Kiwi.Geom.Rectangle = new Kiwi.Geom.Rectangle(box1.x - ((obj1delta &gt; 0) ? obj1delta : 0), phys1.last.y + phys1.box.hitboxOffset.y, box1.width + ((obj1delta &gt; 0) ? obj1delta : -obj1delta), box1.height);
            var obj2rect: Kiwi.Geom.Rectangle = new Kiwi.Geom.Rectangle(box2.x - ((obj2delta &gt; 0) ? obj2delta : 0), phys2.last.y + phys2.box.hitboxOffset.y, box2.width + ((obj2delta &gt; 0) ? obj2delta : -obj2delta), box2.height);


            //Could also use Kiwi.Geom.Intersect.rectangleToRectangle here...
            if ((obj1rect.x + obj1rect.width &gt; obj2rect.x) &amp;&amp; (obj1rect.x &lt; obj2rect.x + obj2rect.width) &amp;&amp; (obj1rect.y + obj1rect.height &gt; obj2rect.y) &amp;&amp; (obj1rect.y &lt; obj2rect.y + obj2rect.height)) {


                var maxOverlap: number = obj1deltaAbs + obj2deltaAbs + ArcadePhysics.OVERLAP_BIAS;


                if (obj1delta &gt; obj2delta) {

                    overlap = box1.x + box1.width - box2.x;
                    if ((overlap &gt; maxOverlap) || !(phys1.allowCollisions &amp; ArcadePhysics.RIGHT) || !(phys2.allowCollisions &amp; ArcadePhysics.LEFT)) {
                        overlap = 0;
                    } else {
                        phys1.touching |= ArcadePhysics.RIGHT;
                        phys2.touching |= ArcadePhysics.LEFT;
                    }

                } else {

                    overlap = box1.x - box2.width - box2.x;
                    if ((-overlap &gt; maxOverlap) || !(phys1.allowCollisions &amp; ArcadePhysics.LEFT) || !(phys2.allowCollisions &amp; ArcadePhysics.RIGHT)) {
                        overlap = 0;
                    } else {
                        phys1.touching |= ArcadePhysics.LEFT;
                        phys2.touching |= ArcadePhysics.RIGHT;
                    }

                }


            }


            if (overlap != 0) {


                //Get the average velocity
                var obj1v: number = phys1.velocity.x;
                var obj2v: number = phys2.velocity.x;


                if (!phys1.immovable &amp;&amp; !phys2.immovable) { 
                    overlap *= 0.5;
                    phys1.transform.x = phys1.transform.x - overlap;
                    phys2.transform.x = phys2.transform.x + overlap;

                    var obj1velocity: number = Math.sqrt((obj2v * obj2v * phys2.mass) / phys1.mass) * ((obj2v &gt; 0) ? 1 : -1);
                    var obj2velocity: number = Math.sqrt((obj1v * obj1v * phys1.mass) / phys2.mass) * ((obj1v &gt; 0) ? 1 : -1);
                    var average: number = (obj1velocity + obj2velocity) * 0.5;
                    obj1velocity -= average;
                    obj2velocity -= average;
                    phys1.velocity.x = average + obj1velocity * phys1.elasticity;
                    phys2.velocity.x = average + obj2velocity * phys2.elasticity;


                } else if (!phys1.immovable) {
                    phys1.transform.x = phys1.transform.x - overlap;
                    phys1.velocity.x = obj2v - obj1v * phys1.elasticity;


                } else if (!phys2.immovable) {
                    phys2.transform.x = phys2.transform.x + overlap;
                    phys2.velocity.x = obj1v - obj2v * phys2.elasticity;

                }
                return true;

            }

            return false;
        }


        /**
		* Separates two GameObject on the y-axis. This method is executed from the &#x27;separate&#x27; method.
        * Both objects need to have both an ArcadePhysics Component and a Box component in order for the separate process to succeed.
        * This method is not recommended to be directly used but instead use a &#x27;collide/overlaps&#x27; method instead.
		*
        * @method seperateY 
		* @param object1 {Kiwi.Entity} The first GameObject.
		* @param object2 {Kiwi.Entity} The second GameObject.
		* @return {boolean} Whether the objects in fact touched and were separated along the Y axis.
		* @static
        * @public
        */
        public static separateY(object1: Kiwi.Entity, object2: Kiwi.Entity): boolean {


            //Get the Arcade Physics Components
            var phys1: ArcadePhysics = &lt;ArcadePhysics&gt;object1.components.getComponent(&quot;ArcadePhysics&quot;);
            var phys2: ArcadePhysics = &lt;ArcadePhysics&gt;object2.components.getComponent(&quot;ArcadePhysics&quot;); 


            //Can&#x27;t separate two immovable objects
            if (phys1.immovable &amp;&amp; phys2.immovable) return false;


            var overlap: number = 0;
            var obj1delta: number = phys1.transform.worldY - phys1.last.y;
            var obj2delta: number = phys2.transform.worldY - phys2.last.y;


            //Do the deltas match?
            if (obj1delta == obj2delta) return false;


            //Absolute Deltas
            var obj1deltaAbs: number = (obj1delta &gt; 0) ? obj1delta : -obj1delta;
            var obj2deltaAbs: number = (obj2delta &gt; 0) ? obj2delta : -obj2delta;


            //Hitboxes
            var box1 = phys1.box.worldHitbox;
            var box2 = phys2.box.worldHitbox;


            //Rectangles
            var obj1rect: Kiwi.Geom.Rectangle = new Kiwi.Geom.Rectangle(box1.x, box1.y - ((obj1delta &gt; 0) ? obj1delta : 0), box1.width, box1.height + obj1deltaAbs);
            var obj2rect: Kiwi.Geom.Rectangle = new Kiwi.Geom.Rectangle(box2.x, box2.y - ((obj2delta &gt; 0) ? obj2delta : 0), box2.width, box2.height + obj2deltaAbs);


            //Check for overlap
            if ((obj1rect.x + obj1rect.width &gt; obj2rect.x) &amp;&amp; (obj1rect.x &lt; obj2rect.x + obj2rect.width) &amp;&amp; (obj1rect.y + obj1rect.height &gt; obj2rect.y) &amp;&amp; (obj1rect.y &lt; obj2rect.y + obj2rect.height)) {

                var maxOverlap: number = obj1deltaAbs + obj2deltaAbs + ArcadePhysics.OVERLAP_BIAS;

                if (obj1delta &gt; obj2delta) {

                    overlap = box1.y + box1.height - box2.y;
                    if ((overlap &gt; maxOverlap) || !(phys1.allowCollisions &amp; ArcadePhysics.DOWN) || !(phys2.allowCollisions &amp; ArcadePhysics.UP)) {
                        overlap = 0;
                    } else {
                        phys1.touching |= ArcadePhysics.DOWN;
                        phys2.touching |= ArcadePhysics.UP;
                    }

                } else {

                    overlap = box1.y - box2.height - box2.y;
                    if ((-overlap &gt; maxOverlap) || !(phys1.allowCollisions &amp; ArcadePhysics.UP) || !(phys2.allowCollisions &amp; ArcadePhysics.DOWN)) {
                        overlap = 0;
                    } else {
                        phys1.touching |= ArcadePhysics.UP;
                        phys2.touching |= ArcadePhysics.DOWN;
                    }

                }


                //Then adjust their positions and velocities accordingly (if there was any overlap)
                if (overlap != 0) {

                    var obj1v: number = phys1.velocity.y;
                    var obj2v: number = phys2.velocity.y;

                    if (!phys1.immovable &amp;&amp; !phys2.immovable) {

                        overlap *= 0.5;

                        phys1.transform.y = phys1.transform.y - overlap;
                        phys2.transform.y = phys2.transform.y + overlap;

                        var obj1velocity: number = Math.sqrt((obj2v * obj2v * phys2.mass) / phys1.mass) * ((obj2v &gt; 0) ? 1 : -1);
                        var obj2velocity: number = Math.sqrt((obj1v * obj1v * phys1.mass) / phys2.mass) * ((obj1v &gt; 0) ? 1 : -1);
                        var average: number = (obj1velocity + obj2velocity) * 0.5;

                        obj1velocity -= average;
                        obj2velocity -= average;

                        phys1.velocity.y = average + obj1velocity * phys1.elasticity;
                        phys2.velocity.y = average + obj2velocity * phys2.elasticity;

                    }
                    else if (!phys1.immovable) {
                        phys1.transform.y = phys1.transform.y - overlap;
                        phys1.velocity.y = obj2v - obj1v * phys1.elasticity;

                        //This is special case code that handles cases like horizontal moving platforms you can ride
                        if (object2.active &amp;&amp; phys2.moves &amp;&amp; (obj1delta &gt; obj2delta))
                            phys1.transform.x = phys1.transform.worldX + object2.transform.worldX - phys2.last.x;

                    } else if (!phys2.immovable) {
                        phys2.transform.y = phys2.transform.y + overlap;
                        phys2.velocity.y = obj1v - obj2v * phys2.elasticity;

                        //This is special case code that handles cases like horizontal moving platforms you can ride
                        if (object1.active &amp;&amp; phys1.moves &amp;&amp; (obj1delta &lt; obj2delta))
                            phys2.transform.x = phys2.transform.worldX + object1.transform.worldX - phys1.last.x;

                    }

                    return true;
                }


            }


            return false;
        }


        /*
        *---------------
        * Seperation of Tiles Methods
        *---------------
        */


        /**
        * Separates a GameObject from a series of passed Tiles that lie on a TileMapLayer. 
        * The gameobject needs to have a Box Component and an ArcadePhysics Component. 
        * This method is not recommended to be directly used but instead use the &#x27;overlapsTiles&#x27; method instead.
        *
        * @method separateTiles
        * @param object {Kiwi.Entity} The GameObject you are wanting to separate from a tile.
        * @param layer {Kiwi.GameObjects.Tilemap.TileMapLayer} The TileMapLayer that the tiles belong on.
        * @param tiles {Array} 
        * @return {Boolean} If any separation occured.
        * @public
        * @static
        */
        public static separateTiles(object:Entity, layer:Kiwi.GameObjects.Tilemap.TileMapLayer, tiles:any):boolean {

            //Physics Component Found?
            if (object.components.hasComponent(&quot;ArcadePhysics&quot;) == false) return false;


            //Immovable?
            if (object.components.getComponent(&quot;ArcadePhysics&quot;).immovable) return false;

            
            var sepX = false;
            var sepY = false;

            for (var i = 0; i &lt; tiles.length; i++) {

                var tile = tiles[i];

                if(!sepX) sepX = this.separateTilesX(object, layer, tile);
                if(!sepY) sepY = this.separateTilesY(object, layer, tile);
            }
            
            return  sepX || sepY;
            
        }


        /**
        * Separates a GameObjects from an Array of Tiles on the x-axis. 
        * @method separateTilesX
        * @param object {Kiwi.Entity} The GameObject you are wanting to separate from a tile.
        * @param layer {Kiwi.GameObjects.Tilemap.TileMapLayer} The TileMapLayer that the tiles belong on.
        * @param tile {Object} An Object containing the information (x/y/tiletypr) about the tile that is being overlapped.
        * @return {Boolean} If any separation occured.
        * @public
        * @static
        */
        public static separateTilesX(object:Entity, layer:Kiwi.GameObjects.Tilemap.TileMapLayer, tile):boolean {


            //Get Physics
            var phys1: ArcadePhysics = &lt;ArcadePhysics&gt;object.components.getComponent(&quot;ArcadePhysics&quot;);
            var phys2: ArcadePhysics = &lt;ArcadePhysics&gt;layer.components.getComponent(&quot;ArcadePhysics&quot;);


            //First, get the two object deltas
            var obj1delta: number = phys1.transform.worldX - phys1.last.x;
            var obj2delta: number = phys2.transform.worldX - phys2.last.x;


            //If they moved the same amount.
            if (obj1delta == obj2delta) return false;
            

            //Absolute Delta and Overlap
            var obj1deltaAbs: number = (obj1delta &gt; 0) ? obj1delta : -obj1delta;
            var obj2deltaAbs: number = (obj2delta &gt; 0) ? obj2delta : -obj2delta;
            var overlap = 0;
            var maxOverlap: number = obj1deltaAbs + obj2deltaAbs + ArcadePhysics.OVERLAP_BIAS;


            //Quick References
            var box1 = phys1.box.worldHitbox;
            var tileTypes = layer.tilemap.tileTypes;
            var tData = layer.tileData;


            //Box of the GameObject
            var x = phys2.transform.worldX + tile.x;
            var obj1rect: Kiwi.Geom.Rectangle = new Kiwi.Geom.Rectangle(box1.x - ((obj1delta &gt; 0) ? obj1delta : 0), phys1.last.y + phys1.box.hitboxOffset.y, box1.width + ((obj1delta &gt; 0) ? obj1delta : -obj1delta), box1.height);
            var obj2rect: Kiwi.Geom.Rectangle = new Kiwi.Geom.Rectangle(x - ((obj2delta &gt; 0) ? obj2delta : 0), phys2.last.y + tile.y, layer.tileWidth + ((obj2delta &gt; 0) ? obj2delta : -obj2delta), layer.tileHeight);


            //Check to see if they overlap
            if ((obj1rect.x + obj1rect.width &gt; obj2rect.x) &amp;&amp; (obj1rect.x &lt; obj2rect.x + obj2rect.width) &amp;&amp; (obj1rect.y + obj1rect.height &gt; obj2rect.y) &amp;&amp; (obj1rect.y &lt; obj2rect.y + obj2rect.height)) {

                //Which way the delta is going
                if (obj1delta &gt; obj2delta) {

                    overlap = box1.x + box1.width - x;
                    if ((overlap &gt; maxOverlap) || !(phys1.allowCollisions &amp; ArcadePhysics.RIGHT) || !(tileTypes[tData[tile.index]].allowCollisions &amp; ArcadePhysics.LEFT)) {
                        overlap = 0;
                    } else {
                        phys1.touching |= ArcadePhysics.RIGHT;
                    }

                } else {

                    overlap = box1.x - layer.tileWidth - x;
                    if ((-overlap &gt; maxOverlap) || !(phys1.allowCollisions &amp; ArcadePhysics.LEFT) || !(tileTypes[tData[tile.index]].allowCollisions &amp; ArcadePhysics.RIGHT)) {
                        overlap = 0;
                    } else {
                        phys1.touching |= ArcadePhysics.LEFT;
                    }

                }

                //Resolve the Collision
                if (overlap != 0) {

                    var obj1v: number = phys1.velocity.x;
                    var obj2v: number = phys2.velocity.x;

                    phys1.transform.x = phys1.transform.x - overlap;
                    phys1.velocity.x = obj2v - obj1v * phys1.elasticity;

                    return true;
                }

            }

            return false;
        }


        /**
        * Separates a GameObject from a tiles on the y-axis. 
        * @method separateTilesY
        * @param object {Kiwi.Entity} The GameObject you are wanting to separate from a tile.
        * @param layer {Kiwi.GameObjects.Tilemap.TileMapLayer} The TileMapLayer that the tiles belong on.
        * @param tiles {Object} An Object representing the Tile which we are checking to see any overlaps occurs.
        * @return {Boolean} If any separation occured.
        * @public
        * @static
        */
        public static separateTilesY(object:Entity, layer, tile):boolean {

            //Get the physics.
            var phys1: ArcadePhysics = &lt;ArcadePhysics&gt;object.components.getComponent(&quot;ArcadePhysics&quot;);
            var phys2: ArcadePhysics = &lt;ArcadePhysics&gt;layer.components.getComponent(&quot;ArcadePhysics&quot;);


            //First, get the two object deltas
            var obj1delta: number = phys1.transform.worldY - phys1.last.y;
            var obj2delta: number = phys2.transform.worldY - phys2.last.y;


            //Have they moved the same amount?
            if (obj1delta == obj2delta) return false;


            //Absolute Delta and Max Overlap
            var obj1deltaAbs: number = (obj1delta &gt; 0) ? obj1delta : -obj1delta;
            var obj2deltaAbs: number = (obj2delta &gt; 0) ? obj2delta : -obj2delta;
            var overlap: number = 0;
            var maxOverlap: number = obj1deltaAbs + obj2deltaAbs + ArcadePhysics.OVERLAP_BIAS;

            
            var box1 = phys1.box.worldHitbox;
            var tileTypes = layer.tilemap.tileTypes;
            var tData = layer.tileData;
            var y = layer.transform.worldY + tile.y;


            //Rectangles 
            var obj1rect: Kiwi.Geom.Rectangle = new Kiwi.Geom.Rectangle(box1.x, box1.y - ((obj1delta &gt; 0) ? obj1delta : 0), box1.width, box1.height + obj1deltaAbs);
            var obj2rect: Kiwi.Geom.Rectangle = new Kiwi.Geom.Rectangle(phys2.transform.worldX + tile.x, y - ((obj2delta &gt; 0) ? obj2delta : 0), layer.tileWidth, layer.tileHeight + obj2deltaAbs);


            //Check if they overlap
            if ((obj1rect.x + obj1rect.width &gt; obj2rect.x) &amp;&amp; (obj1rect.x &lt; obj2rect.x + obj2rect.width) &amp;&amp; (obj1rect.y + obj1rect.height &gt; obj2rect.y) &amp;&amp; (obj1rect.y &lt; obj2rect.y + obj2rect.height)) {
                
                if (obj1delta &gt; obj2delta) {

                    overlap = box1.y + box1.height - y;
                    if ((overlap &gt; maxOverlap) || !(phys1.allowCollisions &amp; ArcadePhysics.DOWN) || !(tileTypes[tData[tile.index]].allowCollisions &amp; ArcadePhysics.UP)) {
                        overlap = 0;
                    } else {
                        phys1.touching |= ArcadePhysics.DOWN;
                    }

                } else {

                    overlap = box1.y - layer.tileHeight - y;
                    if ((-overlap &gt; maxOverlap) || !(phys1.allowCollisions &amp; ArcadePhysics.UP) || !(tileTypes[tData[tile.index]].allowCollisions &amp; ArcadePhysics.DOWN)) {
                        overlap = 0;
                    } else {
                        phys1.touching |= ArcadePhysics.UP;
                    }

                }


                //Resolve the Collision
                if (overlap != 0) {

                    var obj1v: number = phys1.velocity.y;
                    var obj2v: number = phys2.velocity.y;

                    phys1.transform.y = phys1.transform.y - overlap;
                    phys1.velocity.y = obj2v - obj1v * phys1.elasticity;

                    return true;
                }

            }

            return false;
        }


        /* 
        *---------------
        * Instance Functions
        *---------------
        */


        /**
        * A method to check to see if any Tiles with in this parent TileMapLayer overlaps with a GameObject passed.
        * If seperateObjects is true it will seperate the two entities based on their bounding box.
        * ONLY works if the parent of the ArcadePhysics component which is calling this method is a TileMapLayer.
        * Note: The GameObject passed must contain a box component and only if you want to separate the two objects must is ALSO contain an ArcadePhysics component.
        *
        * @method overlapsTiles
        * @param gameObject {Kiwi.Entity} The GameObject you would like to separate with this one.
        * @param [separateObjects=false] {Boolean} If you want the GameObject to be separated from any tile it collides with.
        * @param [collisionType=ANY] {Number} If you want the GameObject to only check for collisions from a particular side of tiles. ANY by default.
        * @return {Boolean} If any gameobject overlapped.
        * @public
        */
        public overlapsTiles(gameObject:Entity, separateObjects:boolean = false, collisionType:number = Kiwi.Components.ArcadePhysics.ANY):boolean {

            //Are we a tilemaplayer?
            if (this.parent.childType() !== Kiwi.TILE_LAYER) return false; 

            var tiles = (&lt;Kiwi.GameObjects.Tilemap.TileMapLayer&gt;this.parent).getOverlappingTiles(gameObject, collisionType);

            if (tiles.length &gt; 0) {
                if (separateObjects) ArcadePhysics.separateTiles(gameObject, &lt;Kiwi.GameObjects.Tilemap.TileMapLayer&gt;this.parent, tiles);

                return true;
            } else {
                return false;
            }
        }


        /**
        * A method to check to see if the parent of this physics component overlaps with another Kiwi.Entity.
        * If seperateObjects is true it will seperate the two entities based on their bounding box.
        * Note: The GameObject passed must contain a box component and only if you want to separate the two objects must is ALSO contain an ArcadePhysics component. 
        * Also: Not to be used for separation from tiles.
        * 
        * @method overlaps
        * @param gameObject {Kiwi.Entity}
        * @param [seperateObjects=false] {boolean}
        * @return {boolean}
        * @public
        */
        public overlaps(gameObject: Entity, separateObjects: boolean = false): boolean {

            if (gameObject.components.hasComponent(&#x27;Box&#x27;) == false) return;

            var box: Kiwi.Components.Box = gameObject.components.getComponent(&#x27;Box&#x27;);

            var result: boolean = (box.worldHitbox.x + box.worldHitbox.width &gt; this.box.worldHitbox.x) &amp;&amp; (box.worldHitbox.x &lt; this.box.worldHitbox.x + this.box.worldHitbox.width) &amp;&amp;
                (box.worldHitbox.y + box.worldHitbox.height &gt; this.box.worldHitbox.y) &amp;&amp; (box.worldHitbox.y &lt; this.box.worldHitbox.y + this.box.worldHitbox.height);

            if (result) {
                if (separateObjects)
                    ArcadePhysics.separate(&lt;Kiwi.Entity&gt;this.owner, gameObject);

                if (this._callbackFunction !== null &amp;&amp; this._callbackContext !== null) {
                    this._callbackFunction.call(this._callbackContext, this.owner, gameObject);
                }
            }

            return result;

        }


        /**
        * A method to check to see if the parent of this physics component overlaps with another individual in a Kiwi Group.
        * 
        * @method overlapsGroup
        * @param group {Kiwi.Group}
        * @param [seperateObjects=false] {boolean} 
        * @return { boolean } If any object in the group overlapped with the GameObject or not.
        * @public
        */
        public overlapsGroup(group: Kiwi.Group, separateObjects: boolean = false): boolean {

            var results: boolean = false;

            for (var i = 0; i &lt; group.members.length; i++) {

                if (group.members[i].childType() === Kiwi.GROUP) {
                    //recursively check overlap
                    this.overlapsGroup(&lt;Kiwi.Group&gt;group.members[i], separateObjects);

                } else {
                    //otherwise its an entity

                    if (this.overlaps(&lt;Kiwi.Entity&gt;group.members[i], separateObjects)) {
                        if (this._callbackContext !== null &amp;&amp; this._callbackFunction !== null)
                            this._callbackFunction.call(this._callbackContext, this.owner, group.members[i]);
                        results = true;
                    }

                }
            }

            return results;
        }


        /**
        * A method to check to see if the parent of this physics component overlaps with any Entities that are held in an Array which is passed.
        *
        * @method overlapsArray
        * @param array {Array} The array of GameObjects you want to check.
        * @param [separateObjects=false] {boolean} If when the objects collide you want them to seperate outwards.
        * @return {boolean} If any overlapping occured or not.
        * @public
        */ 
        public overlapsArray(array: Array&lt;any&gt;, separateObjects: boolean = false): boolean {
            
            var results: boolean = false;

            for (var i = 0; i &lt; array.length; i++) {

                if (typeof array[i].childType !== &quot;undefined&quot;) {

                    if (array[i].childType() == Kiwi.GROUP) {

                        this.overlapsGroup(&lt;Kiwi.Group&gt;array[i], separateObjects);
                        
                    } else {

                        if (this.overlaps(&lt;Kiwi.Entity&gt;array[i], separateObjects)) {
                            if (this._callbackFunction !== null &amp;&amp; this._callbackContext !== null) {
                                this._callbackFunction.call(this._callbackContext, this.owner, array[i]);
                            }
                            results = true;
                        }

                    }

                }

            }
            
            return results;
        }


        /*
        *-------------
        * Motion Methods
        *-------------
        */


        /**
        * Computes the velocity based on the parameters passed.  
        * @method computeVelocity
        * @static
        * @param velocity {number} The currently velocity.
        * @param [acceleration=0] {number} The acceleration of the item.
        * @param [drag=0] {number} The amount of drag effecting the item.
        * @param [max=10000] {number} The maximum velocity.
        * @return {Number} The new velocity
        * @public
        */
        public static computeVelocity(velocity: number, acceleration: number = 0, drag: number = 0, max: number = 10000): number {

            if (acceleration != 0)
                velocity += acceleration * ArcadePhysics.updateInterval;
            else if (drag != 0) {
                drag = drag * ArcadePhysics.updateInterval;
                if (velocity - drag &gt; 0)
                    velocity = velocity - drag;
                else if (velocity + drag &lt; 0)
                    velocity += drag;
                else
                    velocity = 0;
            }
            if ((velocity != 0) &amp;&amp; (max != 10000)) {
                if (velocity &gt; max)
                    velocity = max;
                else if (velocity &lt; -max)
                    velocity = -max;
            }
            return velocity;
        }


        /**
        * Updates the position of this object. Automatically called if the &#x27;moves&#x27; parameter is true.  
        * This called each frame during the update method.
        * 
        * @method updateMotion
        * @private
        */
        public updateMotion() {
            
            var delta: number;
            var velocityDelta: number;
            
            //Update the motion calculated from rotation.
            velocityDelta = (ArcadePhysics.computeVelocity(this.angularVelocity, this.angularAcceleration, this.angularDrag, this.maxAngular) - this.angularVelocity) / 2;
            this.angularVelocity += velocityDelta;
            this.transform.rotation += this.angularVelocity * ArcadePhysics.updateInterval;
            this.angularVelocity += velocityDelta;
           
            //Update the motion on the x-axis.
            velocityDelta = (ArcadePhysics.computeVelocity(this.velocity.x, this.acceleration.x, this.drag.x, this.maxVelocity.x) - this.velocity.x) / 2;
            this.velocity.x += velocityDelta;
            delta = this.velocity.x * ArcadePhysics.updateInterval;
            this.velocity.x += velocityDelta;
            this.transform.x = this.transform.x + delta;

            //Update the motion on the y-axis.
            velocityDelta = (ArcadePhysics.computeVelocity(this.velocity.y, this.acceleration.y, this.drag.y, this.maxVelocity.y) - this.velocity.y) / 2;
            this.velocity.y += velocityDelta;
            delta = this.velocity.y * ArcadePhysics.updateInterval;
            this.velocity.y += velocityDelta;
            this.transform.y = this.transform.y + delta;
        
        }
    

        /**
        * The Update loop of the physics component
        * @method update
        * @public
        */
        public update() {

            //Flixel preupdate
            this.last.x = this.transform.worldX;
            this.last.y = this.transform.worldY;

            //Flixel postupdate
            if (this.moves)
                this.updateMotion();

            this.wasTouching = this.touching;
            this.touching = ArcadePhysics.NONE;


        }


        /**
        * Removes all properties that refer to other objects or outside of this class in order to flag this object for garbage collection.
        * @method destroy
        * @public
        */
        public destroy() {
            super.destroy();

            delete this.transform;
            delete this.owner;
            delete this._callbackContext;
            delete this._callbackFunction;
        }


        /**
        * The type of object that this is.
        * @method objType
        * @return {string} &quot;ArcadePhysics&quot;
        * @public
        */
        public objType() {
            return &quot;ArcadePhysics&quot;;
        }


        /*
        *----------------
        * Static Functions
        *----------------
        */


        /*
        *----------------
        * Collide Functions - Maps to Overlaps
        *----------------
        */


        /**
        * A Static method to check to see if two objects collide or not. Returns a boolean indicating whether they overlaped or not.
        *
        * @method collide
        * @static
        * @public
        * @param gameObject1 {Kiwi.Entity} The first game object.
        * @param gameObject2 {Kiwi.Entity} The second game object.
        * @param [seperate=true] {boolean} If the two gameobjects should seperated when they collide.
        * @return {boolean}
        */
        public static collide(gameObject1: Entity, gameObject2: Entity, seperate: boolean = true): boolean {
            return ArcadePhysics.overlaps(gameObject1, gameObject2, seperate);
        }


        /**
        * A Static method to check to see if a single entity collides with a group of entities. Returns a boolean indicating whether they overlaped or not.
        *
        * @method collideGroup
        * @static
        * @public
        * @param gameObject {Kiwi.Entity} The entity you would like to check against.
        * @param group {Kiwi.Group} The Kiwi Group that you want to check the entity against. 
        * @param [seperate=true] {boolean} 
        * @return {boolean}
        * @public
        */
        public static collideGroup(gameObject: Entity, group: Kiwi.Group, seperate: boolean = true): boolean {

            return ArcadePhysics.overlapsObjectGroup(gameObject, group, seperate);
        }


        /**
        * A Static method to check to see if a group of entities overlap with another group of entities. Returns a boolean indicating whether they overlaped or not.
        *
        * @method collideGroupGroup
        * @static
        * @public
        * @param group1 {Kiwi.Group} The first Kiwi Group that you want to check the entity against. 
        * @param group2 {Kiwi.Group} The second Kiwi Group that you want to check the entity against. 
        * @param [seperate=true] {boolean}
        * @return {boolean}
        */
        public static collideGroupGroup(group1: Kiwi.Group, group2: Kiwi.Group, seperate: boolean = true): boolean {

            return ArcadePhysics.overlapsGroupGroup(group1, group2, seperate);
        }


        /*
        *-------------
        * Overlap Static Method - Use&#x27;s the Arcade Physics of one of the gameobjects passed.
        *-------------
        */


        /**
        * A Static method to that checks to see if two objects overlap. Returns a boolean indicating whether they did or not.
        *
        * @method overlaps
        * @static
        * @public
        * @param gameObject1 {Kiwi.Entity} The first game object.
        * @param gameObject2 {Kiwi.Entity} The second gameobject you are testing the first against.
        * @param [separateObjects=true] {boolean} 
        * @return {boolean}
        */
        public static overlaps(gameObject1: Entity, gameObject2: Entity, separateObjects: boolean = true): boolean {

            var obj1Physics: ArcadePhysics = gameObject1.components.getComponent(&quot;ArcadePhysics&quot;);
            return obj1Physics.overlaps(gameObject2, separateObjects);
        }


        /**
        * A Static method to that checks to see if a single object overlaps with a group of entities. Returns a boolean indicating whether they did or not.
        *
        * @method overlapsObjectGroup
        * @static
        * @param gameObject {Kiwi.Entity}
        * @param group {Kiwi.Group} 
        * @param [seperateObjects=true] {boolean} If they overlap should the seperate or not
        * @return {boolean}
        * @public
        */
        public static overlapsObjectGroup(gameObject: Entity, group: Kiwi.Group, separateObjects: boolean = true): boolean {

            var objPhysics: ArcadePhysics = gameObject.components.getComponent(&quot;ArcadePhysics&quot;);
            return objPhysics.overlapsGroup(group, separateObjects);
        }


        /**
        * A Static method that checks to see if any objects in one group overlap with objects in another group.
        *
        * @method overlaps
        * @static
        * @param group1 {Kiwi.Group} The first group you would like to check against.
        * @param group2 {Kiwi.Group} The second group you would like to check against.
        * @param [seperate=true] {boolean} If they overlap should the seperate or not
        * @return {boolean}
        * @public
        */
        public static overlapsGroupGroup(group1: Kiwi.Group, group2: Kiwi.Group, separateObjects: boolean = true): boolean {

            var result: boolean = false;

            var members: IChild[] = group1.members;
            var i: number = 0;

            while (i &lt; group1.members.length) {
                if (members[i].childType() == Kiwi.GROUP) {
                    if (ArcadePhysics.overlapsGroupGroup(&lt;Kiwi.Group&gt;members[i++], group2, separateObjects)) result = true;

                } else {
                    if (ArcadePhysics.overlapsObjectGroup(&lt;Kiwi.Entity&gt;members[i++], group2, separateObjects)) result = true;

                }
            }

            return result;
        }


        /**
        * A Static method that checks to see if any objects from an Array collide with a Kiwi Group members.
        * 
        * @method overlapsArrayGroup
        * @param array {Array} An array you want to check collide.
        * @param group {Kiwi.Group} A group of objects you want to check overlaps.
        * @param [seperateObjects=true] {Boolean} If when a collision is found the objects should seperate out.
        * @return {Boolean} 
        * @static
        */
        public static overlapsArrayGroup(array: Array&lt;any&gt;, group: Kiwi.Group, separateObjects: boolean = true) {

            var result: boolean = false;

            //loop through the array 
            for (var i = 0; i &lt; array.length; i++) {
                if (typeof array[i].childType !== &quot;undefined&quot;) {

                    if (array[i].childType() === Kiwi.GROUP) {
                        if (ArcadePhysics.overlapsGroupGroup(&lt;Kiwi.Group&gt;array[i], group, separateObjects))
                            result = true;

                    } else {
                        if (ArcadePhysics.overlapsObjectGroup(&lt;Kiwi.Entity&gt;array[i], group, separateObjects))
                            result = true;
                    }

                }
            }

            return result;
        }


        /*
        *---------------
        * Static Constants 
        *---------------
        */


        /**
        * How often the motion should be updated.
        * @property updateInterval
        * @static
        * @default 1 / 10
        * @type number
        * @public
        */
        public static updateInterval: number = 1 / 10;


        /**
        * Generic value for &quot;left&quot; Used by &lt;code&gt;facing&lt;/code&gt;, &lt;code&gt;allowCollisions&lt;/code&gt;, and &lt;code&gt;touching&lt;/code&gt;.
        * @property LEFT
        * @type number
        * @default 0x0001
        * @public
        * @static
        */
        public static LEFT: number = 0x0001;


        /**
        * Generic value for &quot;right&quot; Used by &lt;code&gt;facing&lt;/code&gt;, &lt;code&gt;allowCollisions&lt;/code&gt;, and &lt;code&gt;touching&lt;/code&gt;.
        * @property RIGHT
        * @type number
        * @default 0x0010
        * @public
        * @static
        */
        public static RIGHT: number = 0x0010;


        /**
        * Generic value for &quot;up&quot; Used by &lt;code&gt;facing&lt;/code&gt;, &lt;code&gt;allowCollisions&lt;/code&gt;, and &lt;code&gt;touching&lt;/code&gt;.
        * @property UP
        * @type number
        * @default 0x0100
        * @public
        * @static
        */
        public static UP: number = 0x0100;


        /**
        * Generic value for &quot;down&quot; Used by &lt;code&gt;facing&lt;/code&gt;, &lt;code&gt;allowCollisions&lt;/code&gt;, and &lt;code&gt;touching&lt;/code&gt;.
        * @property DOWN
        * @type number
        * @default 0x1000
        * @public
        * @static
        */
        public static DOWN: number = 0x1000;


        /**
        * Special-case constant meaning no collisions, used mainly by &lt;code&gt;allowCollisions&lt;/code&gt; and &lt;code&gt;touching&lt;/code&gt;.
        * @property NONE
        * @type number
        * @default 0
        * @public
        * @static
        */
        public static NONE: number = 0;


        /**
        * Special-case constant meaning up, used mainly by &lt;code&gt;allowCollisions&lt;/code&gt; and &lt;code&gt;touching&lt;/code&gt;.
        * @property CEILING
        * @type number
        * @default 0x0100
        * @public
        * @static
        */
        public static CEILING: number = ArcadePhysics.UP;


        /**
        * Special-case constant meaning down, used mainly by &lt;code&gt;allowCollisions&lt;/code&gt; and &lt;code&gt;touching&lt;/code&gt;.
        * @property FLOOR
        * @type number
        * @default 0x1000
        * @public
        * @static
        */
        public static FLOOR: number = ArcadePhysics.DOWN;


        /**
        * Special-case constant meaning only the left and right sides, used mainly by &lt;code&gt;allowCollisions&lt;/code&gt; and &lt;code&gt;touching&lt;/code&gt;.
        * @property WALL
        * @type number
        * @default 0x0011
        * @public
        * @static
        */
        public static WALL: number = ArcadePhysics.LEFT | ArcadePhysics.RIGHT;


        /**
        * Special-case constant meaning any direction, used mainly by &lt;code&gt;allowCollisions&lt;/code&gt; and &lt;code&gt;touching&lt;/code&gt;.
        * @property ANY
        * @type number
        * @default 0x1111
        * @public
        * @static
        */
        public static ANY: number = ArcadePhysics.LEFT | ArcadePhysics.RIGHT | ArcadePhysics.UP | ArcadePhysics.DOWN;


        /**
        * Handy constant used during collision resolution (see &lt;code&gt;separateX()&lt;/code&gt; and &lt;code&gt;separateY()&lt;/code&gt;).
        * @property OVERLAP_BIAS
        * @type number
        * @default 4
        * @public
        * @static
        */
        public static OVERLAP_BIAS: number = 4;


    }

}


    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
