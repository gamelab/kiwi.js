<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\geom\Intersect.ts - Kiwi.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Kiwi.js"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.6.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/GLRenderManager.html">GLRenderManager</a></li>
            
                <li><a href="../classes/GLShaders.html">GLShaders</a></li>
            
                <li><a href="../classes/GLTexture.html">GLTexture</a></li>
            
                <li><a href="../classes/GLTextureManager.html">GLTextureManager</a></li>
            
                <li><a href="../classes/IRenderer.html">IRenderer</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Animation.html">Kiwi.Animations.Animation</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Sequence.html">Kiwi.Animations.Sequence</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tween.html">Kiwi.Animations.Tween</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Back.html">Kiwi.Animations.Tweens.Easing.Back</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Bounce.html">Kiwi.Animations.Tweens.Easing.Bounce</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Circular.html">Kiwi.Animations.Tweens.Easing.Circular</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Cubic.html">Kiwi.Animations.Tweens.Easing.Cubic</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Elastic.html">Kiwi.Animations.Tweens.Easing.Elastic</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Exponential.html">Kiwi.Animations.Tweens.Easing.Exponential</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Linear.html">Kiwi.Animations.Tweens.Easing.Linear</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Quadratic.html">Kiwi.Animations.Tweens.Easing.Quadratic</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Quartic.html">Kiwi.Animations.Tweens.Easing.Quartic</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Quintic.html">Kiwi.Animations.Tweens.Easing.Quintic</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.Easing.Sinusoidal.html">Kiwi.Animations.Tweens.Easing.Sinusoidal</a></li>
            
                <li><a href="../classes/Kiwi.Animations.Tweens.TweenManager.html">Kiwi.Animations.Tweens.TweenManager</a></li>
            
                <li><a href="../classes/Kiwi.Camera.html">Kiwi.Camera</a></li>
            
                <li><a href="../classes/Kiwi.CameraManager.html">Kiwi.CameraManager</a></li>
            
                <li><a href="../classes/Kiwi.Component.html">Kiwi.Component</a></li>
            
                <li><a href="../classes/Kiwi.ComponentManager.html">Kiwi.ComponentManager</a></li>
            
                <li><a href="../classes/Kiwi.Components.AnimationManager.html">Kiwi.Components.AnimationManager</a></li>
            
                <li><a href="../classes/Kiwi.Components.ArcadePhysics.html">Kiwi.Components.ArcadePhysics</a></li>
            
                <li><a href="../classes/Kiwi.Components.Box.html">Kiwi.Components.Box</a></li>
            
                <li><a href="../classes/Kiwi.Components.Input.html">Kiwi.Components.Input</a></li>
            
                <li><a href="../classes/Kiwi.Components.Sound.html">Kiwi.Components.Sound</a></li>
            
                <li><a href="../classes/Kiwi.Entity.html">Kiwi.Entity</a></li>
            
                <li><a href="../classes/Kiwi.Files.DataLibrary.html">Kiwi.Files.DataLibrary</a></li>
            
                <li><a href="../classes/Kiwi.Files.File.html">Kiwi.Files.File</a></li>
            
                <li><a href="../classes/Kiwi.Files.FileStore.html">Kiwi.Files.FileStore</a></li>
            
                <li><a href="../classes/Kiwi.Files.Loader.html">Kiwi.Files.Loader</a></li>
            
                <li><a href="../classes/Kiwi.Game.html">Kiwi.Game</a></li>
            
                <li><a href="../classes/Kiwi.GameManager.html">Kiwi.GameManager</a></li>
            
                <li><a href="../classes/Kiwi.GameObjects.Sprite.html">Kiwi.GameObjects.Sprite</a></li>
            
                <li><a href="../classes/Kiwi.GameObjects.StaticImage.html">Kiwi.GameObjects.StaticImage</a></li>
            
                <li><a href="../classes/Kiwi.GameObjects.Textfield.html">Kiwi.GameObjects.Textfield</a></li>
            
                <li><a href="../classes/Kiwi.GameObjects.Tilemap.TileMap.html">Kiwi.GameObjects.Tilemap.TileMap</a></li>
            
                <li><a href="../classes/Kiwi.GameObjects.Tilemap.TileMapLayer.html">Kiwi.GameObjects.Tilemap.TileMapLayer</a></li>
            
                <li><a href="../classes/Kiwi.GameObjects.Tilemap.TileType.html">Kiwi.GameObjects.Tilemap.TileType</a></li>
            
                <li><a href="../classes/Kiwi.Geom.AABB.html">Kiwi.Geom.AABB</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Circle.html">Kiwi.Geom.Circle</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Intersect.html">Kiwi.Geom.Intersect</a></li>
            
                <li><a href="../classes/Kiwi.Geom.IntersectResult.html">Kiwi.Geom.IntersectResult</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Line.html">Kiwi.Geom.Line</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Matrix.html">Kiwi.Geom.Matrix</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Point.html">Kiwi.Geom.Point</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Ray.html">Kiwi.Geom.Ray</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Rectangle.html">Kiwi.Geom.Rectangle</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Transform.html">Kiwi.Geom.Transform</a></li>
            
                <li><a href="../classes/Kiwi.Geom.Vector2.html">Kiwi.Geom.Vector2</a></li>
            
                <li><a href="../classes/Kiwi.Group.html">Kiwi.Group</a></li>
            
                <li><a href="../classes/Kiwi.HUD.HUDComponents.Counter.html">Kiwi.HUD.HUDComponents.Counter</a></li>
            
                <li><a href="../classes/Kiwi.HUD.HUDComponents.Time.html">Kiwi.HUD.HUDComponents.Time</a></li>
            
                <li><a href="../classes/Kiwi.HUD.HUDComponents.WidgetInput.html">Kiwi.HUD.HUDComponents.WidgetInput</a></li>
            
                <li><a href="../classes/Kiwi.HUD.HUDDisplay.html">Kiwi.HUD.HUDDisplay</a></li>
            
                <li><a href="../classes/Kiwi.HUD.HUDManager.html">Kiwi.HUD.HUDManager</a></li>
            
                <li><a href="../classes/Kiwi.HUD.HUDWidget.html">Kiwi.HUD.HUDWidget</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.Bar.html">Kiwi.HUD.Widget.Bar</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.BasicScore.html">Kiwi.HUD.Widget.BasicScore</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.Button.html">Kiwi.HUD.Widget.Button</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.Icon.html">Kiwi.HUD.Widget.Icon</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.IconBar.html">Kiwi.HUD.Widget.IconBar</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.Menu.html">Kiwi.HUD.Widget.Menu</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.MenuItem.html">Kiwi.HUD.Widget.MenuItem</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.TextField.html">Kiwi.HUD.Widget.TextField</a></li>
            
                <li><a href="../classes/Kiwi.HUD.Widget.Time.html">Kiwi.HUD.Widget.Time</a></li>
            
                <li><a href="../classes/Kiwi.IChild.html">Kiwi.IChild</a></li>
            
                <li><a href="../classes/Kiwi.Input.Finger.html">Kiwi.Input.Finger</a></li>
            
                <li><a href="../classes/Kiwi.Input.InputManager.html">Kiwi.Input.InputManager</a></li>
            
                <li><a href="../classes/Kiwi.Input.Key.html">Kiwi.Input.Key</a></li>
            
                <li><a href="../classes/Kiwi.Input.Keyboard.html">Kiwi.Input.Keyboard</a></li>
            
                <li><a href="../classes/Kiwi.Input.Keycodes.html">Kiwi.Input.Keycodes</a></li>
            
                <li><a href="../classes/Kiwi.Input.Mouse.html">Kiwi.Input.Mouse</a></li>
            
                <li><a href="../classes/Kiwi.Input.MouseCursor.html">Kiwi.Input.MouseCursor</a></li>
            
                <li><a href="../classes/Kiwi.Input.Pointer.html">Kiwi.Input.Pointer</a></li>
            
                <li><a href="../classes/Kiwi.Input.Touch.html">Kiwi.Input.Touch</a></li>
            
                <li><a href="../classes/Kiwi.PluginManager.html">Kiwi.PluginManager</a></li>
            
                <li><a href="../classes/Kiwi.Renderers.CanvasRenderer.html">Kiwi.Renderers.CanvasRenderer</a></li>
            
                <li><a href="../classes/Kiwi.Renderers.GLArrayBuffer.html">Kiwi.Renderers.GLArrayBuffer</a></li>
            
                <li><a href="../classes/Kiwi.Renderers.GLElementArrayBuffer.html">Kiwi.Renderers.GLElementArrayBuffer</a></li>
            
                <li><a href="../classes/Kiwi.Signal.html">Kiwi.Signal</a></li>
            
                <li><a href="../classes/Kiwi.SignalBinding.html">Kiwi.SignalBinding</a></li>
            
                <li><a href="../classes/Kiwi.Sound.Audio.html">Kiwi.Sound.Audio</a></li>
            
                <li><a href="../classes/Kiwi.Sound.AudioLibrary.html">Kiwi.Sound.AudioLibrary</a></li>
            
                <li><a href="../classes/Kiwi.Sound.AudioManager.html">Kiwi.Sound.AudioManager</a></li>
            
                <li><a href="../classes/Kiwi.Stage.html">Kiwi.Stage</a></li>
            
                <li><a href="../classes/Kiwi.State.html">Kiwi.State</a></li>
            
                <li><a href="../classes/Kiwi.StateConfig.html">Kiwi.StateConfig</a></li>
            
                <li><a href="../classes/Kiwi.StateManager.html">Kiwi.StateManager</a></li>
            
                <li><a href="../classes/Kiwi.System.Bootstrap.html">Kiwi.System.Bootstrap</a></li>
            
                <li><a href="../classes/Kiwi.System.Browser.html">Kiwi.System.Browser</a></li>
            
                <li><a href="../classes/Kiwi.System.Device.html">Kiwi.System.Device</a></li>
            
                <li><a href="../classes/Kiwi.Textures.SingleImage.html">Kiwi.Textures.SingleImage</a></li>
            
                <li><a href="../classes/Kiwi.Textures.SpriteSheet.html">Kiwi.Textures.SpriteSheet</a></li>
            
                <li><a href="../classes/Kiwi.Textures.TextureAtlas.html">Kiwi.Textures.TextureAtlas</a></li>
            
                <li><a href="../classes/Kiwi.Textures.TextureLibrary.html">Kiwi.Textures.TextureLibrary</a></li>
            
                <li><a href="../classes/Kiwi.Time.Clock.html">Kiwi.Time.Clock</a></li>
            
                <li><a href="../classes/Kiwi.Time.ClockManager.html">Kiwi.Time.ClockManager</a></li>
            
                <li><a href="../classes/Kiwi.Time.MasterClock.html">Kiwi.Time.MasterClock</a></li>
            
                <li><a href="../classes/Kiwi.Time.Timer.html">Kiwi.Time.Timer</a></li>
            
                <li><a href="../classes/Kiwi.Time.TimerEvent.html">Kiwi.Time.TimerEvent</a></li>
            
                <li><a href="../classes/Kiwi.Utils.Canvas.html">Kiwi.Utils.Canvas</a></li>
            
                <li><a href="../classes/Kiwi.Utils.Common.html">Kiwi.Utils.Common</a></li>
            
                <li><a href="../classes/Kiwi.Utils.GameMath.html">Kiwi.Utils.GameMath</a></li>
            
                <li><a href="../classes/Kiwi.Utils.RandomDataGenerator.html">Kiwi.Utils.RandomDataGenerator</a></li>
            
                <li><a href="../classes/Kiwi.Utils.RequestAnimationFrame.html">Kiwi.Utils.RequestAnimationFrame</a></li>
            
                <li><a href="../classes/ShaderManager.html">ShaderManager</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/Animations.html">Animations</a></li>
            
                <li><a href="../modules/Components.html">Components</a></li>
            
                <li><a href="../modules/Easing.html">Easing</a></li>
            
                <li><a href="../modules/Files.html">Files</a></li>
            
                <li><a href="../modules/GameObjects.html">GameObjects</a></li>
            
                <li><a href="../modules/Geom.html">Geom</a></li>
            
                <li><a href="../modules/HUD.html">HUD</a></li>
            
                <li><a href="../modules/HUDComponents.html">HUDComponents</a></li>
            
                <li><a href="../modules/Input.html">Input</a></li>
            
                <li><a href="../modules/Kiwi.html">Kiwi</a></li>
            
                <li><a href="../modules/Renderers.html">Renderers</a></li>
            
                <li><a href="../modules/Shaders.html">Shaders</a></li>
            
                <li><a href="../modules/Sound.html">Sound</a></li>
            
                <li><a href="../modules/System.html">System</a></li>
            
                <li><a href="../modules/Textures.html">Textures</a></li>
            
                <li><a href="../modules/Tilemap.html">Tilemap</a></li>
            
                <li><a href="../modules/Time.html">Time</a></li>
            
                <li><a href="../modules/Tweens.html">Tweens</a></li>
            
                <li><a href="../modules/Utils.html">Utils</a></li>
            
                <li><a href="../modules/Widget.html">Widget</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src\geom\Intersect.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
*  
* @module Kiwi
* @submodule Geom
*/ 

module Kiwi.Geom {

    /**
    * Contains a collection of STATIC methods to help determine and return intersection between geometric objects.
    *
    * @class Intersect
    * @namespace Kiwi.Geom
    * @static
    */
    export class Intersect {

        /**
        * The type of this object.
        * @method objType
        * @return {String}
        * @public
        */
        public objType() {
            return &quot;Intersect&quot;;
        }

        /**
	    * -------------------------------------------------------------------------------------------
	    * Distance
	    * -------------------------------------------------------------------------------------------
	    **/

        /** 
	    * Returns the distance between two sets of coordinates that you specify. 
	    * @method distance
        * @param x1 {Number} The x position of the first coordinate.
        * @param y1 {Number} The y position of the first coordinate.
        * @param x2 {Number} The x position of the second coordinate.
        * @param y2 {Number} The y position of the second coordinate.
        * @return {Number} The distance between the two points.
        * @public
        * @static
	    **/
        static distance(x1: number, y1: number, x2: number, y2: number) {
            return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
        }

        /** 
	    * Returns the distance squared between two sets of coordinates that you specify. 
	    * @method distanceSquared
        * @param x1 {Number} The x position of the first coordinate.
        * @param y1 {Number} The y position of the first coordinate.
        * @param x2 {Number} The x position of the second coordinate.
        * @param y2 {Number} The y position of the second coordinate.
        * @return {Number} The distance between the two points squared.
        * @public
        * @static
	    */
        static distanceSquared(x1: number, y1: number, x2: number, y2: number) {
            return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
        }

        /**
	    * -------------------------------------------------------------------------------------------
	    * Lines
	    * -------------------------------------------------------------------------------------------
	    **/

        /**
	    * Check to see if any two Lines intersect at any point. 
        * Both lines are treated as if they extend infintely through space.
	    * @method lineToLine
	    * @param line1 {Line} The first line object to check
	    * @param line2 {Line} The second line object to check
	    * @param [output=IntersectResult] {IntersectResult} An optional IntersectResult object to store the intersection values in. (One is created if none given)
	    * @return {IntersectResult} An IntersectResult object containing the results of this intersection in x/y
        * @public
        * @static
	    */
        static lineToLine(line1: Line, line2: Line, output: IntersectResult = new IntersectResult): IntersectResult {

            var denom = (line1.x1 - line1.x2) * (line2.y1 - line2.y2) - (line1.y1 - line1.y2) * (line2.x1 - line2.x2);

            if (denom !== 0)
            {
                output.result = true;
                output.x = ((line1.x1 * line1.y2 - line1.y1 * line1.x2) * (line2.x1 - line2.x2) - (line1.x1 - line1.x2) * (line2.x1 * line2.y2 - line2.y1 * line2.x2)) / denom;
                output.y = ((line1.x1 * line1.y2 - line1.y1 * line1.x2) * (line2.y1 - line2.y2) - (line1.y1 - line1.y2) * (line2.x1 * line2.y2 - line2.y1 * line2.x2)) / denom;
            }

            return output;
        }

        /**
	    * Check to see if a Line and a Line Segment intersect at any point. 
        * Note: The first line passed is treated as if it extends infinately though space, 
        * The second is treated as if it only exists between its two points.
	    * @method lineToLineSegment
	    * @param line1 {Line} The first line to check. This is the one that will extend through space infinately.
	    * @param seg {Line} The second line to check. This is the one that will only exist between its two coordinates.
	    * @param [output=IntersectResult] {IntersectResult} An optional IntersectResult object to store the intersection values in (one is created if none given)
	    * @return {IntersectResult} An IntersectResult object containing the results of this intersection.
        * @public
        * @static
	    */
        static lineToLineSegment(line1: Line, seg: Line, output: IntersectResult = new IntersectResult): IntersectResult {

            var denom = (line1.x1 - line1.x2) * (seg.y1 - seg.y2) - (line1.y1 - line1.y2) * (seg.x1 - seg.x2);

            if (denom !== 0)
            {
                output.x = ((line1.x1 * line1.y2 - line1.y1 * line1.x2) * (seg.x1 - seg.x2) - (line1.x1 - line1.x2) * (seg.x1 * seg.y2 - seg.y1 * seg.x2)) / denom;
                output.y = ((line1.x1 * line1.y2 - line1.y1 * line1.x2) * (seg.y1 - seg.y2) - (line1.y1 - line1.y2) * (seg.x1 * seg.y2 - seg.y1 * seg.x2)) / denom;

                var maxX = Math.max(seg.x1, seg.x2);
                var minX = Math.min(seg.x1, seg.x2);
                var maxY = Math.max(seg.y1, seg.y2);
                var minY = Math.min(seg.y1, seg.y2);

                //if (!(output.x &lt;= maxX &amp;&amp; output.x &gt;= minX) || !(output.y &lt;= maxY &amp;&amp; output.y &gt;= minY))
                if ((output.x &lt;= maxX &amp;&amp; output.x &gt;= minX) === true || (output.y &lt;= maxY &amp;&amp; output.y &gt;= minY) === true)
                {
                    output.result = true;
                }

            }

            return output;

        }

        /**
	    * Checks to see if a Line that is passed, intersects at any point another Line that is made by passing a set of coordinates to this method. 
        * Note: The first line will extend infinately through space. 
        * And the second line will only exist between the two points passed.
	    * @method lineToRawSegment
	    * @param line {Line} The line object that extends infinatly through space.
	    * @param x1 {number} The x coordinate of the first point in the second line.
	    * @param y1 {number} The y coordinate of the first point in the second line.
	    * @param x2 {number} The x coordinate of the second point in the second line.
	    * @param y2 {number} The y coordinate of the second point in the second line.
	    * @param [output=IntersectResult] {IntersectResult} An optional IntersectResult object to store the intersection values in (one is created if none given)
	    * @return {IntersectResult} An IntersectResult object containing the results of this intersection in x/y
	    * @static
        * @public
        */
        static lineToRawSegment(line: Line, x1: number, y1: number, x2: number, y2: number, output: IntersectResult = new IntersectResult): IntersectResult {

            var denom = (line.x1 - line.x2) * (y1 - y2) - (line.y1 - line.y2) * (x1 - x2);

            if (denom !== 0)
            {
                output.x = ((line.x1 * line.y2 - line.y1 * line.x2) * (x1 - x2) - (line.x1 - line.x2) * (x1 * y2 - y1 * x2)) / denom;
                output.y = ((line.x1 * line.y2 - line.y1 * line.x2) * (y1 - y2) - (line.y1 - line.y2) * (x1 * y2 - y1 * x2)) / denom;

                var maxX = Math.max(x1, x2);
                var minX = Math.min(x1, x2);
                var maxY = Math.max(y1, y2);
                var minY = Math.min(y1, y2);

                if ((output.x &lt;= maxX &amp;&amp; output.x &gt;= minX) === true || (output.y &lt;= maxY &amp;&amp; output.y &gt;= minY) === true)
                {
                    output.result = true;
                }

            }

            return output;

        }

        /**
	    * Checks to see if a Line and Ray object intersects at any point. 
        * Note: The line in this case extends infinately through space. 
	    * @method lineToRay
	    * @param line1 {Line} The Line object that extends infinatly through space.
	    * @param ray {Ray} The Ray object that you want to check it against.
	    * @param {IntersectResult} An optional IntersectResult object to store the intersection values in (one is created if none given)
	    * @return {IntersectResult} An IntersectResult object containing the results of this intersection in x/y
	    * @public
        * @static
        */
        static lineToRay(line1: Line, ray: Ray, output: IntersectResult = new IntersectResult): IntersectResult {

            var denom = (line1.x1 - line1.x2) * (ray.y1 - ray.y2) - (line1.y1 - line1.y2) * (ray.x1 - ray.x2);

            if (denom !== 0)
            {
                output.x = ((line1.x1 * line1.y2 - line1.y1 * line1.x2) * (ray.x1 - ray.x2) - (line1.x1 - line1.x2) * (ray.x1 * ray.y2 - ray.y1 * ray.x2)) / denom;
                output.y = ((line1.x1 * line1.y2 - line1.y1 * line1.x2) * (ray.y1 - ray.y2) - (line1.y1 - line1.y2) * (ray.x1 * ray.y2 - ray.y1 * ray.x2)) / denom;
                output.result = true; // true unless either of the 2 following conditions are met

                if (!(ray.x1 &gt;= ray.x2) &amp;&amp; output.x &lt; ray.x1)
                {
                    output.result = false;
                }

                if (!(ray.y1 &gt;= ray.y2) &amp;&amp; output.y &lt; ray.y1)
                {
                    output.result = false;
                }
            }

            return output;

        }

        /**
	    * Checks to see if a Line and a Circle intersect at any point.
        * Note: The line passed is assumed to extend infinately through space. 
	    * @method lineToCircle
	    * @param line {Line} The Line object that you want to check it against.
	    * @param circle {Circle} The Circle object to check.
	    * @param [output=Intersect] {IntersectResult} An optional IntersectResult object to store the intersection values in (one is created if none given)
	    * @return {IntersectResult} An IntersectResult object containing the results of this intersection
	    * @public
        * @static
        */
        static lineToCircle(line: Line, circle: Circle, output: IntersectResult = new IntersectResult): IntersectResult {

            //  Get a perpendicular line running to the center of the circle
            if (line.perp(circle.x, circle.y).length &lt;= circle.radius)
            {
                output.result = true;
            }

            return output;

        }

        /**
	    * Check if the Line intersects with each side of a Rectangle.
        * Note: The Line is assumned to extend infinately through space.
	    * @method lineToRectangle
	    * @param line {Line} The Line object to check
	    * @param rectangle {Rectangle} The Rectangle object to check
	    * @param [output=IntersectResult] {IntersectResult} An optional IntersectResult object to store the intersection values in (one is created if none given)
	    * @return {IntersectResult} An IntersectResult object containing the results of this intersection
        * @public
        * @static
	    */
        static lineToRectangle(line: any, rect: Rectangle, output: IntersectResult = new IntersectResult): IntersectResult {

            //  Top of the Rectangle vs the Line
            Intersect.lineToRawSegment(line, rect.x, rect.y, rect.right, rect.y, output);

            if (output.result === true)
            {
                return output;
            }

            //  Left of the Rectangle vs the Line
            Intersect.lineToRawSegment(line, rect.x, rect.y, rect.x, rect.bottom, output);

            if (output.result === true)
            {
                return output;
            }

            //  Bottom of the Rectangle vs the Line
            Intersect.lineToRawSegment(line, rect.x, rect.bottom, rect.right, rect.bottom, output);

            if (output.result === true)
            {
                return output;
            }

            //  Right of the Rectangle vs the Line
            Intersect.lineToRawSegment(line, rect.right, rect.y, rect.right, rect.bottom, output);

            return output;

        }

        /**
	    * -------------------------------------------------------------------------------------------
	    * Line Segment
	    * -------------------------------------------------------------------------------------------
	    **/

        /**
	    * Checks to see if two Line Segments intersect at any point in space. 
        * Note: Both lines are treated as if they only exist between their two line coordinates.
	    * @method lineSegmentToLineSegment
	    * @param line1 {Line} The first line object to check.
	    * @param line2 {Line} The second line object to check.
	    * @param [output=IntersectResult]{IntersectResult} An optional IntersectResult object to store the intersection values in (one is created if none given)
	    * @return {IntersectResult} An IntersectResult object containing the results of this intersection in x/y.
	    * @public
        * @static
        */
        static lineSegmentToLineSegment(line1: Line, line2: Line, output: IntersectResult = new IntersectResult): IntersectResult {

            Intersect.lineToLineSegment(line1, line2, output);

            if (output.result === true)
            {
                if (!(output.x &gt;= Math.min(line1.x1, line1.x2) &amp;&amp; output.x &lt;= Math.max(line1.x1, line1.x2)
                    &amp;&amp; output.y &gt;= Math.min(line1.y1, line1.y2) &amp;&amp; output.y &lt;= Math.max(line1.y1, line1.y2)))
                {
                    output.result = false;
                }
            }

            return output;
        }

        /**
	    * Check if the Line Segment intersects with the Ray.
        * Note: The Line only exists between its two points.
	    * @method lineSegmentToRay
	    * @param line1 {Line} The Line object to check.
	    * @param ray {Line} The Ray object to check.
	    * @param [output=IntersectResult] {IntersectResult} An optional IntersectResult object to store the intersection values in (one is created if none given)
	    * @return {Kiwi.Geom.IntersectResult} An IntersectResult object containing the results of this intersection in x/y
        * @public
        * @static
	    */
        static lineSegmentToRay(line1: Line, ray: Ray, output: IntersectResult = new IntersectResult): IntersectResult {

            Intersect.lineToRay(line1, ray, output);

            if (output.result === true)
            {
                if (!(output.x &gt;= Math.min(line1.x1, line1.x2) &amp;&amp; output.x &lt;= Math.max(line1.x1, line1.x2)
                    &amp;&amp; output.y &gt;= Math.min(line1.y1, line1.y2) &amp;&amp; output.y &lt;= Math.max(line1.y1, line1.y2)))
                {
                    output.result = false;
                }
            }

            return output;

        }

        /**
	    * Check if the Line Segment intersects with the Circle.
        * Note the Line only exists between its point points.
	    * @method lineSegmentToCircle
	    * @param seg {Line} The Line object to check
	    * @param circle {Circle} The Circle object to check
	    * @param [ouput=IntersectResult] {IntersectResult} An optional IntersectResult object to store the intersection values in (one is created if none given)
	    * @return {IntersectResult} An IntersectResult object containing the results of this intersection in x/y
        * @public
        * @static
	    */
        static lineSegmentToCircle(seg: Line, circle: Circle, output: IntersectResult = new IntersectResult): IntersectResult {

            var perp = seg.perp(circle.x, circle.y);

            if (perp.length &lt;= circle.radius)
            {
                //  Line intersects circle - check if segment does
                var maxX = Math.max(seg.x1, seg.x2);
                var minX = Math.min(seg.x1, seg.x2);
                var maxY = Math.max(seg.y1, seg.y2);
                var minY = Math.min(seg.y1, seg.y2);

                if ((perp.x2 &lt;= maxX &amp;&amp; perp.x2 &gt;= minX) &amp;&amp; (perp.y2 &lt;= maxY &amp;&amp; perp.y2 &gt;= minY))
                {
                    output.result = true;
                }
                else
                {
                    //  Worst case - segment doesn&#x27;t traverse center, so no perpendicular connection.
                    if (Intersect.circleContainsPoint(circle, &lt;Point&gt; { x: seg.x1, y: seg.y1 }) || Intersect.circleContainsPoint(circle, &lt;Point&gt; { x: seg.x2, y: seg.y2 }))
                    {
                        output.result = true;
                    }
                }

            }

            return output;
        }

        /**
	    * Check if the Line Segment intersects with any side of a Rectangle.
        * Note: The Line only exists between its two points.
	    * @method lineSegmentToCircle
	    * @param seg {Line} The Line object to check.
	    * @param rect {Rectangle} The Rectangle object to check.
	    * @param [output=IntersectResult] {IntersectResult} An optional IntersectResult object to store the intersection values in (one is created if none given).
	    * @return {IntersectResult} An IntersectResult object containing the results of this intersection in x/y.
	    * @public
        * @static
        */ 
        static lineSegmentToRectangle(seg: Line, rect: Rectangle, output: IntersectResult = new IntersectResult): IntersectResult {

            if (rect.contains(seg.x1, seg.y1) &amp;&amp; rect.contains(seg.x2, seg.y2))
            {
                output.result = true;
            }
            else
            {
                //  Top of the Rectangle vs the Line
                Intersect.lineToRawSegment(seg, rect.x, rect.y, rect.right, rect.bottom, output);

                if (output.result === true)
                {
                    return output;
                }

                //  Left of the Rectangle vs the Line
                Intersect.lineToRawSegment(seg, rect.x, rect.y, rect.x, rect.bottom, output);

                if (output.result === true)
                {
                    return output;
                }

                //  Bottom of the Rectangle vs the Line
                Intersect.lineToRawSegment(seg, rect.x, rect.bottom, rect.right, rect.bottom, output);

                if (output.result === true)
                {
                    return output;
                }

                //  Right of the Rectangle vs the Line
                Intersect.lineToRawSegment(seg, rect.right, rect.y, rect.right, rect.bottom, output);

                return output;

            }

            return output;

        }

        /**
	    * -------------------------------------------------------------------------------------------
	    * Ray
	    * -------------------------------------------------------------------------------------------
	    **/

        /**
	    * Check to see if a Ray intersects at any point with a Rectangle.
	    * @method rayToRectangle
	    * @param ray {Ray} The Ray object to check. 
	    * @param rect {Rectangle} The Rectangle to check.
	    * @param [output=IntersectResult] {IntersectResult} An optional IntersectResult object to store the intersection values in (one is created if none given)
	    * @return {IntersectResult} An IntersectResult object containing the results of this intersection
	    * @public
        * @static
        */
        static rayToRectangle(ray: Ray, rect: Rectangle, output: IntersectResult = new IntersectResult): IntersectResult {

            //  Currently just finds first intersection - might not be closest to ray pt1
            Intersect.lineToRectangle(ray, rect, output);

            return output;

        }

        /**
        * Check whether a Ray intersects a Line segment, returns the parametric value where the intersection occurs.
        * Note: The Line only exists between its two points.
        * @method rayToLineSegment
        * @static
        * @param rayx1 {Number} The origin point of the ray on the x axis.
        * @param rayy1 {Number} The origin point of the ray on the y axis.
        * @param rayx2 {Number} The direction of the ray on the x axis. 
        * @param rayy2 {Number} The direction of the ray on the y axis.
        * @param linex1 {Number} The x of the first point of the line segment.
        * @param liney1 {Number} The y of the first point of the line segment.
        * @param linex2 {Number} The x of the second point of the line segment.
        * @param liney2 {Number} The y of the second point of the line segment.
	    * @param [output=IntersectResult] {IntersectResult} An optional IntersectResult object to store the intersection values in (one is created if none given)
	    * @return {IntersectResult} An IntersectResult object containing the results of this intersection stored in x
        * @public
        */
        static rayToLineSegment(rayx1, rayy1, rayx2, rayy2, linex1, liney1, linex2, liney2, output: IntersectResult = new IntersectResult): IntersectResult {

            var r, s, d;

            // Check lines are not parallel
            if ((rayy2 - rayy1) / (rayx2 - rayx1) != (liney2 - liney1) / (linex2 - linex1))
            {
                d = (((rayx2 - rayx1) * (liney2 - liney1)) - (rayy2 - rayy1) * (linex2 - linex1));

                if (d != 0)
                {
                    r = (((rayy1 - liney1) * (linex2 - linex1)) - (rayx1 - linex1) * (liney2 - liney1)) / d;
                    s = (((rayy1 - liney1) * (rayx2 - rayx1)) - (rayx1 - linex1) * (rayy2 - rayy1)) / d;

                    if (r &gt;= 0)
                    {
                        if (s &gt;= 0 &amp;&amp; s &lt;= 1)
                        {
                            output.result = true;
                            output.x = rayx1 + r * (rayx2 - rayx1), rayy1 + r * (rayy2 - rayy1);
                        }
                    }
                }
            }

            return output;

        }

        /**
	    * -------------------------------------------------------------------------------------------
	    * Circle
	    * -------------------------------------------------------------------------------------------
	    **/

        /**
	    * Check if the two given Circle objects intersect at any point.
	    * @method circleToCircle
	    * @param circle1 {Circle} The first circle object to check.
	    * @param circle2 {Circle} The second circle object to check.
	    * @param [output=IntersectResult] {IntersectResult} An optional IntersectResult object to store the intersection values in (one is created if none given)
	    * @return {IntersectResult} An IntersectResult object containing the results of this intersection
	    * @public
        * @static
        */
        static circleToCircle(circle1: Circle, circle2: Circle, output: IntersectResult = new IntersectResult): IntersectResult {

            output.result = ((circle1.radius + circle2.radius) * (circle1.radius + circle2.radius)) &gt;= Intersect.distanceSquared(circle1.x, circle1.y, circle2.x, circle2.y);

            return output;

        }

        /**
	    * Check if a Circle and a Rectangle intersect with each other at any point. 
	    * @method circleToRectangle
	    * @param circle {Circle} The circle object to check.
	    * @param rect {Rectangle} The Rectangle object to check.
	    * @param [output=IntersectResult] {IntersectResult} An optional IntersectResult object to store the intersection values in (one is created if none given)
	    * @return {IntersectResult} An IntersectResult object containing the results of this intersection
	    * @public
        * @static
        */
        static circleToRectangle(circle: Circle, rect: Rectangle, output: IntersectResult = new IntersectResult): IntersectResult {

            var inflatedRect: Rectangle = rect.clone();

            inflatedRect.inflate(circle.radius, circle.radius);

            output.result = inflatedRect.contains(circle.x, circle.y);

            return output;

        }

        /**
	    * Check if the given Point is found within the given Circle.
	    * @method circleContainsPoint
	    * @param circle {Circle} The circle object to check
	    * @param point {Point} The point object to check
	    * @param [output=IntersectResult] {IntersectResult} An optional IntersectResult object to store the intersection values in (one is created if none given)
	    * @return {IntersectResult} An IntersectResult object containing the results of this intersection
	    * @public
        * @static
        */
        static circleContainsPoint(circle: Circle, point: Point, output: IntersectResult = new IntersectResult): IntersectResult {

            output.result = circle.radius * circle.radius &gt;= Intersect.distanceSquared(circle.x, circle.y, point.x, point.y);

            return output;

        }

        /**
	    * -------------------------------------------------------------------------------------------
	    * Rectangles
	    * -------------------------------------------------------------------------------------------
	    **/

        /**
        * Determines whether the specified point is contained within a given Rectangle object.
        * @method pointToRectangle
        * @param point {Point} The point object being checked.
        * @param rect {Rectangle} The rectangle object being checked.
	    * @param [output=Intersect] {IntersectResult}  An optional IntersectResult object to store the intersection values in (one is created if none given)
        * @return {IntersectResult} An IntersectResult object containing the results of this intersection in x/y/result
        * @public
        * @static
        */
        static pointToRectangle(point: Point, rect: Rectangle, output: IntersectResult = new IntersectResult): IntersectResult {

            output.setTo(point.x, point.y);

            output.result = rect.containsPoint(point);

            return output;

        }

        /**
	    * Check whether two axis aligned rectangles intersect. Return the intersecting rectangle dimensions if they do.
	    * @method rectangleToRectangle
	    * @param rect1 {Rectangle} The first Rectangle object.
	    * @param rect2 {Rectangle} The second Rectangle object.
	    * @param [output=IntersectResult] {IntersectResult} An optional IntersectResult object to store the intersection values in (one is created if none given)
	    * @return {IntersectResult} An IntersectResult object containing the results of this intersection in x/y/width/height
	    * @public
        * @static
        */
        static rectangleToRectangle(rect1: Rectangle, rect2: Rectangle, output: IntersectResult = new IntersectResult): IntersectResult {

            var leftX = Math.max(rect1.x, rect2.x);
            var rightX = Math.min(rect1.right, rect2.right);
            var topY = Math.max(rect1.y, rect2.y);
            var bottomY = Math.min(rect1.bottom, rect2.bottom);

            output.setTo(leftX, topY, rightX - leftX, bottomY - topY, rightX - leftX, bottomY - topY);

            var cx = output.x + output.width * .5;
            var cy = output.y + output.height * .5;

            if ((cx &gt; rect1.x &amp;&amp; cx &lt; rect1.right) &amp;&amp; (cy &gt; rect1.y &amp;&amp; cy &lt; rect1.bottom))
            {
                output.result = true;
            }

            return output;

        }

    }

}
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
